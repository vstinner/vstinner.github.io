<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>asyncio: WSARecv() cancellation causing data loss â€” Victor Stinner blog 3</title>
	<meta name="description" content="Title: asyncio: WSARecv() cancellation causing data loss; Date: 2019-01-31; Author: Victor Stinner">
	<meta name="author" content="Victor Stinner">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
	<!--[if lt IE 9]>
		<script src="https://vstinner.github.io/theme/html5.js"></script>
		<![endif]-->
	<link href="https://vstinner.github.io/theme/css/ipython.css" rel="stylesheet">
	<link href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css" rel="stylesheet">
	<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
	<link href="//maxcdn.bootstrapcdn.com/bootswatch/3.2.0/simplex/bootstrap.min.css" rel="stylesheet">
	<link href="https://vstinner.github.io/theme/css/local.css" rel="stylesheet">
	<link href="https://vstinner.github.io/theme/css/pygments.css" rel="stylesheet">
</head>
<body>
<div class="container">
	<div class="page-header">
		<h1><a href="https://vstinner.github.io/">Victor Stinner blog 3</a>
			<br>	</div>
	<div class="row">
		<div class="col-md-8 col-md-offset-2">
<div class="article" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="text-center article-header">
		<h1 itemprop="name headline" class="article-title">asyncio: WSARecv() cancellation causing data loss</h1>
		<span itemprop="author" itemscope itemtype="http://schema.org/Person">
			<h4 itemprop="name">Victor Stinner</h4>
		</span>
		<time datetime="2019-01-31T15:20:00+01:00" itemprop="datePublished">Thu 31 January 2019</time>
	</div>
	<div>
		Category:
		<span itemprop="articleSection">
			<a href="https://vstinner.github.io/category/cpython.html" rel="category">cpython</a>
		</span>
	</div>
 
	<div>
		Tags:
		<span itemprop="keywords">
			<a href="https://vstinner.github.io/tag/asyncio.html" rel="tag">asyncio</a>
		</span>
	</div>
	<div itemprop="articleBody" class="article-body"><a class="reference external image-reference" href="https://www.flickr.com/photos/joybot/6026542856/"><img alt="Unlocked lock" src="https://vstinner.github.io/images/lock.jpg" /></a>
<p>In December 2017, <strong>Yury Selivanov</strong> pushed the long awaited <tt class="docutils literal">start_tls()</tt>
function.</p>
<p>A newly added test failed on Windows. Later, the test started to fail
randomly on Linux as well. In fact, it was a well hidden race condition in the
asynchronous handshake of <tt class="docutils literal">SSLProtocol</tt> which will take 5 months of work to
be identified and fixed. The bug wasn't a recent regression, but only spotted
thanks to newly added tests.</p>
<p>Even after this bug has been fixed, the same test still failed randomly on
Windows! Once I found how to reproduce the bug, I understood that it's a <strong>very
scary bug</strong>: <tt class="docutils literal">WSARecv()</tt> cancellation randomly caused <strong>data loss</strong>! Again,
it was a very well hidden bug which likely existing since the early days of the
<tt class="docutils literal">ProactorEventLoop</tt> implementation.</p>
<p>Previous article: <a class="reference external" href="https://vstinner.github.io/asyncio-proactor-connect-pipe-race-condition.html">Asyncio: Proactor ConnectPipe() Race Condition</a>.
Next article: <a class="reference external" href="https://vstinner.github.io/asyncio-proactor-wsasend-memory-leak.html">asyncio: WSASend() memory leak</a>.</p>
<div class="section" id="new-start-tls-function">
<h2>New start_tls() function</h2>
<p>The &quot;starttls&quot; feature have been requested since creation of asyncio. At
October 24, 2013, <strong>Guido van Rossum</strong> created <a class="reference external" href="https://github.com/python/asyncio/issues/79">asyncio issue #79</a>:</p>
<blockquote>
<strong>Glyph [Lefkowitz]</strong> and <strong>Antoine [Pitrou]</strong> really want a API to upgrade an
existing Transport/Protocol pair to SSL/TLS, without having to create a new
protocol.</blockquote>
<p>At March 23, 2015, <strong>Giovanni Cannata</strong> created <a class="reference external" href="https://bugs.python.org/issue23749">bpo-23749</a> which is basically the same feature
request. I <a class="reference external" href="https://bugs.python.org/issue23749#msg239022">replied</a>:</p>
<blockquote>
asyncio got a new SSL implementation which makes possible to implement
STARTTLS. Are you interested to implement it?</blockquote>
<p><strong>Elizabeth Myers</strong>, <strong>Antoine Pitrou</strong>, <strong>Guido van Rossum</strong> and
<strong>Yury Selivanov</strong> designed the feature. Yury <a class="reference external" href="https://bugs.python.org/issue23749#msg253495">wrote a prototype</a> in 2015 for PostgreSQL.  In
2017, <strong>Barry Warsaw</strong> <a class="reference external" href="https://bugs.python.org/issue23749#msg293912">wrote his own implementation for SMTP</a>.</p>
<p>At the end of 2017, <strong>four year</strong> after Guido van Rossum created the feature
request, <strong>Yury Selivanov</strong> implemented the feature and pushed the <a class="reference external" href="https://github.com/python/cpython/commit/f111b3dcb414093a4efb9d74b69925e535ddc470">commit
f111b3dc</a>:</p>
<pre class="literal-block">
commit f111b3dcb414093a4efb9d74b69925e535ddc470
Author: Yury Selivanov &lt;yury&#64;magic.io&gt;
Date:   Sat Dec 30 00:35:36 2017 -0500

    bpo-23749: Implement loop.start_tls() (#5039)
</pre>
</div>
<div class="section" id="sslprotocol-race-condition">
<h2>SSLProtocol Race Condition</h2>
<div class="section" id="test-fails-on-appveyor-windows-temporary-fix">
<h3>Test fails on AppVeyor (Windows): temporary fix</h3>
<p>At December 30, 2017, just after Yury pushed his implementation of
<tt class="docutils literal">start_tls()</tt> (the same day), <strong>Antoine Pitrou</strong> reported <a class="reference external" href="https://bugs.python.org/issue32458">bpo-32458</a>: it seems test_asyncio fails
sporadically on AppVeyor:</p>
<pre class="literal-block">
ERROR: test_start_tls_server_1 (test.test_asyncio.test_sslproto.ProactorStartTLS)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &quot;C:\projects\cpython\lib\test\test_asyncio\test_sslproto.py&quot;, line 284, in test_start_tls_server_1
    asyncio.wait_for(main(), loop=self.loop, timeout=10))
  File &quot;C:\projects\cpython\lib\asyncio\base_events.py&quot;, line 440, in run_until_complete
    return future.result()
  File &quot;C:\projects\cpython\lib\asyncio\tasks.py&quot;, line 398, in wait_for
    raise futures.TimeoutError()
concurrent.futures._base.TimeoutError
</pre>
<p><strong>Yury Selivanov</strong> <a class="reference external" href="https://bugs.python.org/issue32458#msg309254">wrote</a>:</p>
<blockquote>
I'm leaving on a two-weeks vacation today.  To avoid risking breaking the workflow, I'll mask this tests on AppVeyor.  I'll investigate this when I get back.</blockquote>
<p>and skipped the test as a <strong>temporary fix</strong>, <a class="reference external" href="https://github.com/python/cpython/commit/0c36bed1c46d07ef91d3e02e69e974e4f3ecd31a">commit 0c36bed1</a>:</p>
<pre class="literal-block">
commit 0c36bed1c46d07ef91d3e02e69e974e4f3ecd31a
Author: Yury Selivanov &lt;yury&#64;magic.io&gt;
Date:   Sat Dec 30 15:40:20 2017 -0500

    bpo-32458: Temporarily mask start-tls proactor test on Windows (#5054)
</pre>
</div>
<div class="section" id="bug-reproduced-on-linux">
<h3>Bug reproduced on Linux</h3>
<p>At May 23, 2018, five month after the bug have been reported, <a class="reference external" href="https://bugs.python.org/issue32458#msg317468">I wrote</a>:</p>
<blockquote>
test_start_tls_server_1() just failed on my Linux. It likely depends on the system load.</blockquote>
<p>Christian Heimes <a class="reference external" href="https://bugs.python.org/issue32458#msg317760">added</a>:</p>
<blockquote>
[On Linux,] It's failing reproducible with OpenSSL 1.1.1 and TLS 1.3
enabled. I haven't seen it failing with TLS 1.2 yet.</blockquote>
<p>At May 28, 2018, I found a reliable way to <a class="reference external" href="https://bugs.python.org/issue32458#msg317833">reproduce the issue on Linux</a>:</p>
<blockquote>
<p>Open 3 terminals and run these commands in parallel:</p>
<ol class="arabic simple">
<li><tt class="docutils literal">./python <span class="pre">-m</span> test test_asyncio <span class="pre">-m</span> test_start_tls_server_1 <span class="pre">-F</span></tt></li>
<li><tt class="docutils literal">./python <span class="pre">-m</span> test <span class="pre">-j16</span> <span class="pre">-r</span></tt></li>
<li><tt class="docutils literal">./python <span class="pre">-m</span> test <span class="pre">-j16</span> <span class="pre">-r</span></tt></li>
</ol>
<p>It's a <strong>race condition</strong> which doesn't depend on the OS, but on the system
load.</p>
</blockquote>
</div>
<div class="section" id="root-issue-identified">
<h3>Root issue identified</h3>
<p>Once I found how to reproduce the bug, I was able to investigate it. I created
<a class="reference external" href="https://bugs.python.org/issue33674">bpo-33674</a>.</p>
<p>I found a race condition in <tt class="docutils literal">SSLProtocol</tt> of <tt class="docutils literal">asyncio/sslproto.py</tt>.
Sometimes, <tt class="docutils literal">_sslpipe.feed_ssldata()</tt> is called before
<tt class="docutils literal">_sslpipe.shutdown()</tt>.</p>
<ul class="simple">
<li><tt class="docutils literal">SSLProtocol.connection_made()</tt> -&gt; <tt class="docutils literal">SSLProtocol._start_handshake()</tt>: <tt class="docutils literal">self._loop.call_soon(self._process_write_backlog)</tt></li>
<li><tt class="docutils literal">SSLProtoco.data_received()</tt>: direct call to <tt class="docutils literal">self._sslpipe.feed_ssldata(data)</tt></li>
<li>Later, <tt class="docutils literal">self._process_write_backlog()</tt> calls <tt class="docutils literal">self._sslpipe.do_handshake()</tt></li>
</ul>
<p>The first <strong>write</strong> is <strong>delayed</strong> by <tt class="docutils literal">call_soon()</tt>, whereas the first
<strong>read</strong> is a <strong>direct call</strong> to the SSL pipe.</p>
<p>Workaround:</p>
<pre class="literal-block">
diff --git a/Lib/asyncio/sslproto.py b/Lib/asyncio/sslproto.py
index 2bfa45dd15..4a5dbb38a1 100644
--- a/Lib/asyncio/sslproto.py
+++ b/Lib/asyncio/sslproto.py
&#64;&#64; -592,7 +592,7 &#64;&#64; class SSLProtocol(protocols.Protocol):
         # (b'', 1) is a special value in _process_write_backlog() to do
         # the SSL handshake
         self._write_backlog.append((b'', 1))
-        self._loop.call_soon(self._process_write_backlog)
+        self._process_write_backlog()
         self._handshake_timeout_handle = \
             self._loop.call_later(self._ssl_handshake_timeout,
                                   self._check_handshake_timeout)
</pre>
<p>Yury Selivanov wrote:</p>
<blockquote>
<p><strong>The fix is correct and the bug is now obvious</strong>: <tt class="docutils literal">data_received()</tt> occurs
pretty much any time after <tt class="docutils literal">connection_made()</tt> call; if <tt class="docutils literal">call_soon()</tt> is
used in <tt class="docutils literal">connection_made()</tt>, <tt class="docutils literal">data_received()</tt> may find the protocol in
an incorrect state.</p>
<p><strong>Kudos Victor for debugging this.</strong></p>
</blockquote>
<p>I pushed <a class="reference external" href="https://github.com/python/cpython/commit/be00a5583a2cb696335c527b921d1868266a42c6">commit be00a558</a>:</p>
<pre class="literal-block">
commit be00a5583a2cb696335c527b921d1868266a42c6
Author: Victor Stinner &lt;vstinner&#64;redhat.com&gt;
Date:   Tue May 29 01:33:35 2018 +0200

    bpo-33674: asyncio: Fix SSLProtocol race (GH-7175)

    Fix a race condition in SSLProtocol.connection_made() of
    asyncio.sslproto: start immediately the handshake instead of using
    call_soon(). Previously, data_received() could be called before the
    handshake started, causing the handshake to hang or fail.
</pre>
<p>... the change is basically a single line change:</p>
<pre class="literal-block">
- self._loop.call_soon(self._process_write_backlog)
+ self._process_write_backlog()
</pre>
<p>I closed <a class="reference external" href="https://bugs.python.org/issue32458">bpo-32458</a> and <strong>Yury
Selivanov</strong> closed <a class="reference external" href="https://bugs.python.org/issue33674">bpo-33674</a>.</p>
</div>
<div class="section" id="not-a-regression">
<h3>Not a regression</h3>
<p>The SSLProtocol race condition wasn't new: it existed since January 2015,
<a class="reference external" href="https://github.com/python/cpython/commit/231b404cb026649d4b7172e75ac394ef558efe60">commit 231b404c</a>:</p>
<pre class="literal-block">
commit 231b404cb026649d4b7172e75ac394ef558efe60
Author: Victor Stinner &lt;victor.stinner&#64;gmail.com&gt;
Date:   Wed Jan 14 00:19:09 2015 +0100

    Issue #22560: New SSL implementation based on ssl.MemoryBIO

    The new SSL implementation is based on the new ssl.MemoryBIO which is only
    available on Python 3.5. On Python 3.4 and older, the legacy SSL implementation
    (using SSL_write, SSL_read, etc.) is used. The proactor event loop only
    supports the new implementation.

    The new asyncio.sslproto module adds _SSLPipe, SSLProtocol and
    _SSLProtocolTransport classes. _SSLPipe allows to &quot;wrap&quot; or &quot;unwrap&quot; a socket
    (switch between cleartext and SSL/TLS).

    Patch written by Antoine Pitrou. sslproto.py is based on gruvi/ssl.py of the
    gruvi project written by Geert Jansen.

    This change adds SSL support to ProactorEventLoop on Python 3.5 and newer!

    It becomes also possible to implement STARTTTLS: switch a cleartext socket to
    SSL.
</pre>
<p>This is the new cool asynchronous SSL implementation written by <strong>Antoine
Pitrou</strong> and <strong>Geert Jansen</strong>. It took <strong>3 years</strong> and <strong>new functional tests</strong>
to discover the race condition.</p>
</div>
</div>
<div class="section" id="wsarecv-cancellation-causing-data-loss">
<h2>WSARecv() cancellation causing data loss</h2>
<div class="section" id="yet-another-very-boring-buildbot-test-failure">
<h3>Yet another very boring buildbot test failure</h3>
<p>At May 30, 2018, the day after I fixed SSLProtocol race condition, I created
<a class="reference external" href="https://bugs.python.org/issue33694">bpo-33694</a>.</p>
<p>test_asyncio.test_start_tls_server_1() got multiple fixes recently (see
<a class="reference external" href="https://bugs.python.org/issue32458">bpo-32458</a> and <a class="reference external" href="https://bugs.python.org/issue33674">bpo-33674</a>)... but it still fails on Python on x86
Windows7 3.x at revision bb9474f1fb2fc7c7ed9f826b78262d6a12b5f9e8 which
contains all these fixes.</p>
<p>The test fails even when test_asyncio is re-run alone (not when other tests run
in parallel).</p>
<p>Example of failure:</p>
<pre class="literal-block">
ERROR: test_start_tls_server_1 (test.test_asyncio.test_sslproto.ProactorStartTLSTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &quot;...\lib\test\test_asyncio\test_sslproto.py&quot;, line 467, in test_start_tls_server_1
    self.loop.run_until_complete(run_main())
  File &quot;...\lib\asyncio\base_events.py&quot;, line 566, in run_until_complete
    raise RuntimeError('Event loop stopped before Future completed.')
RuntimeError: Event loop stopped before Future completed.
</pre>
<p>The test fails also on x86 Windows7 3.7. Moreover, 3.7 got an additional failure:</p>
<pre class="literal-block">
ERROR: test_pipe_handle (test.test_asyncio.test_windows_utils.PipeTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &quot;...\lib\test\test_asyncio\test_windows_utils.py&quot;, line 73, in test_pipe_handle
    raise RuntimeError('expected ERROR_INVALID_HANDLE')
RuntimeError: expected ERROR_INVALID_HANDLE
</pre>
</div>
<div class="section" id="unable-to-reproduce-the-bug">
<h3>Unable to reproduce the bug</h3>
<p><strong>Yury Selivanov</strong> <a class="reference external" href="https://bugs.python.org/issue33694#msg318193">failed to reproduce the issue</a> in Windows 7 VM (on macOS) using:</p>
<ol class="arabic simple">
<li>run <tt class="docutils literal">test_asyncio</tt></li>
<li>run <tt class="docutils literal">test_asyncio.test_sslproto</tt></li>
<li>run <tt class="docutils literal">test_asyncio.test_sslproto <span class="pre">-m</span> test_start_tls_server_1</tt></li>
</ol>
<p><strong>Andrew Svetlov</strong> <a class="reference external" href="https://bugs.python.org/issue33694#msg318194">added</a>:</p>
<blockquote>
I used <tt class="docutils literal">SNDBUF</tt> to enforce send buffer overloading. It is not required by
sendfile tests but I thought that better to have non-mocked way to test such
situations. We can remove the socket buffers size manipulation at all
without any problem.</blockquote>
<p>But Yury Selivanov <a class="reference external" href="https://bugs.python.org/issue33694#msg318195">replied</a>:</p>
<blockquote>
When I tried to do that I think <strong>I was having more failures</strong> with that
test. But really up to you.</blockquote>
<p>Next days, I reported more and more similar failures on Windows buildbots and
AppVeyor (our Windows CI).</p>
</div>
<div class="section" id="root-issue-identified-pause-reading">
<h3>Root issue identified: pause_reading()</h3>
<p>Since this bug became more and more frequent, I decided to work on it. Yury and
Andrew failed to reproduce it.</p>
<p>At June 7, 2018, I managed to <strong>reproduce the bug on Linux</strong> by <a class="reference external" href="https://bugs.python.org/issue33694#msg318869">inserting a
sleep at the right place</a>...
I understood one hour later that my patch is wrong: &quot;it introduces a bug in
the test&quot;.</p>
<p>On the other hand, I found the root cause: calling <tt class="docutils literal">pause_reading()</tt> and
<tt class="docutils literal">resume_reading()</tt> on the transport is not safe. Sometimes, we loose data.
See the <strong>ugly hack</strong> described in the TODO comment below:</p>
<pre class="literal-block">
class _ProactorReadPipeTransport(_ProactorBasePipeTransport,
                                 transports.ReadTransport):
    &quot;&quot;&quot;Transport for read pipes.&quot;&quot;&quot;
    (...)
    def pause_reading(self):
        if self._closing or self._paused:
            return
        self._paused = True

        if self._read_fut is not None and not self._read_fut.done():
            # TODO: This is an ugly hack to cancel the current read future
            # *and* avoid potential race conditions, as read cancellation
            # goes through `future.cancel()` and `loop.call_soon()`.
            # We then use this special attribute in the reader callback to
            # exit *immediately* without doing any cleanup/rescheduling.
            self._read_fut.__asyncio_cancelled_on_pause__ = True

            self._read_fut.cancel()
            self._read_fut = None
            self._reschedule_on_resume = True

        if self._loop.get_debug():
            logger.debug(&quot;%r pauses reading&quot;, self)
</pre>
<p>If you remove the &quot;ugly hack&quot;, the test no longer hangs...</p>
<p>Extract of <tt class="docutils literal">_ProactorReadPipeTransport.set_transport()</tt>:</p>
<pre class="literal-block">
if self.is_reading():
    # reset reading callback / buffers / self._read_fut
    self.pause_reading()
    self.resume_reading()
</pre>
<p>This method <strong>cancels the pending overlapped</strong> <tt class="docutils literal">WSARecv()</tt>, and then creates
a new overlapped <tt class="docutils literal">WSARecv()</tt>.</p>
<p>Even after <tt class="docutils literal">CancelIoEx(old overlapped)</tt>, the IOCP loop still gets an event
for the completion of the cancelled overlapped <tt class="docutils literal">WSARecv()</tt>. Problem: <strong>since
the Python future is cancelled, the event is ignored and so 176 bytes of data
are lost</strong>.</p>
<p>I'm surprised that an overlapped <tt class="docutils literal">WSARecv()</tt> <strong>cancelled</strong> by
<tt class="docutils literal">CancelIoEx()</tt> still returns data when IOCP polls for events.</p>
<p>Something else. The bug occurs when <tt class="docutils literal">CancelIoEx()</tt> (on the current overlapped
<tt class="docutils literal">WSARecv()</tt>) fails internally with <tt class="docutils literal">ERROR_NOT_FOUND</tt>. According to
overlapped.c, it means:</p>
<pre class="literal-block">
/* CancelIoEx returns ERROR_NOT_FOUND if the I/O completed in-between */
</pre>
<p><tt class="docutils literal">HasOverlappedIoCompleted()</tt> returns 0 in that case.</p>
<p>The problem is that currently, <tt class="docutils literal">Overlapped.cancel()</tt> also returns <tt class="docutils literal">None</tt> in
that case, and later the asyncio IOCP loop ignores the completion event and so
<strong>drops incoming received data</strong>.</p>
</div>
<div class="section" id="release-blocker-bug">
<h3>Release blocker bug?</h3>
<p>Yury, Andrew, Ned: I set the priority to release blocker because I'm scared by
what I saw. The START TLS has a race condition in its ProactorEventLoop
implementation. But the bug doesn't see to be specific to START TLS, but rather
to <tt class="docutils literal">transport.set_transport()</tt>, and even more generally to
<tt class="docutils literal">transport.pause_reading()</tt> / <tt class="docutils literal">transport.resume_reading()</tt>. The bug is quite
severe: we loose data and it's really hard to know why (I spent a few hours to
add many many print and try to reproduce on a very tiny reliable unit test). As
an asyncio user, I expect that transports are 100% reliable, and I would first
look into my code (like looking into <tt class="docutils literal">start_tls()</tt> implementation in my case).</p>
<p>If the bug was very specific to <tt class="docutils literal">start_tls()</tt>, I would suggest to &quot;just&quot;
&quot;disable&quot; start_tls() on ProactorEventLoop (sorry, Windows!). But since the
data loss seems to concern basically any application using
<tt class="docutils literal">ProactorEventLoop</tt>, I don't see any simple workaround.</p>
<p><strong>My hope is that a fix can be written shortly</strong> to not block the 3.7.0 final
release for too long :-(</p>
<p>Yury, Andrew: Can you please just confirm that it's a regression and that a
release blocker is justified?</p>
</div>
<div class="section" id="functional-test-reproducing-the-bug">
<h3>Functional test reproducing the bug</h3>
<p>I wrote <a class="reference external" href="https://bugs.python.org/file47632/race.py">race.py script</a>: simple
echo client and server sending packets in both directions.  Pause/resume
reading the client transport every 100 ms to trigger the bug.</p>
<p>Using <tt class="docutils literal">ProactorEventLoop</tt> and 2000 packets of 16 KiB, I easily reproduce the
bug.</p>
<p>So again, it's nothing related to <tt class="docutils literal">start_tls()</tt>, <tt class="docutils literal">start_tls()</tt> was just one
way to spot the bug.</p>
<p>The bug is in Proactor transport: the cancellation of overlapped <tt class="docutils literal">WSARecv()</tt>
sometime drops packets. The bug occurs when <tt class="docutils literal">CancelIoEx()</tt> fails with
<tt class="docutils literal">ERROR_NOT_FOUND</tt> which means that the I/O (<tt class="docutils literal">WSARecv()</tt>) completed.</p>
<p>One solution would be to not cancel <tt class="docutils literal">WSARecv()</tt> on pause_reading(): wait
until the current <tt class="docutils literal">WSARecv()</tt> completes, store data somewhere but don't pass
it to <tt class="docutils literal">protocol.data_received()</tt>, and don't schedule a new <tt class="docutils literal">WSARecv()</tt>.
Once reading is resumed: call <tt class="docutils literal">protocol.data_received()</tt> and schedule a new
<tt class="docutils literal">WSARecv()</tt>.</p>
<p>That would be a workaround. I don't know how to really fix <tt class="docutils literal">WSARecv()</tt>
cancellation without loosing data. A good start would be to modify
<tt class="docutils literal">Overlapped.cancel()</tt> to return a boolean to notice if the overlapped I/O
completed even if we just cancelled it. Currently, the corner case
(<tt class="docutils literal">CancelIoEx()</tt> fails with <tt class="docutils literal">ERROR_NOT_FOUND</tt>) is silently ignored, and then
the IOCP loop silently ignores the event of completed I/O...</p>
</div>
<div class="section" id="fix-the-bug-no-longer-cancel-wsarecv">
<h3>Fix the bug: no longer cancel WSARecv()</h3>
<p>At June 8, 2018, I pushed <a class="reference external" href="https://github.com/python/cpython/commit/79790bc35fe722a49977b52647f9b5fe1deda2b7">commit 79790bc3</a>:</p>
<pre class="literal-block">
commit 79790bc35fe722a49977b52647f9b5fe1deda2b7
Author: Victor Stinner &lt;vstinner&#64;redhat.com&gt;
Date:   Fri Jun 8 00:25:52 2018 +0200

    bpo-33694: Fix race condition in asyncio proactor (GH-7498)

    The cancellation of an overlapped WSARecv() has a race condition
    which causes data loss because of the current implementation of
    proactor in asyncio.

    No longer cancel overlapped WSARecv() in _ProactorReadPipeTransport
    to work around the race condition.

    Remove the optimized recv_into() implementation to get simple
    implementation of pause_reading() using the single _pending_data
    attribute.

    Move _feed_data_to_bufferred_proto() to protocols.py.

    Remove set_protocol() method which became useless.
</pre>
<p>I fixed the root issue (in Python 3.7 and future Python 3.8).</p>
<p>I used my <tt class="docutils literal">race.py</tt> script to validate that the issue is fixed for real.</p>
</div>
</div>
<div class="section" id="conclusion">
<h2>Conclusion</h2>
<p>I fixed one race condition in the asynchronous handshake of <tt class="docutils literal">SSLProtocol</tt>.</p>
<p>I found and fixed a data loss bug caused by <tt class="docutils literal">WSARecv()</tt> cancellation.</p>
<p>Lessons learnt from these two bugs:</p>
<ul class="simple">
<li>You should <strong>write an extensive test suite</strong> for your code.</li>
<li>You should <strong>keep an eye on your continuous integration (CI)</strong>: any tiny test
failure can hide a very severe bug.</li>
</ul>
</div>
</div>
	<hr>
	<h2>Comments</h2>
</div>
		</div>
	</div> 	<!-- <hr> -->
</div> <!-- /container -->
<footer class="aw-footer bg-danger">
	<div class="container"> <!-- footer -->
		<div class="row">
			<div class="col-md-10 col-md-offset-1">
				<div class="row">
					<div class="col-md-3">
						<h4>Navigation</h4>
						<ul class="list-unstyled my-list-style">
							<li><a href="https://vstinner.github.io">Victor Stinner blog 3</a></li>
							<li><a href="https://vstinner.github.io/feeds/all.atom.xml" type="application/atom+xml"><i class="fa fa-rss "></i> atom</a></li>
						</ul>
					</div>
					<div class="col-md-3">
						<h4>Author</h4>
						<ul class="list-unstyled my-list-style">
							<li><a href="https://twitter.com/VictorStinner">Follow @VictorStinner on Twitter</a></li>
						</ul>
					</div>
					<div class="col-md-3">
						<h4>Categories</h4>
						<ul class="list-unstyled my-list-style">
							<li><a href="https://vstinner.github.io/category/benchmark.html">benchmark (8)</a></li>
							<li><a href="https://vstinner.github.io/category/cpython.html">cpython (17)</a></li>
							<li><a href="https://vstinner.github.io/category/linux.html">linux (2)</a></li>
							<li><a href="https://vstinner.github.io/category/python.html">python (41)</a></li>
						</ul>
					</div>
					<div class="col-md-3">
						<h4>Links</h4>
						<ul class="list-unstyled my-list-style">
							<li><a href="http://vstinner.readthedocs.org/">Victor Stinner's Notes</a></li>
						</ul>
					</div>
				</div>
			</div>
		</div>
	</div>
</footer>
<div class="container">
	<div class="row">
		<div class="col-md-12 text-center center-block aw-bottom">
			<p>&copy; Victor Stinner 2016</p>
			<p>Powered by Pelican</p>
		</div>
	</div>
</div>
<!-- JavaScript -->
<script src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
<script type="text/javascript">
jQuery(document).ready(function($) {
	$("div.collapseheader").click(function () {
		$header = $(this).children("span").first();
		$codearea = $(this).children(".input_area");
		$codearea.slideToggle(500, function () {
			$header.text(function () {
				return $codearea.is(":visible") ? "Collapse Code" : "Expand Code";
			});
		});
	});
});
</script>
</body>
</html>