<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Leaks discovered by subinterpreters â€” Victor Stinner blog 3</title>
	<meta name="description" content="Title: Leaks discovered by subinterpreters; Date: 2020-12-23; Author: Victor Stinner">
	<meta name="author" content="Victor Stinner">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
	<!--[if lt IE 9]>
		<script src="https://vstinner.github.io/theme/html5.js"></script>
		<![endif]-->
	<link href="https://vstinner.github.io/theme/css/ipython.css" rel="stylesheet">
	<link href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css" rel="stylesheet">
	<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
	<link href="//maxcdn.bootstrapcdn.com/bootswatch/3.2.0/simplex/bootstrap.min.css" rel="stylesheet">
	<link href="https://vstinner.github.io/theme/css/local.css" rel="stylesheet">
	<link href="https://vstinner.github.io/theme/css/pygments.css" rel="stylesheet">
</head>
<body>
<div class="container">
	<div class="page-header">
		<h1><a href="https://vstinner.github.io/">Victor Stinner blog 3</a>
			<br>	</div>
	<div class="row">
		<div class="col-md-8 col-md-offset-2">
<div class="article" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="text-center article-header">
		<h1 itemprop="name headline" class="article-title">Leaks discovered by subinterpreters</h1>
		<span itemprop="author" itemscope itemtype="http://schema.org/Person">
			<h4 itemprop="name">Victor Stinner</h4>
		</span>
		<time datetime="2020-12-23T14:00:00+01:00" itemprop="datePublished">Wed 23 December 2020</time>
	</div>
	<div>
		Category:
		<span itemprop="articleSection">
			<a href="https://vstinner.github.io/category/cpython.html" rel="category">cpython</a>
		</span>
	</div>
 
	<div>
		Tags:
		<span itemprop="keywords">
			<a href="https://vstinner.github.io/tag/cpython.html" rel="tag">cpython</a>
		</span>
		<span itemprop="keywords">
			<a href="https://vstinner.github.io/tag/subinterpreters.html" rel="tag">subinterpreters</a>
		</span>
	</div>
	<div itemprop="articleBody" class="article-body"><p>This article is about old reference leaks discovered or caused by the work on
isolating subinterpreters: leaks in 6 different modules (gc, _weakref, _abc,
_signal, _ast and _thread).</p>
<img alt="_thread GC bug" src="https://vstinner.github.io/images/thread_gc_bug.jpg" />
<div class="section" id="refleaks-buildbot-failures">
<h2>Refleaks buildbot failures</h2>
<p>With my work on isolating subinterpreters, old bugs about Python objects leaked
at Python exit are suddenly becoming blocker issues on buildbots.</p>
<p>When subinterpreters still share Python objects with the main interpreter, it
is ok-ish to leak these objects at Python exit. Right now (current master
branch), there are still more than 18 000 Python objects which are not
destroyed at Python exit:</p>
<pre class="literal-block">
$ ./python -X showrefcount -c pass
[18411 refs, 6097 blocks]
</pre>
<p>This issue is being solved in the <a class="reference external" href="https://bugs.python.org/issue1635741">bpo-1635741: Py_Finalize() doesn't clear all
Python objects at exit</a> which was
opened almost 14 years ago (2007).</p>
<p>When subinterpreters are better isolated, objects are no longer shared, and
suddenly these leaks make subinterpreters tests failing on Refleak buildbots.
For example, when an extension module is converted to the multiphase
initialization API (PEP 489) or when static types are converted to heap types,
these issues pop up.</p>
<p>It is a blocker issue for me, since I care of having only &quot;green&quot; buildbots (no
test failure), otherwise more serious regressions can be easily missed.</p>
</div>
<div class="section" id="per-interpreter-gc-state">
<h2>Per-interpreter GC state</h2>
<p>In November 2019, I made the state of the GC module per-interpreter in
<a class="reference external" href="https://bugs.python.org/issue36854">bpo-36854</a>
(<a class="reference external" href="https://github.com/python/cpython/commit/7247407c35330f3f6292f1d40606b7ba6afd5700">commit</a>)
and test_atexit started to leak:</p>
<pre class="literal-block">
$ ./python -m test -R 3:3 test_atexit -m test.test_atexit.SubinterpreterTest.test_callbacks_leak
test_atexit leaked [3988, 3986, 3988] references, sum=11962
</pre>
<p>I fixed the usage of the <tt class="docutils literal">PyModule_AddObject()</tt> function in the <tt class="docutils literal">_testcapi</tt>
module (<a class="reference external" href="https://github.com/python/cpython/commit/310e2d25170a88ef03f6fd31efcc899fe062da2c">commit</a>).</p>
<p>I also pushed a <strong>workaround</strong> in <tt class="docutils literal">finalize_interp_clear()</tt>:</p>
<pre class="literal-block">
+    /* bpo-36854: Explicitly clear the codec registry
+       and trigger a GC collection */
+    PyInterpreterState *interp = tstate-&gt;interp;
+    Py_CLEAR(interp-&gt;codec_search_path);
+    Py_CLEAR(interp-&gt;codec_search_cache);
+    Py_CLEAR(interp-&gt;codec_error_registry);
+    _PyGC_CollectNoFail();
</pre>
<p>I dislike having to push a &quot;temporary&quot; workaround, but the Python finalization
is really complex and fragile. Fixing the root issues would require too much
work, whereas I wanted to repair the Refleak buildbots as soon as possible.</p>
<p>In December 2019, the workaround was partially removed (<a class="reference external" href="https://github.com/python/cpython/commit/ac0e1c2694bc199dbd073312145e3c09bee52cc4">commit</a>):</p>
<pre class="literal-block">
-    Py_CLEAR(interp-&gt;codec_search_path);
-    Py_CLEAR(interp-&gt;codec_search_cache);
-    Py_CLEAR(interp-&gt;codec_error_registry);
</pre>
<p>The year after (December 2020), the last GC collection was moved into
<tt class="docutils literal">PyInterpreterState_Clear()</tt>, before finalizating the GC (<a class="reference external" href="https://github.com/python/cpython/commit/eba5bf2f5672bf4861c626937597b85ac0c242b9">commit</a>).</p>
</div>
<div class="section" id="port-weakref-to-multiphase-init">
<h2>Port _weakref to multiphase init</h2>
<p>In March 2020, the <tt class="docutils literal">_weakref</tt> module was ported to the multiphase
initialization API (PEP 489) in <a class="reference external" href="https://bugs.python.org/issue40050">bpo-40050</a> and test_importlib started to leak:</p>
<pre class="literal-block">
$ ./python -m test -R 3:3 test_importlib
test_importlib leaked [6303, 6299, 6303] references, sum=18905
</pre>
<p>The analysis was quite long and complicated. The importlib imported some
extension modules twice and it has to inject frozen modules to &quot;bootstrap&quot; the
code.</p>
<p>At the end, I fixed the issue by removing the now unused <tt class="docutils literal">_weakref</tt> import in
<tt class="docutils literal">importlib._bootstrap_external</tt>
(<a class="reference external" href="https://github.com/python/cpython/commit/83d46e0622d2efdf5f3bf8bf8904d0dcb55fc322">commit</a>).
The fix also avoids importing an extension module twice.</p>
</div>
<div class="section" id="convert-abc-static-types-to-heap-types">
<h2>Convert _abc static types to heap types</h2>
<p>In April 2020, the static types of the <tt class="docutils literal">_abc</tt> extension module were converted
to heap types in <a class="reference external" href="https://bugs.python.org/issue40077">bpo-40077</a>
(<a class="reference external" href="https://github.com/python/cpython/commit/53e4c91725083975598350877e2ed8e2d0194114">commit</a>) and
test_threading started to leak:</p>
<pre class="literal-block">
$ ./python -m test -R 3:3 test_threading
test_threading leaked [19, 19, 19] references, sum=57
</pre>
<p>I created <a class="reference external" href="https://bugs.python.org/issue40149">bpo-40149</a> to track the leak.</p>
<div class="section" id="objects-hold-a-reference-to-heap-types">
<h3>Objects hold a reference to heap types</h3>
<p>In March 2019, the <tt class="docutils literal">PyObject_Init()</tt> function was modified in <a class="reference external" href="https://bugs.python.org/issue35810">bpo-35810</a> to keep a strong reference (<tt class="docutils literal">INCREF</tt>)
to the type if the type is a heap type
(<a class="reference external" href="https://github.com/python/cpython/commit/364f0b0f19cc3f0d5e63f571ec9163cf41c62958">commit</a>):</p>
<pre class="literal-block">
+    if (PyType_GetFlags(tp) &amp; Py_TPFLAGS_HEAPTYPE) {
+        Py_INCREF(tp);
+    }
</pre>
<p>I opened <a class="reference external" href="https://bugs.python.org/issue40217">bpo-40217: The garbage collector doesn't take in account that objects
of heap allocated types hold a strong reference to their type</a> to discuss the regression
(the test_threading leak).</p>
</div>
<div class="section" id="first-workaround-not-merged-force-a-second-garbage-collection">
<h3>First workaround (not merged): force a second garbage collection</h3>
<p>While analysing test_threading regression leak, I identified a first
workaround: add a second <tt class="docutils literal">_PyGC_CollectNoFail()</tt> call in
<tt class="docutils literal">finalize_interp_clear()</tt>.</p>
<p>It was only a workaround which helped to understand the issue, it was not
merged.</p>
</div>
<div class="section" id="first-fix-merged-abc-data-traverse">
<h3>First fix (merged): abc_data_traverse()</h3>
<p>I merged a first fix: add a traverse function to the <tt class="docutils literal">_abc._abc_data</tt> type
(<a class="reference external" href="https://github.com/python/cpython/commit/9cc3ebd7e04cb645ac7b2f372eaafa7464e16b9c">commit</a>):</p>
<pre class="literal-block">
+static int
+abc_data_traverse(_abc_data *self, visitproc visit, void *arg)
+{
+    Py_VISIT(self-&gt;_abc_registry);
+    Py_VISIT(self-&gt;_abc_cache);
+    Py_VISIT(self-&gt;_abc_negative_cache);
+    return 0;
+}
</pre>
</div>
<div class="section" id="second-workaround-not-merged-visit-the-type-in-abc-data-traverse">
<h3>Second workaround (not merged): visit the type in abc_data_traverse()</h3>
<p>A second workaround was identified: add <tt class="docutils literal"><span class="pre">Py_VISIT(Py_TYPE(self));</span></tt> to
the new <tt class="docutils literal">abc_data_traverse()</tt> function.</p>
<p>Again, it was only a workaround which helped to understand the issue, but it
was not merged.</p>
</div>
<div class="section" id="second-fix-merged-call-py-visit-py-type-self-automatically">
<h3>Second fix (merged): call Py_VISIT(Py_TYPE(self)) automatically</h3>
<p>20 days after I opened <a class="reference external" href="https://bugs.python.org/issue40217">bpo-40217</a>,
<strong>Pablo Galindo</strong> modified <tt class="docutils literal">PyType_FromSpec()</tt> to add a wrapper around the
traverse function of heap types to ensure that <tt class="docutils literal">Py_VISIT(Py_TYPE(self))</tt> is
always called (<a class="reference external" href="https://github.com/python/cpython/commit/0169d3003be3d072751dd14a5c84748ab63a249f">commit</a>).</p>
</div>
<div class="section" id="last-fix-merged-fix-every-traverse-function">
<h3>Last fix (merged): fix every traverse function</h3>
<p>In May 2020, <strong>Pablo Galindo</strong> changed his mind. He reverted his
<tt class="docutils literal">PyType_FromSpec()</tt> change and instead fixed traverse function of heap types
(<a class="reference external" href="https://github.com/python/cpython/commit/1cf15af9a6f28750f37b08c028ada31d38e818dd">commit</a>).</p>
<p>At the end, <tt class="docutils literal">abc_data_traverse()</tt> calls <tt class="docutils literal">Py_VISIT(Py_TYPE(self))</tt>. The
second &quot;workaround&quot; was the correct fix!</p>
</div>
</div>
<div class="section" id="convert-signal-to-multiphase-init">
<h2>Convert _signal to multiphase init</h2>
<p>In September 2020, <strong>Mohamed Koubaa</strong> ported the <tt class="docutils literal">_signal</tt> module to the
multiphase initialization API (PEP 489) in <a class="reference external" href="https://bugs.python.org/issue1635741">bpo-1635741</a> (<a class="reference external" href="https://github.com/python/cpython/commit/71d1bd9569c8a497e279f2fea6fe47cd70a87ea3">commit 71d1bd95</a>)
and test_interpreters started to leak:</p>
<pre class="literal-block">
$ ./python -m test -R 3:3 test_interpreters
test_interpreters leaked [237, 237, 237] references, sum=711
</pre>
<p>I created <a class="reference external" href="https://bugs.python.org/issue41713">bpo-41713</a> to track the
regression. Since I failed to find a simple fix, I started by reverting the
change which caused Refleak buildbots to fail (<a class="reference external" href="https://github.com/python/cpython/commit/4b8032e5a4994a7902076efa72fca1e2c85d8b7f">commit</a>).</p>
<p>I had to refactor the <tt class="docutils literal">_signal</tt> extension module code with multiple commits
to fix all bugs.</p>
<p>The first fix was to remove the <tt class="docutils literal">IntHandler</tt> variable: there was no need to
keep it alive, it was only needed once in <tt class="docutils literal">signal_module_exec()</tt>.</p>
<p>The second fix is to close the Windows event at exit:</p>
<pre class="literal-block">
+ #ifdef MS_WINDOWS
+     if (sigint_event != NULL) {
+         CloseHandle(sigint_event);
+         sigint_event = NULL;
+     }
+ #endif
</pre>
<p>The last fix, the most important, is to clear the strong reference to old
Python signal handlers when <tt class="docutils literal">signal_module_exec()</tt> is called more than once:</p>
<pre class="literal-block">
// If signal_module_exec() is called more than one, we must
// clear the strong reference to the previous function.
Py_XSETREF(Handlers[signum].func, Py_NewRef(func));
</pre>
<p>The <tt class="docutils literal">_signal</tt> module is not well isolated for subinterpreters yet, but at
least it no longer leaks.</p>
</div>
<div class="section" id="per-interpreter-ast-state">
<h2>Per-interpreter _ast state</h2>
<p>In September 2019, the <tt class="docutils literal">_ast</tt> extension module was converted to PEP 384
(stable ABI) in <a class="reference external" href="https://bugs.python.org/issue38113">bpo-38113</a> (<a class="reference external" href="https://github.com/python/cpython/commit/ac46eb4ad6662cf6d771b20d8963658b2186c48c">commit</a>):
the AST state moves into a module state.</p>
<p>This change caused 3 different bugs including crashes (<a class="reference external" href="https://bugs.python.org/issue41194">bpo-41194</a>, <a class="reference external" href="https://bugs.python.org/issue41261">bpo-41261</a>, <a class="reference external" href="https://bugs.python.org/issue41631">bpo-41631</a>). The issue is complex since there are
public C APIs which require to access AST types, whereas it became possible to
have multiple <tt class="docutils literal">_ast</tt> extension module instances.</p>
<p>In July 2020, I fixed the root issue in <a class="reference external" href="https://bugs.python.org/issue41194">bpo-41194</a> by replacing the module state with a
global state (<a class="reference external" href="https://github.com/python/cpython/commit/91e1bc18bd467a13bceb62e16fbc435b33381c82">commit</a>):</p>
<pre class="literal-block">
static astmodulestate global_ast_state;
</pre>
<p>A global state is bad for subinterpreters. In November 2020, I made the AST
state per-interpreter in <a class="reference external" href="https://bugs.python.org/issue41796">bpo-41796</a>
(<a class="reference external" href="https://github.com/python/cpython/commit/5cf4782a2630629d0978bf4cf6b6340365f449b2">commit</a>
and test_ast started to leak:</p>
<pre class="literal-block">
$ ./python -m test -R 3:3 test_ast
test_ast leaked [23640, 23636, 23640] references, sum=70916
</pre>
<p>The fix is to call <tt class="docutils literal">_PyAST_Fini()</tt> earlier (<a class="reference external" href="https://github.com/python/cpython/commit/fd957c124c44441d9c5eaf61f7af8cf266bafcb1">commit</a>).</p>
<p>Python types contain a reference to themselves in in their
<tt class="docutils literal">PyTypeObject.tp_mro</tt> member (the MRO tuple: Method Resolution Order).
<tt class="docutils literal">_PyAST_Fini()</tt> must called before the last GC collection to destroy AST
types.</p>
<p><tt class="docutils literal">_PyInterpreterState_Clear()</tt> now calls <tt class="docutils literal">_PyAST_Fini()</tt>. It now also
calls <tt class="docutils literal">_PyWarnings_Fini()</tt> on subinterpeters, not only on the main
interpreter.</p>
</div>
<div class="section" id="thread-lock-traverse">
<h2>_thread lock traverse</h2>
<p>In December 2020, while I tried to port the <tt class="docutils literal">_thread</tt> extesnion module to the multiphase initialization API
(PEP 489), test_threading started to leak:</p>
<pre class="literal-block">
$ ./python -m test -R 3:3 test_threading
test_threading leaked [56, 56, 56] references, sum=168
</pre>
<p>As usual, the workaround was to force a second GC collection in <tt class="docutils literal">interpreter_clear()</tt>:</p>
<pre class="literal-block">
     /* Last garbage collection on this interpreter */
     _PyGC_CollectNoFail(tstate);
+    _PyGC_CollectNoFail(tstate);
     _PyGC_Fini(tstate);
</pre>
<p>It took me two days to full understand the problem. I drew reference cycles
on paper to help me to understand the problem:</p>
<img alt="_thread GC bug" src="https://vstinner.github.io/images/thread_gc_bug.jpg" />
<p>There are two cycles:</p>
<ul class="simple">
<li>Cycle 1:<ul>
<li>at fork function</li>
<li>-&gt; __main__ module dict</li>
<li>-&gt; at fork function</li>
</ul>
</li>
<li>Cycle 2:<ul>
<li>_thread lock type</li>
<li>-&gt; lock type methods</li>
<li>-&gt; _thread module dict</li>
<li>-&gt; _thread local type</li>
<li>-&gt; _thread module</li>
<li>-&gt; _thread module state</li>
<li>-&gt; _thread lock type</li>
</ul>
</li>
</ul>
<p>Moreover, there is a link between these two reference cycles: an instance of
the lock type.</p>
<p>I fixed the issue by adding a traverse function to the lock type and add
<tt class="docutils literal">Py_TPFLAGS_HAVE_GC</tt> flag to the type (<a class="reference external" href="https://github.com/python/cpython/commit/6104013838e181e3c698cb07316f449a0c31ea96">commit</a>):</p>
<pre class="literal-block">
+static int
+lock_traverse(lockobject *self, visitproc visit, void *arg)
+{
+    Py_VISIT(Py_TYPE(self));
+    return 0;
+}
</pre>
</div>
<div class="section" id="notes-on-weird-gc-bugs">
<h2>Notes on weird GC bugs</h2>
<ul class="simple">
<li><tt class="docutils literal">gc.get_referents()</tt> and <tt class="docutils literal">gc.get_referrers()</tt> can be used to check
traverse functions.</li>
<li><tt class="docutils literal">gc.is_tracked()</tt> can be used to check if the GC tracks an object.</li>
<li>Using the <tt class="docutils literal">gdb</tt> debugger on <tt class="docutils literal">gc_collect_main()</tt> helps to see which
objects are collected. See for example the <tt class="docutils literal">finalize_garbage()</tt> functions
which calls finalizers on unreachable objects.</li>
<li>The solution is usually a missing traverse functions or a missing
<tt class="docutils literal">Py_VISIT()</tt> in an existing traverse function.</li>
<li>GC bugs are hard to debug :-)</li>
</ul>
<p>Thanks <strong>Pablo Galindo</strong> for helping me to debug all these tricky GC bugs!</p>
<p>Thanks to everybody who are helping to better isolate subintrepreters by
converting extension modules to the multiphase initialization API (PEP 489) and
by converting dozens of static types to heap types. We made huge progresses
last months!</p>
</div>
</div>
	<hr>
	<h2>Comments</h2>
</div>
		</div>
	</div> 	<!-- <hr> -->
</div> <!-- /container -->
<footer class="aw-footer bg-danger">
	<div class="container"> <!-- footer -->
		<div class="row">
			<div class="col-md-10 col-md-offset-1">
				<div class="row">
					<div class="col-md-3">
						<h4>Navigation</h4>
						<ul class="list-unstyled my-list-style">
							<li><a href="https://vstinner.github.io">Victor Stinner blog 3</a></li>
							<li><a href="https://vstinner.github.io/feeds/all.atom.xml" type="application/atom+xml"><i class="fa fa-rss "></i> atom</a></li>
						</ul>
					</div>
					<div class="col-md-3">
						<h4>Author</h4>
						<ul class="list-unstyled my-list-style">
							<li><a href="https://twitter.com/VictorStinner">Follow @VictorStinner on Twitter</a></li>
						</ul>
					</div>
					<div class="col-md-3">
						<h4>Categories</h4>
						<ul class="list-unstyled my-list-style">
							<li><a href="https://vstinner.github.io/category/benchmark.html">benchmark (8)</a></li>
							<li><a href="https://vstinner.github.io/category/cpython.html">cpython (21)</a></li>
							<li><a href="https://vstinner.github.io/category/linux.html">linux (2)</a></li>
							<li><a href="https://vstinner.github.io/category/python.html">python (41)</a></li>
						</ul>
					</div>
					<div class="col-md-3">
						<h4>Links</h4>
						<ul class="list-unstyled my-list-style">
							<li><a href="http://vstinner.readthedocs.org/">Victor Stinner's Notes</a></li>
						</ul>
					</div>
				</div>
			</div>
		</div>
	</div>
</footer>
<div class="container">
	<div class="row">
		<div class="col-md-12 text-center center-block aw-bottom">
			<p>&copy; Victor Stinner 2016</p>
			<p>Powered by Pelican</p>
		</div>
	</div>
</div>
<!-- JavaScript -->
<script src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
<script type="text/javascript">
jQuery(document).ready(function($) {
	$("div.collapseheader").click(function () {
		$header = $(this).children("span").first();
		$codearea = $(this).children(".input_area");
		$codearea.slideToggle(500, function () {
			$header.text(function () {
				return $codearea.is(":visible") ? "Collapse Code" : "Expand Code";
			});
		});
	});
});
</script>
</body>
</html>