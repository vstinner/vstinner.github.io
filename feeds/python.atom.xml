<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Haypo blog 2</title><link href="https://haypo.github.io/" rel="alternate"></link><link href="https://haypo.github.io/feeds/python.atom.xml" rel="self"></link><id>https://haypo.github.io/</id><updated>2017-02-14T12:00:00+01:00</updated><entry><title>PEP 524: os.urandom() now blocks on Linux</title><link href="https://haypo.github.io/pep-524-os-urandom-blocking.html" rel="alternate"></link><published>2017-02-14T12:00:00+01:00</published><author><name>Victor Stinner</name></author><id>tag:haypo.github.io,2017-02-14:pep-524-os-urandom-blocking.html</id><summary type="html">&lt;div class="section" id="getrandom-avoids-file-descriptors"&gt;
&lt;h2&gt;getrandom() avoids file descriptors&lt;/h2&gt;
&lt;p&gt;Last years, I'm making sometimes enhancements in the Python code used to
generate random numbers, the C implementation of &lt;tt class="docutils literal"&gt;os.urandom()&lt;/tt&gt;. My main two
changes were to use the new &lt;tt class="docutils literal"&gt;getentropy()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;getrandom()&lt;/tt&gt; functions when
available on Linux, Solaris, OpenBSD, etc.&lt;/p&gt;
&lt;p&gt;In 2013, &lt;tt class="docutils literal"&gt;os.urandom()&lt;/tt&gt; opened a file descriptor to read from
&lt;tt class="docutils literal"&gt;/dev/urandom&lt;/tt&gt; and then closed it. It was decided to use a single private
file descriptor and keep it open to prevent &lt;tt class="docutils literal"&gt;EMFILE&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;ENFILE&lt;/tt&gt; errors
(too many open files) under high system loads with many threads: see the issue
#18756.&lt;/p&gt;
&lt;p&gt;The private file descriptor introduced a backward incompatible change in badly
written programs. The code was modified to call &lt;tt class="docutils literal"&gt;fstat()&lt;/tt&gt; to check if the
file descriptor was closed and then replaced with a different file descriptor
(but same number): check if &lt;tt class="docutils literal"&gt;st_dev&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;st_ino&lt;/tt&gt; attributes changed.&lt;/p&gt;
&lt;p&gt;In 2014, the new Linux kernel 3.17 added a new &lt;tt class="docutils literal"&gt;getrandom()&lt;/tt&gt; syscall which
gives access to random bytes without having to handle a file descriptor. I
modified &lt;tt class="docutils literal"&gt;os.urandom()&lt;/tt&gt; to call &lt;tt class="docutils literal"&gt;getrandom()&lt;/tt&gt; to avoid file descriptors,
but a different issue appeared.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="getrandom-hangs-at-system-startup"&gt;
&lt;h2&gt;getrandom() hangs at system startup&lt;/h2&gt;
&lt;p&gt;On embedded devices and virtual machines, Python 3.5 started to hang at
startup.&lt;/p&gt;
&lt;p&gt;On Debian, a systemd script used Python to compute a MD5 checksum, but Python
was blocked during its initialization. Other users reported that Python blocked
on importing the &lt;tt class="docutils literal"&gt;random&lt;/tt&gt; module, sometimes imported indirectly by a
different module.&lt;/p&gt;
&lt;p&gt;Python was blocked on the &lt;tt class="docutils literal"&gt;getrandom(0)&lt;/tt&gt; syscall, waiting until the system
collected enough entropy to initialize the urandom pool. It took longer than 90
seconds, so systemd killed the service with a timeout. As a consequence, the
system boot takes longer than 90 seconds or can even fail!&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="fix-python-startup"&gt;
&lt;h2&gt;Fix Python startup&lt;/h2&gt;
&lt;p&gt;The fix was obvious: call &lt;tt class="docutils literal"&gt;getrandom(GRND_NONBLOCK)&lt;/tt&gt; which fails immediately
if the call would block, and fall back on reading from &lt;tt class="docutils literal"&gt;/dev/urandom&lt;/tt&gt; which
doesn't block even if the entropy pool is not initialized yet.&lt;/p&gt;
&lt;p&gt;Quickly, our security experts complained that falling back on &lt;tt class="docutils literal"&gt;/dev/urandom&lt;/tt&gt;
makes Python less secure. When the fall back path is taken, &lt;tt class="docutils literal"&gt;/dev/urandom&lt;/tt&gt;
returns random number not suitable for security purpose (initialized with low
entropy), wheras &lt;a class="reference external" href="https://docs.python.org/dev/library/os.html#os.urandom"&gt;os.urandom() documenation&lt;/a&gt; says: &amp;quot;The returned
data should be unpredictable enough for cryptographic applications&amp;quot; (and
&amp;quot;though its exact quality depends on the OS implementation.&amp;quot;).&lt;/p&gt;
&lt;p&gt;Calling &lt;tt class="docutils literal"&gt;getrandom()&lt;/tt&gt; in blocking mode for &lt;tt class="docutils literal"&gt;os.urandom()&lt;/tt&gt; makes Python more
secure, but it doesn't fix the startup bug.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="discussion-storm"&gt;
&lt;h2&gt;Discussion storm&lt;/h2&gt;
&lt;p&gt;The proposed change started a huge rain of messages. More than 200 messages,
maybe even more than 500 messages, on the bug tracker and python-dev mailing
list. Everyone became a security expert and wanted to give his/her very
important opinion, without listening to other arguments.&lt;/p&gt;
&lt;p&gt;Two Python security experts left the discussion.&lt;/p&gt;
&lt;p&gt;I also ignored new messages. I simply had not enough time to read all of them,
and the discussion tone made me angry.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="new-mailing-list-and-two-new-peps"&gt;
&lt;h2&gt;New mailing list and two new PEPs&lt;/h2&gt;
&lt;p&gt;A new &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;security-sig&lt;/span&gt;&lt;/tt&gt; mailing list, subtitled &amp;quot;os.urandom rehab clinic&amp;quot;, was
created just to take a decision on &lt;tt class="docutils literal"&gt;os.urandom()&lt;/tt&gt;!&lt;/p&gt;
&lt;p&gt;Nick Coghlan wrote the &lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0522/"&gt;PEP 522: Allow BlockingIOError in security sensitive
APIs&lt;/a&gt;. Basically: he considers
that there is no good default behaviour when &lt;tt class="docutils literal"&gt;os.urandom()&lt;/tt&gt; would block, so
raise an exception to let users decide.&lt;/p&gt;
&lt;p&gt;I wrote  &lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0524/"&gt;PEP 524: Make os.urandom() blocking on Linux&lt;/a&gt;. My PEP proposes to make
&lt;tt class="docutils literal"&gt;os.urandom()&lt;/tt&gt; blocking, &lt;em&gt;but&lt;/em&gt; also modify Python startup to fall back on
non-blocking RNG to initialize the secret hash seed and the &lt;tt class="docutils literal"&gt;random&lt;/tt&gt; module
(which is &lt;em&gt;not&lt;/em&gt; sensitive for security, except of &lt;tt class="docutils literal"&gt;random.SystemRandom&lt;/tt&gt;).&lt;/p&gt;
&lt;p&gt;Nick's PEP describes an important use case: be able to check if
&lt;tt class="docutils literal"&gt;os.urandom()&lt;/tt&gt; would block. Instead of adding a flag to &lt;tt class="docutils literal"&gt;os.urandom()&lt;/tt&gt;,
I chose to expose the low-level C
&lt;tt class="docutils literal"&gt;getrandom()&lt;/tt&gt; function as a new Python &lt;tt class="docutils literal"&gt;os.getrandom()&lt;/tt&gt; function. Calling
&lt;tt class="docutils literal"&gt;os.getrandom(1, os.GRND_NONBLOCK)&lt;/tt&gt; raises a &lt;tt class="docutils literal"&gt;BlockingIOError&lt;/tt&gt; exception,
as Nick proposed for &lt;tt class="docutils literal"&gt;os.urandom()&lt;/tt&gt;, so it's possible to decide what to do in
this case.&lt;/p&gt;
&lt;p&gt;While both PEPs are valid, IMHO my PEP was &lt;em&gt;less&lt;/em&gt; backward incompatible,
simpler and maybe closer to what users &lt;em&gt;expect&lt;/em&gt;. The &amp;quot;os.urandom() would block&amp;quot;
case is a special case with my PEP, but my PEP allows to decide what to do in
that case (thanks to &lt;tt class="docutils literal"&gt;os.getrandom()&lt;/tt&gt;).&lt;/p&gt;
&lt;p&gt;Guido van Rossum approved my PEP and rejected Nick's PEP. I worked with Nick to
implement my PEP.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="python-3-6-changes"&gt;
&lt;h2&gt;Python 3.6 changes&lt;/h2&gt;
&lt;p&gt;I added a new &lt;tt class="docutils literal"&gt;os.getrandom()&lt;/tt&gt; function: expose the Linux
&lt;tt class="docutils literal"&gt;getrandom()&lt;/tt&gt; syscall (issue #27778). I also added the two getrandom() flags:
&lt;tt class="docutils literal"&gt;os.GRND_NONBLOCK&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;os.GRND_RANDOM&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;I modified &lt;tt class="docutils literal"&gt;os.urandom()&lt;/tt&gt; to block on Linux: call &lt;tt class="docutils literal"&gt;getrandom(0)&lt;/tt&gt;
instead of &lt;tt class="docutils literal"&gt;getrandom(GRND_NONBLOCK)&lt;/tt&gt; (issue #27776).&lt;/p&gt;
&lt;p&gt;I also added a private &lt;tt class="docutils literal"&gt;_PyOS_URandomNonblock()&lt;/tt&gt; function used to initialize
the hash secret and used by &lt;tt class="docutils literal"&gt;random.Random.seed()&lt;/tt&gt; (used to initialize the
&lt;tt class="docutils literal"&gt;random&lt;/tt&gt; module).&lt;/p&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;os.urandom()&lt;/tt&gt; function now blocks in Python 3.6 on Linux 3.17 and newer
until the system urandom entropy pool is initialized to increase the security.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="read-also-lwn-articles"&gt;
&lt;h2&gt;Read also LWN articles&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://lwn.net/Articles/606141/"&gt;A system call for random numbers: getrandom()&lt;/a&gt; (July 2014)&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://lwn.net/Articles/693189/"&gt;Python's os.urandom() in the absence of entropy&lt;/a&gt; (July 2016) -- this story&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://lwn.net/Articles/711013/"&gt;The long road to getrandom() in glibc&lt;/a&gt; (January 2017)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="cpython"></category></entry><entry><title>My contributions to CPython during 2016 Q2</title><link href="https://haypo.github.io/contrib-cpython-2016q2.html" rel="alternate"></link><published>2017-02-12T18:00:00+01:00</published><author><name>Victor Stinner</name></author><id>tag:haypo.github.io,2017-02-12:contrib-cpython-2016q2.html</id><summary type="html">&lt;p&gt;My contributions to &lt;a class="reference external" href="https://www.python.org/"&gt;CPython&lt;/a&gt; during 2016 Q2
(april, may, june):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
hg log -r 'date(&amp;quot;2016-04-01&amp;quot;):date(&amp;quot;2016-06-30&amp;quot;)' --no-merges -u Stinner
&lt;/pre&gt;
&lt;p&gt;Statistics: 52 non-merge commits + 22 merge commits (total: 74 commits).&lt;/p&gt;
&lt;p&gt;Previous report: &lt;a class="reference external" href="https://haypo.github.io/contrib-cpython-2016q1.html"&gt;My contributions to CPython during 2016 Q1&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="start-of-my-work-on-optimization"&gt;
&lt;h2&gt;Start of my work on optimization&lt;/h2&gt;
&lt;p&gt;During 2016 Q2, I started to spend more time on optimizing CPython.&lt;/p&gt;
&lt;p&gt;I experimented a change on CPython: a new FASTCALL calling convention to avoid
the creation of a temporary tuple to pass positional argulments: &lt;a class="reference external" href="http://bugs.python.org/issue26814"&gt;issue26814&lt;/a&gt;. Early results were really good: calling
builtin functions became between 20% and 50% faster!&lt;/p&gt;
&lt;p&gt;Quickly, my optimization work was blocked by unreliable benchmarks. I spent the
rest of the year 2016 analyzing benchmarks and making benchmarks more stable.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="subprocess-now-emits-resourcewarning"&gt;
&lt;h2&gt;subprocess now emits ResourceWarning&lt;/h2&gt;
&lt;p&gt;subprocess.Popen destructor now emits a ResourceWarning warning if the child
process is still running (issue #26741). The warning helps to track and fix
zombi processes. I updated asyncio to prevent a false ResourceWarning (warning
whereas the child process completed): asyncio now copies the child process exit
status to the internal Popen object.&lt;/p&gt;
&lt;p&gt;I also fixed the POSIX implementation of subprocess.Popen._execute_child(): it
now sets the returncode attribute from the child process exit status when exec
failed.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="security-fix-potential-shell-injections-in-ctypes-util"&gt;
&lt;h2&gt;Security: fix potential shell injections in ctypes.util&lt;/h2&gt;
&lt;p&gt;I rewrote methods of the ctypes.util module using &lt;tt class="docutils literal"&gt;os.popen()&lt;/tt&gt;. I replaced
&lt;tt class="docutils literal"&gt;os.popen()&lt;/tt&gt; with &lt;tt class="docutils literal"&gt;subprocess.Popen&lt;/tt&gt; without shell (issue #22636) to fix a
class of security vulneratiblity, &amp;quot;shell injection&amp;quot; (inject arbitrary shell
commands to take the control of a computer).&lt;/p&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;os.popen()&lt;/tt&gt; function uses a shell, so there is a risk if the command
line arguments are not properly escaped for shell. Using &lt;tt class="docutils literal"&gt;subproces.Popen&lt;/tt&gt;
without shell fixes completely the risk.&lt;/p&gt;
&lt;p&gt;Note: the &lt;tt class="docutils literal"&gt;ctypes&lt;/tt&gt; is generally not considered as &amp;quot;safe&amp;quot;, but it doesn't harm
to make it more secure ;-)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="optimization-pymem-malloc-now-uses-pymalloc"&gt;
&lt;h2&gt;Optimization: PyMem_Malloc() now uses pymalloc&lt;/h2&gt;
&lt;p&gt;PyMem_Malloc() now uses the fast Python &amp;quot;pymalloc&amp;quot; memory allocator which is
optimized for small objects with a short lifetime (issue #26249). The change
makes some benchmarks up to 4% faster.&lt;/p&gt;
&lt;p&gt;This change was possible thanks to the whole preparation work I did in the 2016
Q1, especially the new GIL check in memory allocator debug hooks and the new
&lt;tt class="docutils literal"&gt;PYTHONMALLOC=debug&lt;/tt&gt; environment variable enabling these hooks on a Python
compiled in released mode.&lt;/p&gt;
&lt;p&gt;I tested lxml, Pillow, cryptography and numpy before pushing the change,
as asked by Marc-Andre Lemburg. All these projects work with the change, except
of numpy. I wrote a fix for numpy: &lt;a class="reference external" href="https://github.com/numpy/numpy/pull/7404"&gt;Use PyMem_RawMalloc on Python 3.4 and newer&lt;/a&gt;, merged one month later (my first
contribution to numy!).&lt;/p&gt;
&lt;p&gt;The change indirectly helped to identify and fix a memory leak in the
&lt;tt class="docutils literal"&gt;formatfloat()&lt;/tt&gt; function used to format bytes strings: &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;b&amp;quot;%f&amp;quot;&lt;/span&gt; % 1.2&lt;/tt&gt; (issue
#25349, #26249).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="optimization"&gt;
&lt;h2&gt;Optimization&lt;/h2&gt;
&lt;p&gt;Issue #27056: Optimize pickle.load() and pickle.loads(), up to 10% faster to
deserialize a lot of small objects. I found this optimization using Linux perf
on Python compiled with PGO. My change implements manually the optimization if
Python is not compiled with PGO.&lt;/p&gt;
&lt;p&gt;Issue #26770: When &lt;tt class="docutils literal"&gt;set_inheritable()&lt;/tt&gt; is implemented with &lt;tt class="docutils literal"&gt;fcntl()&lt;/tt&gt;, don't
call &lt;tt class="docutils literal"&gt;fcntl()&lt;/tt&gt; twice if the &lt;tt class="docutils literal"&gt;FD_CLOEXEC&lt;/tt&gt; flag is already set to the
requested value. Linux uses &lt;tt class="docutils literal"&gt;ioctl()&lt;/tt&gt; and so always only need a single
syscall.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="changes"&gt;
&lt;h2&gt;Changes&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;Issue #26716: Replace IOError with OSError in fcntl documentation, IOError is
a deprecated alias to OSError since Python 3.3.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Issue #26639: Replace the deprecated &lt;tt class="docutils literal"&gt;imp&lt;/tt&gt; module with the &lt;tt class="docutils literal"&gt;importlib&lt;/tt&gt;
module in &lt;tt class="docutils literal"&gt;Tools/i18n/pygettext.py&lt;/tt&gt;. Remove &lt;tt class="docutils literal"&gt;_get_modpkg_path()&lt;/tt&gt;,
replaced with &lt;tt class="docutils literal"&gt;importlib.util.find_spec()&lt;/tt&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Issue #26735: Fix os.urandom() on Solaris 11.3 and newer when reading more
than 1024 bytes: call getrandom() multiple times with a limit of 1024 bytes
per call.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;configure: fix &lt;tt class="docutils literal"&gt;HAVE_GETRANDOM_SYSCALL&lt;/tt&gt; check, syscall() function requires
&lt;tt class="docutils literal"&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Issue #26766: Fix _PyBytesWriter_Finish(). Return a bytearray object when
bytearray is requested and when the small buffer is used. Fix also
test_bytes: bytearray%args must return a bytearray type.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Issue #26777: Fix random failure of test_asyncio.test_timeout_disable() on
the &amp;quot;AMD64 FreeBSD 9.x 3.5&amp;quot; buildbot:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
File &amp;quot;.../Lib/test/test_asyncio/test_tasks.py&amp;quot;, line 2398, in go
  self.assertTrue(0.09 &amp;lt; dt &amp;lt; 0.11, dt)
AssertionError: False is not true : 0.11902812402695417
&lt;/pre&gt;
&lt;p&gt;Replace &lt;tt class="docutils literal"&gt;&amp;lt; 0.11&lt;/tt&gt; with &lt;tt class="docutils literal"&gt;&amp;lt; 0.15&lt;/tt&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Backport test_gdb fix for s390x buildbots to Python 3.5.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Cleanup import.c: replace &lt;tt class="docutils literal"&gt;PyUnicode_RPartition()&lt;/tt&gt; with
&lt;tt class="docutils literal"&gt;PyUnicode_FindChar()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;PyUnicode_Substring()&lt;/tt&gt; to avoid the creation
of a temporary tuple. Use &lt;tt class="docutils literal"&gt;PyUnicode_FromFormat()&lt;/tt&gt; to build a string and
avoid the single_dot ('.') singleton.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;regrtest now uses subprocesses when the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-j1&lt;/span&gt;&lt;/tt&gt; command line option is used:
each test file runs in a fresh child process. Before, the -j1 option was
ignored. &lt;tt class="docutils literal"&gt;Tools/buildbot/test.bat&lt;/tt&gt; script now uses -j1 by default to run
each test file in fresh child process.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;regrtest: display test result (passed, failed, ...) after each test
completion. In multiprocessing mode: always display the result. In sequential
mode: only display the result if the test did not pass&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Issue #27278: Fix &lt;tt class="docutils literal"&gt;os.urandom()&lt;/tt&gt; implementation using &lt;tt class="docutils literal"&gt;getrandom()&lt;/tt&gt; on
Linux. Truncate size to &lt;tt class="docutils literal"&gt;INT_MAX&lt;/tt&gt; and loop until we collected enough random
bytes, instead of casting a directly &lt;tt class="docutils literal"&gt;Py_ssize_t&lt;/tt&gt; to &lt;tt class="docutils literal"&gt;int&lt;/tt&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="contributions"&gt;
&lt;h2&gt;Contributions&lt;/h2&gt;
&lt;p&gt;I also pushed a few changes written by other contributors.&lt;/p&gt;
&lt;p&gt;Issue #26839: &lt;tt class="docutils literal"&gt;os.urandom()&lt;/tt&gt; doesn't block on Linux anymore. On Linux,
&lt;tt class="docutils literal"&gt;os.urandom()&lt;/tt&gt; now calls getrandom() with &lt;tt class="docutils literal"&gt;GRND_NONBLOCK&lt;/tt&gt; to fall back on
reading &lt;tt class="docutils literal"&gt;/dev/urandom&lt;/tt&gt; if the urandom entropy pool is not initialized yet.
Patch written by Colm Buckley. This issue started a huge annoying discussion
around random number generation on the bug tracker and the python-dev mailing
list.  I later wrote the &lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0524/"&gt;PEP 524: Make os.urandom() blocking on Linux&lt;/a&gt; to fix the issue!&lt;/p&gt;
&lt;p&gt;Other changes:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Issue #26647: Cleanup opcode: simplify code to build &lt;tt class="docutils literal"&gt;opcode.opname&lt;/tt&gt;. Patch
written by Demur Rumed.&lt;/li&gt;
&lt;li&gt;Issue #26647: Cleanup modulefinder: use &lt;tt class="docutils literal"&gt;dis.opmap[name]&lt;/tt&gt; rather than
&lt;tt class="docutils literal"&gt;dis.opname.index(name)&lt;/tt&gt;. Patch written by Demur Rumed.&lt;/li&gt;
&lt;li&gt;Issue #26801: Fix error handling in &lt;tt class="docutils literal"&gt;shutil.get_terminal_size()&lt;/tt&gt;: catch
AttributeError instead of NameError. Skip the functional test of test_shutil
using the &lt;tt class="docutils literal"&gt;stty size&lt;/tt&gt; command if the &lt;tt class="docutils literal"&gt;os.get_terminal_size()&lt;/tt&gt; function is
missing. Patch written by Emanuel Barry.&lt;/li&gt;
&lt;li&gt;Issue #26802: Optimize function calls only using unpacking like
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;func(*tuple)&lt;/span&gt;&lt;/tt&gt; (no other positional argument, no keyword argument): avoid
copying the tuple. Patch written by Joe Jevnik.&lt;/li&gt;
&lt;li&gt;Issue #21668: Add missing libm dependency in setup.py: link audioop,
_datetime, _ctypes_test modules to libm, except on Mac OS X. Patch written by
Chi Hsuan Yen.&lt;/li&gt;
&lt;li&gt;Issue #26799: Fix python-gdb.py: don't get C types at startup, only on
demand. The C types can change if python-gdb.py is loaded before loading the
Python executable in gdb. Patch written by Thomas Ilsche.&lt;/li&gt;
&lt;li&gt;Issue #27057: Fix os.set_inheritable() on Android, ioctl() is blocked by
SELinux and fails with EACCESS. The function now falls back to fcntl(). Patch
written by Micha≈Ç Bednarski.&lt;/li&gt;
&lt;li&gt;Issue #26647: Fix typo in test_grammar. Patch written by Demur Rumed.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="cpython"></category></entry><entry><title>My contributions to CPython during 2016 Q1</title><link href="https://haypo.github.io/contrib-cpython-2016q1.html" rel="alternate"></link><published>2017-02-09T17:00:00+01:00</published><author><name>Victor Stinner</name></author><id>tag:haypo.github.io,2017-02-09:contrib-cpython-2016q1.html</id><summary type="html">&lt;p&gt;My contributions to &lt;a class="reference external" href="https://www.python.org/"&gt;CPython&lt;/a&gt; during 2016 Q1
(january, februrary, march):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
hg log -r 'date(&amp;quot;2016-01-01&amp;quot;):date(&amp;quot;2016-03-31&amp;quot;)' --no-merges -u Stinner
&lt;/pre&gt;
&lt;p&gt;Statistics: 196 non-merge commits + 33 merge commits (total: 229 commits).&lt;/p&gt;
&lt;p&gt;Previous report: &lt;a class="reference external" href="https://haypo.github.io/contrib-cpython-2015q4.html"&gt;My contributions to CPython during 2015 Q4&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="summary"&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;Since this report is much longer than I expected, here are the highlights:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Python 8: no pep8, no chocolate!&lt;/li&gt;
&lt;li&gt;AST enhancements coming from FAT Python&lt;/li&gt;
&lt;li&gt;faulthandler now catchs Windows fatal exceptions&lt;/li&gt;
&lt;li&gt;New PYTHONMALLOC environment variable&lt;/li&gt;
&lt;li&gt;tracemalloc: new C API and support multiple address spaces&lt;/li&gt;
&lt;li&gt;ResourceWarning warnings now come with a traceback&lt;/li&gt;
&lt;li&gt;PyMem_Malloc() now fails if the GIL is not held&lt;/li&gt;
&lt;li&gt;Interesting bug: reentrant flag in tracemalloc&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="python-8-no-pep8-no-chocolate"&gt;
&lt;h2&gt;Python 8: no pep8, no chocolate!&lt;/h2&gt;
&lt;p&gt;I prepared an April Fool: &lt;a class="reference external" href="https://mail.python.org/pipermail/python-dev/2016-March/143603.html"&gt;[Python-Dev] The next major Python version will be
Python 8&lt;/a&gt; :-)&lt;/p&gt;
&lt;p&gt;I increased Python version to 8, added the &lt;tt class="docutils literal"&gt;pep8&lt;/tt&gt; module and modified
&lt;tt class="docutils literal"&gt;importlib&lt;/tt&gt; to raise an &lt;tt class="docutils literal"&gt;ImportError&lt;/tt&gt; if a module is not PEP8-compliant!&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="ast-enhancements-coming-from-fat-python"&gt;
&lt;h2&gt;AST enhancements coming from FAT Python&lt;/h2&gt;
&lt;p&gt;Changes coming from my &lt;a class="reference external" href="http://faster-cpython.readthedocs.io/fat_python.html"&gt;FAT Python&lt;/a&gt; (AST optimizer, run
ahead of time):&lt;/p&gt;
&lt;p&gt;The compiler now ignores constant statements like &lt;tt class="docutils literal"&gt;b'bytes'&lt;/tt&gt; (issue #26204).
I had to replace constant statement with expressions to prepare the change (ex:
replace &lt;tt class="docutils literal"&gt;b'bytes'&lt;/tt&gt; with &lt;tt class="docutils literal"&gt;x = b'bytes'&lt;/tt&gt;). First, the compiler emited a
&lt;tt class="docutils literal"&gt;SyntaxWarning&lt;/tt&gt;, but it was quickly decided to let linters to emit such
warnings to not annoy users: &lt;a class="reference external" href="https://mail.python.org/pipermail/python-dev/2016-February/143163.html"&gt;read the thread on python-dev&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Example, Python 3.5:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;gt;&amp;gt;&amp;gt; def f():
...  b'bytes'
...
&amp;gt;&amp;gt;&amp;gt; import dis; dis.dis(f)
  2           0 LOAD_CONST               1 (b'bytes')
              3 POP_TOP
              4 LOAD_CONST               0 (None)
              7 RETURN_VALUE
&lt;/pre&gt;
&lt;p&gt;Python 3.6:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;gt;&amp;gt;&amp;gt; def f():
...  b'bytes'
...
&amp;gt;&amp;gt;&amp;gt; import dis; dis.dis(f)
  1           0 LOAD_CONST               0 (None)
              2 RETURN_VALUE
&lt;/pre&gt;
&lt;p&gt;Other changes:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Issue #26107: The format of the co_lnotab attribute of code objects changes
to support negative line number delta. It allows AST optimizers to move
instructions without breaking Python tracebacks. Change needed by the loop
unrolling optimization of FAT Python.&lt;/li&gt;
&lt;li&gt;Issue #26146: Add a new kind of AST node: &lt;tt class="docutils literal"&gt;ast.Constant&lt;/tt&gt;. It can be used by
external AST optimizers like FAT Python, but the compiler does not emit
directly such node. Update code to accept ast.Constant instead of ast.Num
and/or ast.Str.&lt;/li&gt;
&lt;li&gt;Issue #26146: &lt;tt class="docutils literal"&gt;marshal.loads()&lt;/tt&gt; now uses the empty frozenset singleton. It
fixes a test failure in FAT Python and reduces the memory footprint.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="faulthandler-now-catchs-windows-fatal-exceptions"&gt;
&lt;h2&gt;faulthandler now catchs Windows fatal exceptions&lt;/h2&gt;
&lt;p&gt;I enhanced the faulthandler.enable() function on Windows to set a
handler for Windows fatal exceptions using &lt;tt class="docutils literal"&gt;AddVectoredExceptionHandler()&lt;/tt&gt;
(issue #23848).&lt;/p&gt;
&lt;p&gt;Windows exceptions are the native way to handle fatal errors on Windows,
whereas UNIX signals SIGSEGV, SIGFPE and SIGABRT are &amp;quot;emulated&amp;quot; on top of that.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="new-pythonmalloc-environment-variable"&gt;
&lt;h2&gt;New PYTHONMALLOC environment variable&lt;/h2&gt;
&lt;p&gt;I added a new &lt;tt class="docutils literal"&gt;PYTHONMALLOC&lt;/tt&gt; environment variable (issue #26516) to set the
Python memory allocators.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;PYTHONMALLOC=debug&lt;/tt&gt; enables debug hooks on a Python compiled in release
mode, whereas Python 3.5 requires to recompile Python in debug mode. These
hooks implements various checks:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Detect &lt;strong&gt;buffer underflow&lt;/strong&gt;: write before the start of the buffer&lt;/li&gt;
&lt;li&gt;Detect &lt;strong&gt;buffer overflow&lt;/strong&gt;: write after the end of the buffer&lt;/li&gt;
&lt;li&gt;Detect API violations, ex: &lt;tt class="docutils literal"&gt;PyObject_Free()&lt;/tt&gt; called on a buffer
allocated by &lt;tt class="docutils literal"&gt;PyMem_Malloc()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;Check if the GIL is held when allocator functions of PYMEM_DOMAIN_OBJ (ex:
&lt;tt class="docutils literal"&gt;PyObject_Malloc()&lt;/tt&gt;) and PYMEM_DOMAIN_MEM (ex: &lt;tt class="docutils literal"&gt;PyMem_Malloc()&lt;/tt&gt;) domains
are called&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Moreover, logging a fatal memory error now uses the tracemalloc module to get
the traceback where a memory block was allocated. Example of a buffer overflow
using &lt;tt class="docutils literal"&gt;python3.6 &lt;span class="pre"&gt;-X&lt;/span&gt; tracemalloc=5&lt;/tt&gt; (store 5 frames in traces):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Debug memory block at address p=0x7fbcd41666f8: API 'o'
    4 bytes originally requested
    The 7 pad bytes at p-7 are FORBIDDENBYTE, as expected.
    The 8 pad bytes at tail=0x7fbcd41666fc are not all FORBIDDENBYTE (0xfb):
        at tail+0: 0x02 *** OUCH
        at tail+1: 0xfb
        at tail+2: 0xfb
        ...
    The block was made by call #1233329 to debug malloc/realloc.
    Data at p: 1a 2b 30 00

Memory block allocated at (most recent call first):
  File &amp;quot;test/test_bytes.py&amp;quot;, line 323
  File &amp;quot;unittest/case.py&amp;quot;, line 600
  ...

Fatal Python error: bad trailing pad byte

Current thread 0x00007fbcdbd32700 (most recent call first):
  File &amp;quot;test/test_bytes.py&amp;quot;, line 323 in test_hex
  File &amp;quot;unittest/case.py&amp;quot;, line 600 in run
  ...
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;PYTHONMALLOC=malloc&lt;/tt&gt; forces the usage of the system &lt;tt class="docutils literal"&gt;malloc()&lt;/tt&gt; allocator.
This option can be used with Valgrind. Without this option, Valgrind emits tons
of false alarms in the Python &lt;tt class="docutils literal"&gt;pymalloc&lt;/tt&gt; memory allocator.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="tracemalloc-new-c-api-and-support-multiple-address-spaces"&gt;
&lt;h2&gt;tracemalloc: new C API and support multiple address spaces&lt;/h2&gt;
&lt;p&gt;Antoine Pitrou and Nathaniel Smith asked me to enhance the tracemalloc module:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Add a C API to be able to manually track/untrack memory blocks, to track
the memory allocated by custom memory allocators. For example, numpy uses
allocators with a specific memory alignment for SIMD instructions.&lt;/li&gt;
&lt;li&gt;Support tracking memory of different address spaces. For example, central
(CPU) memory and GPU memory for numpy.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="support-multiple-address-spaces"&gt;
&lt;h3&gt;Support multiple address spaces&lt;/h3&gt;
&lt;p&gt;I made deep changes in the &lt;tt class="docutils literal"&gt;hashtable.c&lt;/tt&gt; code (simple C implementation of an
hash table used by &lt;tt class="docutils literal"&gt;_tracemalloc&lt;/tt&gt;) to support keys of a variable size (issue
#26588), instead of using an hardcoded &lt;tt class="docutils literal"&gt;void *&lt;/tt&gt; size. It allows to support
keys larger than &lt;tt class="docutils literal"&gt;sizeof(void*)&lt;/tt&gt;, but also to use &lt;em&gt;less&lt;/em&gt; memory for keys
smaller than &lt;tt class="docutils literal"&gt;sizeof(void*)&lt;/tt&gt; (ex: &lt;tt class="docutils literal"&gt;int&lt;/tt&gt; keys).&lt;/p&gt;
&lt;p&gt;Then I extended the C &lt;tt class="docutils literal"&gt;_tracemalloc&lt;/tt&gt; module and the Python &lt;tt class="docutils literal"&gt;tracemalloc&lt;/tt&gt; to
add a new &lt;tt class="docutils literal"&gt;domain&lt;/tt&gt; attribute to traces: add &lt;tt class="docutils literal"&gt;Trace.domain&lt;/tt&gt; attribute and
&lt;tt class="docutils literal"&gt;tracemalloc.DomainFilter&lt;/tt&gt; class.&lt;/p&gt;
&lt;p&gt;The final step was to optimize the memory footprint of _tracemalloc. Start with
compact keys (&lt;tt class="docutils literal"&gt;Py_uintptr_t&lt;/tt&gt; type) and only switch to &lt;tt class="docutils literal"&gt;pointer_t&lt;/tt&gt; keys when
the first memory block with a non-zero domain is tracked (when one more one
address space is used). So the &lt;tt class="docutils literal"&gt;_tracemalloc&lt;/tt&gt; memory usage doesn't change by
default in Python 3.6!&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="c-api"&gt;
&lt;h3&gt;C API&lt;/h3&gt;
&lt;p&gt;I added a private C API (issue #26530):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
int _PyTraceMalloc_Track(_PyTraceMalloc_domain_t domain, Py_uintptr_t ptr, size_t size);
int _PyTraceMalloc_Untrack(_PyTraceMalloc_domain_t domain, Py_uintptr_t ptr);
&lt;/pre&gt;
&lt;p&gt;I waited for Antoine and Nathaniel feedback on this API, but the API remains
private in Python 3.6 since none reviewed it.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="resourcewarning-warnings-now-come-with-a-traceback"&gt;
&lt;h2&gt;ResourceWarning warnings now come with a traceback&lt;/h2&gt;
&lt;div class="section" id="final-result"&gt;
&lt;h3&gt;Final result&lt;/h3&gt;
&lt;p&gt;Before going to explain the long development of the feature, let's see an
example of the final result! Example with the script &lt;tt class="docutils literal"&gt;example.py&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
import warnings

def func():
    return open(__file__)

f = func()
f = None
&lt;/pre&gt;
&lt;p&gt;Output of the command &lt;tt class="docutils literal"&gt;python3.6 &lt;span class="pre"&gt;-Wd&lt;/span&gt; &lt;span class="pre"&gt;-X&lt;/span&gt; tracemalloc=5 example.py&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
example.py:7: ResourceWarning: unclosed file &amp;lt;_io.TextIOWrapper name='example.py' mode='r' encoding='UTF-8'&amp;gt;
  f = None
Object allocated at (most recent call first):
  File &amp;quot;example.py&amp;quot;, lineno 4
    return open(__file__)
  File &amp;quot;example.py&amp;quot;, lineno 6
    f = func()
&lt;/pre&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;Object allocated at &lt;span class="pre"&gt;(...)&lt;/span&gt;&lt;/tt&gt; part is the new feature ;-)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="add-source-parameter-to-warnings"&gt;
&lt;h3&gt;Add source parameter to warnings&lt;/h3&gt;
&lt;p&gt;Python 3 logs &lt;tt class="docutils literal"&gt;ResourceWarning&lt;/tt&gt; warnings when a resource is not closed
properly to help developers to handle resources correctly. The problem is that
the warning is only logged when the object is destroy, which can occur far from
the object creation and can occur on a line unrelated to the object because of
the garbage collector.&lt;/p&gt;
&lt;p&gt;I added a new &lt;tt class="docutils literal"&gt;tracemalloc&lt;/tt&gt; module to Python 3.4 which has an interesting
&lt;tt class="docutils literal"&gt;tracemalloc.get_object_traceback()&lt;/tt&gt; function. If tracemalloc traced the
allocation of an object, it is able to provide later the traceback where the
object was allocated.&lt;/p&gt;
&lt;p&gt;I wanted to modify the &lt;tt class="docutils literal"&gt;warnings&lt;/tt&gt; module to call
&lt;tt class="docutils literal"&gt;get_object_traceback()&lt;/tt&gt;, but I noticed that it wasn't possible
to easily extend the &lt;tt class="docutils literal"&gt;warnings&lt;/tt&gt; API because this module allows to override
&lt;tt class="docutils literal"&gt;showwarning()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;formatwarning()&lt;/tt&gt; functions and these
functions have a fixed number of parameters. Example:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
def showwarning(message, category, filename, lineno, file=None, line=None):
    ...
&lt;/pre&gt;
&lt;p&gt;With the issue #26568, I added new  &lt;tt class="docutils literal"&gt;_showwarnmsg()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;_formatwarnmsg()&lt;/tt&gt;
functions to the warnings module which get a &lt;tt class="docutils literal"&gt;warnings.WarningMessage&lt;/tt&gt; object
instead of a list of parameters:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
def _showwarnmsg(msg):
    ...
&lt;/pre&gt;
&lt;p&gt;I added a &lt;tt class="docutils literal"&gt;source&lt;/tt&gt; attribute to &lt;tt class="docutils literal"&gt;warnings.WarningMessage&lt;/tt&gt; (issue #26567)
and a new optional &lt;tt class="docutils literal"&gt;source&lt;/tt&gt; parameter to &lt;tt class="docutils literal"&gt;warnings.warn()&lt;/tt&gt; (issue #26604):
the leaked resource object. I modified &lt;tt class="docutils literal"&gt;_formatwarnmsg()&lt;/tt&gt; to log the
traceback where resource was allocated, if available.&lt;/p&gt;
&lt;p&gt;The tricky part was to fix corner cases when the following functions of the
&lt;tt class="docutils literal"&gt;warnings&lt;/tt&gt; module are overriden:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;formatwarning()&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;showwarning()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_formatwarnmsg()&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;_showwarnmsg()&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="set-the-source-parameter"&gt;
&lt;h3&gt;Set the source parameter&lt;/h3&gt;
&lt;p&gt;I started to modify modules to set the source parameter when logging
&lt;tt class="docutils literal"&gt;ResourceWarning&lt;/tt&gt; warnings.&lt;/p&gt;
&lt;p&gt;The easy part was to modify &lt;tt class="docutils literal"&gt;asyncore&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;asyncio&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;_pyio&lt;/tt&gt; modules to
set the &lt;tt class="docutils literal"&gt;source&lt;/tt&gt; parameter. These modules are implemented in Python, the
change was just to add &lt;tt class="docutils literal"&gt;source=self&lt;/tt&gt;. Example of &lt;tt class="docutils literal"&gt;asyncio&lt;/tt&gt; destructor:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
def __del__(self):
    if not self.is_closed():
        warnings.warn(&amp;quot;unclosed event loop %r&amp;quot; % self, ResourceWarning,
                      source=self)
        if not self.is_running():
            self.close()
&lt;/pre&gt;
&lt;p&gt;Note: The warning is logged before the resource is closed to provide more
information in &lt;tt class="docutils literal"&gt;repr()&lt;/tt&gt;. Many objects clear most information in their
&lt;tt class="docutils literal"&gt;close()&lt;/tt&gt; method.&lt;/p&gt;
&lt;p&gt;Modifying C modules was more tricky than expected. I had to implement
&amp;quot;finalizers&amp;quot; (&lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0442/"&gt;PEP 432: Safe object finalization&lt;/a&gt;) for the &lt;tt class="docutils literal"&gt;_socket.socket&lt;/tt&gt; type
(issue #26590) and for the &lt;tt class="docutils literal"&gt;os.scandir()&lt;/tt&gt; iterator (issue #26603).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="more-reliable-warnings"&gt;
&lt;h3&gt;More reliable warnings&lt;/h3&gt;
&lt;p&gt;The Python shutdown process is complex, and some Python functions are broken
during the shutdown. I enhanced the warnings module to handle nicely these
failures and try to log warnings anyway.&lt;/p&gt;
&lt;p&gt;I modified &lt;tt class="docutils literal"&gt;warnings.formatwarning()&lt;/tt&gt; to catch &lt;tt class="docutils literal"&gt;linecache.getline()&lt;/tt&gt;
failures on formatting the traceback.&lt;/p&gt;
&lt;p&gt;Logging the resource traceback is complex, so I only implemented it in Python.
Python tries to use the Python &lt;tt class="docutils literal"&gt;warnings&lt;/tt&gt; module if it was imported, or falls
back on the C &lt;tt class="docutils literal"&gt;_warnings&lt;/tt&gt; module. To get the resource traceback at Python
shutdown, I modified the C module to try to import the Python warning:
&lt;tt class="docutils literal"&gt;_warnings.warn_explicit()&lt;/tt&gt; now tries to import the Python warnings module if
the source parameter is set to be able to log the traceback where the source
was allocated (issue #26592).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="fix-resourcewarning-warnings"&gt;
&lt;h3&gt;Fix ResourceWarning warnings&lt;/h3&gt;
&lt;p&gt;Since it became easy to debug these warnings, I fixed some of them in the
Python test suite:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Issue #26620: Fix ResourceWarning in test_urllib2_localnet. Use context
manager on urllib objects and use self.addCleanup() to cleanup resources even
if a test is interrupted with CTRL+c&lt;/li&gt;
&lt;li&gt;Issue #25654: multiprocessing: open file with &lt;tt class="docutils literal"&gt;closefd=False&lt;/tt&gt; to avoid
ResourceWarning. _test_multiprocessing: open file with &lt;tt class="docutils literal"&gt;O_EXCL&lt;/tt&gt; to detect
bugs in tests (if a previous test forgot to remove TESTFN).
&lt;tt class="docutils literal"&gt;test_sys_exit()&lt;/tt&gt;: remove TESTFN after each loop iteration&lt;/li&gt;
&lt;li&gt;Fix &lt;tt class="docutils literal"&gt;ResourceWarning&lt;/tt&gt; in test_unittest when interrupted&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="pymem-malloc-now-fails-if-the-gil-is-not-held"&gt;
&lt;h2&gt;PyMem_Malloc() now fails if the GIL is not held&lt;/h2&gt;
&lt;p&gt;Since using the mall object allocator (&lt;tt class="docutils literal"&gt;pymalloc)&lt;/tt&gt;) for dictionary key
storage showed speedup for the dict type (issue #23601), I proposed to
generalize the change, use &lt;tt class="docutils literal"&gt;pymalloc&lt;/tt&gt; for &lt;tt class="docutils literal"&gt;PyMem_Malloc()&lt;/tt&gt;: &lt;a class="reference external" href="https://mail.python.org/pipermail/python-dev/2016-February/143084.html"&gt;[Python-Dev]
Modify PyMem_Malloc to use pymalloc for performance&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The main issue was that the change means that &lt;tt class="docutils literal"&gt;PyMem_Malloc()&lt;/tt&gt; now requires
to hold the GIL, whereas it didn't before since it called directly
&lt;tt class="docutils literal"&gt;malloc()&lt;/tt&gt;.&lt;/p&gt;
&lt;div class="section" id="check-if-the-gil-is-held"&gt;
&lt;h3&gt;Check if the GIL is held&lt;/h3&gt;
&lt;p&gt;CPython has a &lt;tt class="docutils literal"&gt;PyGILState_Check()&lt;/tt&gt; function to check if the GIL is held.
Problem: the function doesn't work with subinterpreters: see issues #10915 and
#15751.&lt;/p&gt;
&lt;p&gt;I added an internal flag to &lt;tt class="docutils literal"&gt;PyGILState_Check()&lt;/tt&gt; (issue #26558) to skip the
test. The flag value is false at startup, set to true once the GIL is fully
initialized (Python initialization), set to false again when the GIL is
destroyed (Python finalization). The flag is also set to false when the first
subinterpreter is created.&lt;/p&gt;
&lt;p&gt;This hack works around &lt;tt class="docutils literal"&gt;PyGILState_Check()&lt;/tt&gt; limitations allowing to call
&lt;cite&gt;PyGILState_Check()`&lt;/cite&gt; anytime to debug more bugs earlier.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;_Py_dup()&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;_Py_fstat()&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;_Py_read()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;_Py_write()&lt;/tt&gt; are
low-level helper functions for system functions, but these functions require
the GIL to be held.  Thanks to the &lt;tt class="docutils literal"&gt;PyGILState_Check()&lt;/tt&gt; enhancement, it
became possible to check the GIL using an assertion.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pymem-malloc-and-gil"&gt;
&lt;h3&gt;PyMem_Malloc() and GIL&lt;/h3&gt;
&lt;p&gt;Issue #26563: Debug hooks on Python memory allocators now raise a fatal error
if memory allocator functions like PyMem_Malloc() and PyMem_Malloc() are called
without holding the GIL.&lt;/p&gt;
&lt;p&gt;The change spotted two bugs which I fixed:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Issue #26563: Replace PyMem_Malloc() with PyMem_RawMalloc() in the Windows
implementation of os.stat(), the code is called without holding the
GIL.&lt;/li&gt;
&lt;li&gt;Issue #26563: Fix usage of PyMem_Malloc() in overlapped.c. Replace
PyMem_Malloc() with PyMem_RawFree() since PostToQueueCallback() calls
PyMem_Free() in a new C thread which doesn't hold the GIL.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I wasn't able to switch &lt;tt class="docutils literal"&gt;PyMem_Malloc()&lt;/tt&gt; to &lt;tt class="docutils literal"&gt;pymalloc&lt;/tt&gt; in this quarter,
since it took more a lot of time to implement requested checks and test third
party modules.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="fatal-error-and-faulthandler"&gt;
&lt;h3&gt;Fatal error and faulthandler&lt;/h3&gt;
&lt;p&gt;I enhanced the faulthandler module to work in non-Python threads (issue
#26563). I fixed &lt;tt class="docutils literal"&gt;Py_FatalError()&lt;/tt&gt; if called without holding the GIL: don't
try to print the current exception, nor try to flush stdout and stderr: only
dump the traceback of Python threads.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="interesting-bug-reentrant-flag-in-tracemalloc"&gt;
&lt;h2&gt;Interesting bug: reentrant flag in tracemalloc&lt;/h2&gt;
&lt;p&gt;A bug annoyed me a lot: a random assertion error related to a reentrant flag in
the _tracemalloc module.&lt;/p&gt;
&lt;p&gt;Story starting in the &lt;a class="reference external" href="http://bugs.python.org/issue26588#msg262125"&gt;middle of the issue #26588 (2016-03-21)&lt;/a&gt;. While working on issue #26588,
&amp;quot;_tracemalloc: add support for multiple address spaces (domains)&amp;quot;, I noticed an
assertion failure in set_reentrant(), a helper function to set a &lt;em&gt;Thread Local
Storage&lt;/em&gt; (TLS), on a buildbot:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
python: ./Modules/_tracemalloc.c:195: set_reentrant:
    Assertion `PyThread_get_key_value(tracemalloc_reentrant_key) == ((PyObject *) &amp;amp;_Py_TrueStruct)' failed.
&lt;/pre&gt;
&lt;p&gt;I was unable to reproduce the bug on my Fedora 23 (AMD64). After changes on my
patch, I pushed it the day after, but the assertion failed again. I added
assertions and debug informations. More failures, an interesting one on Windows
which uses a single process.&lt;/p&gt;
&lt;p&gt;I added an assertion in tracemalloc_init() to ensure that the reeentrant flag
is set at the end of the function. The reentrant flag was no more set at
tracemalloc_start() entry for an unknown reason. I changed the module
initialization to no call tracemalloc_init() anymore, it's only called on
tracemalloc.start().&lt;/p&gt;
&lt;p&gt;&amp;quot;The bug was seen on 5 buildbots yet: PPC Fedora, AMD64 Debian, s390x RHEL,
AMD64 Windows, x86 Ubuntu.&amp;quot;&lt;/p&gt;
&lt;p&gt;I finally understood and fixed the bug with the &lt;a class="reference external" href="https://hg.python.org/cpython/rev/af1c1149784a"&gt;change af1c1149784a&lt;/a&gt;: tracemalloc_start() and
tracemalloc_stop() don't clear/set the reentrant flag anymore.&lt;/p&gt;
&lt;p&gt;The problem was that I expected that tracemalloc_init() and tracemalloc_start()
functions would always be called in the same thread, whereas it occurred that
tracemalloc_init() was called in thread A when the tracemalloc module is
imported, whereas tracemalloc_start() was called in thread B.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="other-commits"&gt;
&lt;h2&gt;Other commits&lt;/h2&gt;
&lt;div class="section" id="enhancements"&gt;
&lt;h3&gt;Enhancements&lt;/h3&gt;
&lt;p&gt;The developers of the &lt;tt class="docutils literal"&gt;vmprof&lt;/tt&gt; profiler asked me to expose the atomic
variable &lt;tt class="docutils literal"&gt;_PyThreadState_Current&lt;/tt&gt;. The private variable was removed from
Python 3.5.1 API because the implementation of atomic variables depends on the
compiler, compiler options, etc. and so caused compilation issues. I added a
new private &lt;tt class="docutils literal"&gt;_PyThreadState_UncheckedGet()&lt;/tt&gt; function (issue #26154) which
gets the value of the variable without exposing its implementation.&lt;/p&gt;
&lt;p&gt;Other enhancements:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Issue #26099: The site module now writes an error into stderr if
sitecustomize module can be imported but executing the module raise an
ImportError. Same change for usercustomize.&lt;/li&gt;
&lt;li&gt;Issue #26516: Enhance Python memory allocators documentation. Add link to
PYTHONMALLOCSTATS environment variable. Add parameters to PyMem macros like
PyMem_MALLOC().&lt;/li&gt;
&lt;li&gt;Issue #26569: Fix pyclbr.readmodule() and pyclbr.readmodule_ex() to support
importing packages.&lt;/li&gt;
&lt;li&gt;Issue #26564, #26516, #26563: Enhance documentation on memory allocator debug
hooks.&lt;/li&gt;
&lt;li&gt;doctest now supports packages. Issue #26641: doctest.DocFileTest and
doctest.testfile() now support packages (module splitted into multiple
directories) for the package parameter.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="bugfixes"&gt;
&lt;h3&gt;Bugfixes&lt;/h3&gt;
&lt;p&gt;Issue #25843: When compiling code, don't merge constants if they are equal but
have a different types. For example, &lt;tt class="docutils literal"&gt;f1, f2 = lambda: 1, lambda: 1.0&lt;/tt&gt; is now
correctly compiled to two different functions: &lt;tt class="docutils literal"&gt;f1()&lt;/tt&gt; returns &lt;tt class="docutils literal"&gt;1&lt;/tt&gt; (int) and
&lt;tt class="docutils literal"&gt;f2()&lt;/tt&gt; returns &lt;tt class="docutils literal"&gt;1.0&lt;/tt&gt; (int), even if 1 and 1.0 are equal.&lt;/p&gt;
&lt;p&gt;Other fixes:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Issue #26101: Fix test_compilepath() of test_compileall. Exclude Lib/test/
from sys.path in test_compilepath(). The directory contains invalid Python
files like Lib/test/badsyntax_pep3120.py, whereas the test ensures that all
files can be compiled.&lt;/li&gt;
&lt;li&gt;Issue #24520: Replace fpgetmask() with fedisableexcept(). On FreeBSD,
fpgetmask() was deprecated long time ago.  fedisableexcept() is now
preferred.&lt;/li&gt;
&lt;li&gt;Issue #26161: Use Py_uintptr_t instead of void* for atomic pointers in
pyatomic.h. Use atomic_uintptr_t when &amp;lt;stdatomic.h&amp;gt; is used. Using void*
causes compilation warnings depending on which implementation of atomic types
is used.&lt;/li&gt;
&lt;li&gt;Issue #26637: The importlib module now emits an ImportError rather than a
TypeError if __import__() is tried during the Python shutdown process but
sys.path is already cleared (set to None).&lt;/li&gt;
&lt;li&gt;doctest: fix _module_relative_path() error message. Write the module name
rather than &amp;lt;module&amp;gt; in the error message, if module has no __file__
attribute (ex: package).&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="fix-type-downcasts-on-windows-64-bit"&gt;
&lt;h3&gt;Fix type downcasts on Windows 64-bit&lt;/h3&gt;
&lt;p&gt;In my spare time, I'm trying to fix a few compiler warnings on Windows 64-bit
where the C &lt;tt class="docutils literal"&gt;long&lt;/tt&gt; type is only 32-bit, whereas pointers are &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;64-bit&lt;/span&gt;&lt;/tt&gt; long:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;posix_getcwd(): limit to INT_MAX on Windows. It's more to fix a compiler
warning during compilation, I don't think that Windows support current
working directories larger than 2 GB :-)&lt;/li&gt;
&lt;li&gt;_pickle: Fix load_counted_tuple(), use Py_ssize_t for size. Fix a warning on
Windows 64-bit.&lt;/li&gt;
&lt;li&gt;getpathp.c: fix compiler warning, wcsnlen_s() result type is size_t.&lt;/li&gt;
&lt;li&gt;compiler.c: fix compiler warnings on Windows&lt;/li&gt;
&lt;li&gt;_msi.c: try to fix compiler warnings&lt;/li&gt;
&lt;li&gt;longobject.c: fix compilation warning on Windows 64-bit. We know that
Py_SIZE(b) is -1 or 1 an so fits into the sdigit type.&lt;/li&gt;
&lt;li&gt;On Windows, socket.setsockopt() now raises an OverflowError if the socket
option is larger than INT_MAX bytes.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="unicode-bugfixes"&gt;
&lt;h3&gt;Unicode bugfixes&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Issue #26227: On Windows, getnameinfo(), gethostbyaddr() and
gethostbyname_ex() functions of the socket module now decode the hostname
from the ANSI code page rather than UTF-8.&lt;/li&gt;
&lt;li&gt;Issue #26217: Unicode resize_compact() must set wstr_length to 0 after
freeing the wstr string. Otherwise, an assertion fails in
_PyUnicode_CheckConsistency().&lt;/li&gt;
&lt;li&gt;Issue #26464: Fix str.translate() when string is ASCII and first replacements
removes characters, but next replacements use a non-ASCII character or a
string longer than 1 character. Regression introduced in Python 3.5.0.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="buildbot-tests"&gt;
&lt;h3&gt;Buildbot, tests&lt;/h3&gt;
&lt;p&gt;Just to give you an idea of the work required to keep a working CI, here is the
list of changes I maded in a single quarter to make tests and Python buildbots
more reliable.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Issue #26610: Skip test_venv.test_with_pip() if ctypes miss&lt;/li&gt;
&lt;li&gt;test_asyncio: fix test_timeout_time(). Accept time delta up to 0.12 second,
instead of 0.11, for the &amp;quot;AMD64 FreeBSD 9.x&amp;quot; buildbot slave.&lt;/li&gt;
&lt;li&gt;Issue #13305: Always test datetime.datetime.strftime(&amp;quot;%4Y&amp;quot;) for years &amp;lt; 1900.
Change quickly reverted, strftime(&amp;quot;%4Y&amp;quot;) fails on most platforms.&lt;/li&gt;
&lt;li&gt;Issue #17758: Skip test_site if site.USER_SITE directory doesn't exist and
cannot be created.&lt;/li&gt;
&lt;li&gt;Fix test_venv on FreeBSD buildbot. Ignore pip warning in
test_venv.test_with_venv().&lt;/li&gt;
&lt;li&gt;Issue #26566: Rewrite test_signal.InterProcessSignalTests. Don't use
os.fork() with a subprocess to not inherit existing signal handlers or
threads: start from a fresh process. Use a timeout of 10 seconds to wait for
the signal instead of 1 second&lt;/li&gt;
&lt;li&gt;Issue #26538: regrtest: Fix module.__path__. libregrtest: Fix setup_tests()
to keep module.__path__ type (_NamespacePath), don't convert to a list.
Add _NamespacePath.__setitem__() method to importlib._bootstrap_external.&lt;/li&gt;
&lt;li&gt;regrtest: add time to output. Timestamps should help to debug slow buildbots,
and timeout and hang on buildbots.&lt;/li&gt;
&lt;li&gt;regrtest: add timeout to main process when using -jN. libregrtest: add a
watchdog to run_tests_multiprocess() using faulthandler.dump_traceback_later().&lt;/li&gt;
&lt;li&gt;Makefile: change default value of TESTTIMEOUT from 1 hour to 15 min.
The whole test suite takes 6 minutes on my laptop. It takes less than 30
minutes on most buildbots. The TESTTIMEOUT is the timeout for a single test
file.&lt;/li&gt;
&lt;li&gt;Buildbots: change also Windows timeout from 1 hour to 15 min&lt;/li&gt;
&lt;li&gt;regrtest: display test duration in sequential mode. Only display duration if
a test takes more than 30 seconds.&lt;/li&gt;
&lt;li&gt;Issue #18787: Try to fix test_spwd on OpenIndiana. Try to get the &amp;quot;root&amp;quot;
entry which should exist on all UNIX instead of &amp;quot;bin&amp;quot; which doesn't exist on
OpenIndiana.&lt;/li&gt;
&lt;li&gt;regrtest: fix --fromfile feature. Update code for the name regrtest output
format. Enhance also test_regrtest test on --fromfile&lt;/li&gt;
&lt;li&gt;regrtest: mention if tests run sequentially or in parallel&lt;/li&gt;
&lt;li&gt;regrtest: when parallel tests are interrupted, display progress&lt;/li&gt;
&lt;li&gt;support.temp_dir(): call support.rmtree() instead of shutil.rmtree(). Try
harder to remove directories on Windows.&lt;/li&gt;
&lt;li&gt;rt.bat: use -m test instead of Libtestregrtest.py&lt;/li&gt;
&lt;li&gt;Refactor regrtest.&lt;/li&gt;
&lt;li&gt;Fix test_warnings.test_improper_option(). test_warnings: only run
test_improper_option() and test_warnings_bootstrap() once. The unit test
doesn't depend on self.module.&lt;/li&gt;
&lt;li&gt;Fix test_os.test_symlink(): remove created symlink.&lt;/li&gt;
&lt;li&gt;Issue #26643: Add missing shutil resources to regrtest.py&lt;/li&gt;
&lt;li&gt;test_urllibnet: set timeout on test_fileno(). Use the default timeout of 30
seconds to avoid blocking forever.&lt;/li&gt;
&lt;li&gt;Issue #26295: When using &amp;quot;python3 -m test --testdir=TESTDIR&amp;quot;, regrtest
doesn't add &amp;quot;test.&amp;quot; prefix to test module names. regrtest also prepends
testdir to sys.path.&lt;/li&gt;
&lt;li&gt;Issue #26295: test_regrtest now uses a temporary directory&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="contributions"&gt;
&lt;h3&gt;Contributions&lt;/h3&gt;
&lt;p&gt;I also pushed a few changes written by other contributors:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Issue #25907: Use {% trans %} tags in HTML templates to ease the translation
of the documentation. The tag comes from Jinja templating system, used by
Sphinx. Patch written by Julien Palard.&lt;/li&gt;
&lt;li&gt;Issue #26248: Enhance os.scandir() doc, patch written by Ben Hoyt:&lt;/li&gt;
&lt;li&gt;Fix error message in asyncio.selector_events. Patch written by Carlo
Beccarini.&lt;/li&gt;
&lt;li&gt;Issue #16851: Fix inspect.ismethod() doc, return also True if object is an
unbound method. Patch written by Anna Koroliuk.&lt;/li&gt;
&lt;li&gt;Issue #26574: Optimize bytes.replace(b'', b'.') and bytearray.replace(b'', b'.'):
up to 80% faster. Patch written by Josh Snider.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
</summary><category term="cpython"></category></entry><entry><title>Status of Python 3 in OpenStack Mitaka</title><link href="https://haypo.github.io/openstack_mitaka_python3.html" rel="alternate"></link><published>2016-03-02T14:00:00+01:00</published><author><name>Victor Stinner</name></author><id>tag:haypo.github.io,2016-03-02:openstack_mitaka_python3.html</id><summary type="html">&lt;p&gt;Now that most OpenStack services have reached feature freeze for the Mitaka
cycle (November 2015-April 2016), it's time to look back on the progress made
for Python 3 support.&lt;/p&gt;
&lt;p&gt;Previous status update: &lt;a class="reference external" href="http://techs.enovance.com/7807/python-3-status-openstack-liberty"&gt;Python 3 Status in OpenStack Liberty&lt;/a&gt;
(September 2015).&lt;/p&gt;
&lt;div class="section" id="services-ported-to-python-3"&gt;
&lt;h2&gt;Services ported to Python 3&lt;/h2&gt;
&lt;p&gt;13 services were ported to Python 3 during the Mitaka cycle:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Cinder&lt;/li&gt;
&lt;li&gt;Congress&lt;/li&gt;
&lt;li&gt;Designate&lt;/li&gt;
&lt;li&gt;Glance&lt;/li&gt;
&lt;li&gt;Heat&lt;/li&gt;
&lt;li&gt;Horizon&lt;/li&gt;
&lt;li&gt;Manila&lt;/li&gt;
&lt;li&gt;Mistral&lt;/li&gt;
&lt;li&gt;Octavia&lt;/li&gt;
&lt;li&gt;Searchlight&lt;/li&gt;
&lt;li&gt;Solum&lt;/li&gt;
&lt;li&gt;Watcher&lt;/li&gt;
&lt;li&gt;Zaqar&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Red Hat contributed to the Cinder, Designate, Glance and Horizon service
porting efforts.&lt;/p&gt;
&lt;p&gt;&amp;quot;Ported to Python 3&amp;quot; means that all unit tests pass on Python 3.4 which is
verified by a voting gate job. It is not enough to run applications in
production with Python 3. Integration and functional tests are not run on
Python 3 yet. See the section dedicated to these tests below.&lt;/p&gt;
&lt;p&gt;See the &lt;a class="reference external" href="https://wiki.openstack.org/wiki/Python3"&gt;Python 3 wiki page&lt;/a&gt; for the
current status of the OpenStack port to Python 3; especially the list of
services ported to Python 3.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="services-not-ported-yet"&gt;
&lt;h2&gt;Services not ported yet&lt;/h2&gt;
&lt;p&gt;It's become easier to list services which are not compatible with Python 3 than
listing services already ported to Python 3!&lt;/p&gt;
&lt;p&gt;9 services still need to be ported:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Work-in-progress:&lt;ul&gt;
&lt;li&gt;Magnum: 83% (959 unit tests/1,161)&lt;/li&gt;
&lt;li&gt;Cue: 81% (208 unit tests/257)&lt;/li&gt;
&lt;li&gt;Nova: 74% (10,859 unit tests/14,726)&lt;/li&gt;
&lt;li&gt;Barbican: 34% (392 unit tests/1168)&lt;/li&gt;
&lt;li&gt;Murano: 29% (133 unit tests/455)&lt;/li&gt;
&lt;li&gt;Keystone: 27% (1200 unit tests/4455)&lt;/li&gt;
&lt;li&gt;Swift: 0% (3 unit tests/4,435)&lt;/li&gt;
&lt;li&gt;Neutron-LBaaS: 0% (1 unit test/806)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Port not started yet:&lt;ul&gt;
&lt;li&gt;Trove: no python34 gate&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Red Hat contributed Python 3 patches to Cue, Neutron-LBaaS, Swift and Trove
during the Mitaka cycle.&lt;/p&gt;
&lt;p&gt;Trove developers are ready to start the port at the beginning of the next cycle
(Newton). The py34 test environment was blocked by the MySQL-Python dependency (it
was not possible to build the test environment), but this dependency is now
skipped on Python 3. Later, it will be &lt;a class="reference external" href="https://review.openstack.org/#/c/225915/"&gt;replaced with PyMySQL&lt;/a&gt; on Python 2 and Python 3.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="python-3-issues-in-eventlet"&gt;
&lt;h2&gt;Python 3 issues in Eventlet&lt;/h2&gt;
&lt;p&gt;Four Python 3 issues were fixed in Eventlet:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/eventlet/eventlet/issues/295"&gt;Issue #295: Python 3: wsgi doesn't handle correctly partial write of
socket send() when using writelines()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;PR #275: &lt;a class="reference external" href="https://github.com/eventlet/eventlet/pull/275"&gt;Issue #274: Fix GreenSocket.recv_into()&lt;/a&gt;.
Issue: &lt;a class="reference external" href="https://github.com/eventlet/eventlet/issues/274"&gt;On Python 3, sock.makefile('rb').readline() doesn't handle blocking
errors correctly&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;PR #257: &lt;a class="reference external" href="https://github.com/eventlet/eventlet/pull/257"&gt;Fix GreenFileIO.readall() for regular file&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/eventlet/eventlet/issues/248"&gt;Issue #248: eventlet.monkey_patch() on Python 3.4 makes stdout
non-blocking&lt;/a&gt;: pull
request &lt;a class="reference external" href="https://github.com/eventlet/eventlet/pull/250"&gt;Fix GreenFileIO.write()&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="next-milestone-functional-and-integration-tests"&gt;
&lt;h2&gt;Next Milestone: Functional and integration tests&lt;/h2&gt;
&lt;p&gt;The next major milestone will be to run functional and integration tests on
Python 3.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;functional tests are restricted to one component (ex: only Glance)&lt;/li&gt;
&lt;li&gt;integration tests, like Tempest, test the integration of multiple components&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It is now possible to install some packages on Python 3 in DevStack using
&lt;tt class="docutils literal"&gt;USE_PYTHON3&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;PYTHON3_VERSION&lt;/tt&gt; variables: &lt;a class="reference external" href="https://review.openstack.org/#/c/181165/"&gt;Enable optional Python 3
support&lt;/a&gt;. It means that it is
possible to run tests with some services running on Python 3, and the remaining
services on Python 2.&lt;/p&gt;
&lt;p&gt;The port to Python 3 of Glance, Heat and Neutron functional and integration
tests have already started.&lt;/p&gt;
&lt;p&gt;For Glance, 159 functional tests already pass on Python 3.4.&lt;/p&gt;
&lt;p&gt;Heat:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;project-config: &lt;a class="reference external" href="https://review.openstack.org/#/c/228194/"&gt;Add python34 integration test job for Heat&lt;/a&gt; (WIP)&lt;/li&gt;
&lt;li&gt;heat: &lt;a class="reference external" href="https://review.openstack.org/#/c/188033/"&gt;py34: integration tests&lt;/a&gt;
(WIP)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Neutron: the &lt;a class="reference external" href="https://review.openstack.org/#/c/231897/"&gt;Add the functional-py34 and dsvm-functional-py34 targets to
tox.ini&lt;/a&gt; change was merged, but a
gate job hasn't been added for it yet.&lt;/p&gt;
&lt;p&gt;Another pending project is to fix issues specific to Python 3.5, but the gate
doesn‚Äôt use Python 3.5 yet. There are some minor issues, probably easy to fix.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="how-to-port-remaining-code"&gt;
&lt;h2&gt;How to port remaining code?&lt;/h2&gt;
&lt;p&gt;The &lt;a class="reference external" href="https://wiki.openstack.org/wiki/Python3"&gt;Python 3 wiki page&lt;/a&gt; contains
a lot of information about adding Python 3 support to Python 2 code.&lt;/p&gt;
&lt;p&gt;Join us in the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;#openstack-python3&lt;/span&gt;&lt;/tt&gt; IRC channel on Freenode to discuss
Python 3!&lt;/p&gt;
&lt;/div&gt;
</summary><category term="openstack"></category><category term="python3"></category></entry><entry><title>Fast _PyAccu, _PyUnicodeWriter and_PyBytesWriter APIs to produce strings in CPython</title><link href="https://haypo.github.io/pybyteswriter.html" rel="alternate"></link><published>2016-03-01T16:00:00+01:00</published><author><name>Victor Stinner</name></author><id>tag:haypo.github.io,2016-03-01:pybyteswriter.html</id><summary type="html">&lt;p&gt;This article described the _PyBytesWriter and _PyUnicodeWriter private APIs of
CPython. These APIs are design to optimize code producing strings when the
ouput size is not known in advance.&lt;/p&gt;
&lt;p&gt;I created the _PyUnicodeWriter API to reply to complains that Python 3 was much
slower than Python 2, especially with the new Unicode implementation (PEP 393).&lt;/p&gt;
&lt;div class="section" id="pyaccu-api"&gt;
&lt;h2&gt;_PyAccu API&lt;/h2&gt;
&lt;p&gt;Issue #12778: In 2011, Antoine Pitrou found a performance issue in the JSON
serializer when serializing many small objects: it used way too much memory for
temporary objects compared to the final output string.&lt;/p&gt;
&lt;p&gt;The JSON serializer used a list of strings and joined all strings at the end of
create a final output string. Pseudocode:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
def serialize():
    pieces = [serialize(item) for item in self]
    return ''.join(pieces)
&lt;/pre&gt;
&lt;p&gt;Antoine introduced an accumulator compacting the temporary list of &amp;quot;small&amp;quot;
strings and put the result in a second list of &amp;quot;large&amp;quot; strings. At the end, the
list of &amp;quot;large&amp;quot; strings was also compacted to build the final output string.
Pseudo-code:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
def serialize():
    small = []
    large = []
    for item in self:
        small.append(serialize(item))
        if len(small) &amp;gt; 10000:
            large.append(''.join(small))
            small.clear()
    if small
        large.append(''.join(small))
    return ''.join(large)
&lt;/pre&gt;
&lt;p&gt;The threshold of 10,000  strings is justified by this comment:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
/* Each item in a list of unicode objects has an overhead (in 64-bit
 * builds) of:
 *   - 8 bytes for the list slot
 *   - 56 bytes for the header of the unicode object
 * that is, 64 bytes.  100000 such objects waste more than 6MB
 * compared to a single concatenated string.
 */
&lt;/pre&gt;
&lt;p&gt;Issue #12911: Antoine Pitrou found a similar performance issue in repr(list),
and so proposed to convert its accumular code into a new private _PyAccu API.
He added the _PyAccu API to Python 2.7.5 and 3.2.3. Title of te repr(list)
change: &amp;quot;Fix memory consumption when calculating the repr() of huge tuples or
lists&amp;quot;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-pyunicodewriter-api"&gt;
&lt;h2&gt;The _PyUnicodeWriter API&lt;/h2&gt;
&lt;div class="section" id="inefficient-implementation-of-the-pep-393"&gt;
&lt;h3&gt;Inefficient implementation of the PEP 393&lt;/h3&gt;
&lt;p&gt;In 2010, Python 3.3 got a completly new Unicode implementation, the Python type
&lt;tt class="docutils literal"&gt;str&lt;/tt&gt;, with the PEP 393. The implementation of the PEP was the topic of a
Google Summer of Code 2011 with the student Torsten Becker menthored by Martin
v. L√∂wis (author of the PEP). The project was successful: the PEP 393 was
implemented, it worked!&lt;/p&gt;
&lt;p&gt;The first implementation of the PEP 393 used a lot of 32-bit character buffers
(&lt;tt class="docutils literal"&gt;Py_UCS4&lt;/tt&gt;) which uses a lot of memory and requires expensive conversion to
8-bit (&lt;tt class="docutils literal"&gt;Py_UCS1&lt;/tt&gt;, ASCII and Latin1) or 16-bit (&lt;tt class="docutils literal"&gt;Py_UCS2&lt;/tt&gt;, BMP) characters.&lt;/p&gt;
&lt;p&gt;The new internal structures for Unicode strings are now very complex and
require to be smart when building a new string to avoid memory copies. I
created the _PyUnicodeWriter API to try to reduce expensive memory copies, and
even completly avoid memory copies in best cases.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="design-of-the-pyunicodewriter-api"&gt;
&lt;h3&gt;Design of the _PyUnicodeWriter API&lt;/h3&gt;
&lt;p&gt;According to benchmarks, creating a &lt;tt class="docutils literal"&gt;Py_UCS1*&lt;/tt&gt; buffer and then expand it
to &lt;tt class="docutils literal"&gt;Py_UCS2*&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;Py_UCS4*&lt;/tt&gt; is more efficient, since &lt;tt class="docutils literal"&gt;Py_UCS1*&lt;/tt&gt; is the
most common format.&lt;/p&gt;
&lt;p&gt;Python &lt;tt class="docutils literal"&gt;str&lt;/tt&gt; type is used for a wide range of usages. For example, it is used
for the name of variable names in the Python language itself. Variable names
are almost always ASCII.&lt;/p&gt;
&lt;p&gt;The worst case for _PyUnicodeWriter is when a long &lt;tt class="docutils literal"&gt;Py_UCS1*&lt;/tt&gt; buffer must be
converted to &lt;tt class="docutils literal"&gt;Py_UCS2*&lt;/tt&gt;, and then converted to &lt;tt class="docutils literal"&gt;Py_UCS4*&lt;/tt&gt;. Each conversion
is expensive: need to allocate a second memory block and convert characters to
the new format.&lt;/p&gt;
&lt;p&gt;_PyUnicodeWriter features:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Optional overallocation: overallocate the buffer by 50% on Windows and 25%
on Linux. The ratio changes depending on the OS, it is a raw heuristic to get
the best performances depending on the &lt;tt class="docutils literal"&gt;malloc()&lt;/tt&gt; memory allocator.&lt;/li&gt;
&lt;li&gt;The buffer can be a shared read-only string if the buffer was only created
from a single string. Micro-optimization for &lt;tt class="docutils literal"&gt;&amp;quot;%s&amp;quot; % str&lt;/tt&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The API allows to disable overallocation before the last write. For example,
&lt;tt class="docutils literal"&gt;&amp;quot;%s%s&amp;quot; % ('abc', 'def')&lt;/tt&gt; disables the overallocation before writing
&lt;tt class="docutils literal"&gt;'def'&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;The _PyUnicodeWriter was introduced by the issue #14716 (change 7be716a47e9d):&lt;/p&gt;
&lt;blockquote&gt;
Close #14716: str.format() now uses the new &amp;quot;unicode writer&amp;quot; API instead
of the PyAccu API. For example, it makes str.format() from 25% to 30%
faster on Linux.&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="fast-path-for-ascii"&gt;
&lt;h3&gt;Fast-path for ASCII&lt;/h3&gt;
&lt;p&gt;The cool and &lt;em&gt;unexpected&lt;/em&gt; side-effect of the _PyUnicodeWriter is that many
intermediate operations got a fast-path for &lt;tt class="docutils literal"&gt;Py_UCS1*&lt;/tt&gt;, especially for ASCII
strings. For example, padding a number with spaces on &lt;tt class="docutils literal"&gt;'%10i' % 123&lt;/tt&gt; is
implemented with &lt;tt class="docutils literal"&gt;memset()&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Formating a floating point number uses the &lt;tt class="docutils literal"&gt;PyOS_double_to_string()&lt;/tt&gt; function
which creates an ASCII buffer. If the writer buffer uses Py_UCS1, a
&lt;tt class="docutils literal"&gt;memcpy()&lt;/tt&gt; is enough to copy the formatted number.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="avoid-temporary-buffers"&gt;
&lt;h3&gt;Avoid temporary buffers&lt;/h3&gt;
&lt;p&gt;Since the beginning, I had the idea of avoiding temporary buffers thanks
to an unified API to handle a &amp;quot;Unicode buffer&amp;quot;. Slowly, I spread my changes
to all functions producing Unicode strings.&lt;/p&gt;
&lt;p&gt;The obvious target were &lt;tt class="docutils literal"&gt;str % args&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;str.format(args)&lt;/tt&gt;. Both
instructions use very different code, but it was possible to share a few
functions especially the code to format integers in bases 2 (binary), 8
(octal), 10 (decimal) and 16 (hexadecimal).&lt;/p&gt;
&lt;p&gt;The function formatting an integer computes the exact size of the output,
requests a number of characters and then write characters. The characters are
written directly in the writer buffer. No temporary memory block is needed
anymore, and moreover no Py_UCS conversion is need: &lt;tt class="docutils literal"&gt;_PyLong_Format()&lt;/tt&gt; writes
directly characters into the character format (PyUCS1, Py_UCS2 or Py_UCS4) of
the buffer.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="performance-compared-to-python-2"&gt;
&lt;h3&gt;Performance compared to Python 2&lt;/h3&gt;
&lt;p&gt;The PEP 393 uses a complex storage for strings, so the exact performances
now depends on the character set used in the benchmark. For benchmarks using
a character set different than ASCII, the result are more tricky to understand.&lt;/p&gt;
&lt;p&gt;To compare performances with Python 2, I focused my benchmarks on ASCII.  I
compared Python 3 str with Python 2 unicode, but also sometimes to Python 2 str
(bytes). On ASCII, Python 3.3 was as fast as Python 2, or even faster on some
very specific cases, but these cases are probably artificial and never seen in
real applications.&lt;/p&gt;
&lt;p&gt;In the best case, Python 3 str (Unicode) was faster than Python 2 bytes.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="pybyteswriter-api-first-try-big-fail"&gt;
&lt;h2&gt;_PyBytesWriter API: first try, big fail&lt;/h2&gt;
&lt;p&gt;Since Python was &lt;em&gt;much&lt;/em&gt; faster with _PyUnicodeWriter, I expected to get good
speedup with a similar API for bytes. The graal would be to share code for
bytes and Unicode (Spoiler alert! I reached this goal, but only for a single
function: format an integer to decimal).&lt;/p&gt;
&lt;p&gt;My first attempt of a _PyBytesWriter API was in 2013: &lt;a class="reference external" href="https://bugs.python.org/issue17742"&gt;Issue #17742: Add
_PyBytesWriter API&lt;/a&gt;. But quickly, I
noticed with microbenchmarks that my change made Python slower! I spent hours
to understand why GCC produced less efficient machine code. When I started to
dig the &amp;quot;strict aliasing&amp;quot; optimization issue, I realized that I reached a
deadend.&lt;/p&gt;
&lt;p&gt;Extract of the _PyBytesWriter structure:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
typedef struct {
    /* Current position in the buffer */
    char *str;

    /* Start of the buffer */
    char *start;

    /* End of the buffer */
    char *end;

    ...
} _PyBytesWriter;
&lt;/pre&gt;
&lt;p&gt;The problem is that GCC emited less efficient machine code for the C code (see
my &lt;a class="reference external" href="https://bugs.python.org/issue17742#msg187595"&gt;msg187595&lt;/a&gt;):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
while (collstart++&amp;lt;collend)
    *writer.str++ = '?';
&lt;/pre&gt;
&lt;p&gt;For the &lt;tt class="docutils literal"&gt;writer.str++&lt;/tt&gt; instruction, the new pointer value is written
immediatly in the structure. The pointer value is read again at each iteration.
So we have 1 LOAD and 1 STORE per iteration.&lt;/p&gt;
&lt;p&gt;GCC emits better code for the original C code:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
while (collstart++&amp;lt;collend)
    *str++ = '?';
&lt;/pre&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;str&lt;/tt&gt; variable is stored in a register and the new value of &lt;tt class="docutils literal"&gt;str&lt;/tt&gt; is
only written &lt;em&gt;once&lt;/em&gt;, at the end of loop (instead of writing it at each
iteration). The pointer value is &lt;em&gt;only read once&lt;/em&gt; before the loop. So we have 0
LOAD and 0 STORE (related to the pointer value) in the loop body.&lt;/p&gt;
&lt;p&gt;It looks like an aliasing issue, but I didn't find how to say to GCC that the
new value of &lt;tt class="docutils literal"&gt;writer.str&lt;/tt&gt; can be written only once at the end of the loop. I
tried the &lt;tt class="docutils literal"&gt;__restrict__&lt;/tt&gt; keyword: the LOAD (get the pointer value) was moved
out of the loop. But the STORE was still in the loop body.&lt;/p&gt;
&lt;p&gt;I wrote to gcc-help: &lt;a class="reference external" href="https://gcc.gnu.org/ml/gcc-help/2013-04/msg00192.html"&gt;Missed optimization when using a structure&lt;/a&gt;, but I didn't get any
reply. I just gave up.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pybyteswriter-api-new-try-the-good-one"&gt;
&lt;h2&gt;_PyBytesWriter API: new try, the good one&lt;/h2&gt;
&lt;p&gt;In 2015, I created the &lt;a class="reference external" href="https://bugs.python.org/issue25318"&gt;Issue #25318: Add _PyBytesWriter API to optimize
Unicode encoders&lt;/a&gt;. I redesigned the API
to avoid the aliasing issue.&lt;/p&gt;
&lt;p&gt;The new _PyBytesWriter doesn't contain the &lt;tt class="docutils literal"&gt;char*&lt;/tt&gt; pointers anymore: they are
now local variables in functions. Instead, functions of API requires two
parameters: the bytes writer and a &lt;tt class="docutils literal"&gt;char*&lt;/tt&gt; parameter. Example:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
PyObject * _PyBytesWriter_Finish(_PyBytesWriter *writer, char *str)
&lt;/pre&gt;
&lt;p&gt;The idea is to keep &lt;tt class="docutils literal"&gt;char*&lt;/tt&gt; pointers in functions to keep the most efficient
machine code in loops. The compiler doesn't have to compute complex aliasing
rules to decide if a CPU register can be used or not.&lt;/p&gt;
&lt;p&gt;_PyBytesWriter features:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Optional overallocation: overallocate the buffer by 25% on Windows and 50%
on Linux. Same idea than _PyUnicodeWriter.&lt;/li&gt;
&lt;li&gt;Support &lt;tt class="docutils literal"&gt;bytes&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;bytearray&lt;/tt&gt; type as output format to avoid an expensive
memory copy from &lt;tt class="docutils literal"&gt;bytes&lt;/tt&gt; to &lt;tt class="docutils literal"&gt;bytearray&lt;/tt&gt;.&lt;/li&gt;
&lt;li&gt;Small buffer of 512 bytes allocated on the stack to avoid the need of a
buffer allocated on the heap, before creating the final
&lt;tt class="docutils literal"&gt;bytes&lt;/tt&gt;/&lt;tt class="docutils literal"&gt;bytearray&lt;/tt&gt; object.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A _PyBytesWriter structure must always be allocated on the stack (to get fast
memory allocation of the smaller buffer).&lt;/p&gt;
&lt;p&gt;While _PyUnicodeWriter has a 5 functions and 1 macro to write a single
character, write strings, write a substring, etc. _PyBytesWriter has a single
_PyBytesWriter_WriteBytes() function to write a string, since all other writes
are done directly with regular C code on &lt;tt class="docutils literal"&gt;char*&lt;/tt&gt; pointers.&lt;/p&gt;
&lt;p&gt;The API itself doesn't make the code faster. Disabling overallocation on the
last write and the usage of the small buffer allocated on the stack may be
faster.&lt;/p&gt;
&lt;p&gt;In Python 3.6, I optimized error handlers on various codecs: ASCII, Latin1
and UTF-8. For example, the UTF-8 encoder is now up to 75 times as fast for
error handlers: &lt;tt class="docutils literal"&gt;ignore&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;replace&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;surrogateescape&lt;/tt&gt;,
&lt;tt class="docutils literal"&gt;surrogatepass&lt;/tt&gt;. The &lt;tt class="docutils literal"&gt;bytes % int&lt;/tt&gt; instruction became between 30% and 50%
faster on a microbenchmark.&lt;/p&gt;
&lt;p&gt;Later, I replaced &lt;tt class="docutils literal"&gt;char*&lt;/tt&gt; type with &lt;tt class="docutils literal"&gt;void*&lt;/tt&gt; to avoid compiler warnings
in functions using &lt;tt class="docutils literal"&gt;Py_UCS1*&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;unsigned char*&lt;/tt&gt;, unsigned types.&lt;/p&gt;
&lt;/div&gt;
</summary><category term="cpython"></category></entry><entry><title>My contributions to CPython during 2015 Q4</title><link href="https://haypo.github.io/contrib-cpython-2015q4.html" rel="alternate"></link><published>2016-03-01T15:00:00+01:00</published><author><name>Victor Stinner</name></author><id>tag:haypo.github.io,2016-03-01:contrib-cpython-2015q4.html</id><summary type="html">&lt;p&gt;My contributions to &lt;a class="reference external" href="https://www.python.org/"&gt;CPython&lt;/a&gt; during 2015 Q4
(october, november, december):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
hg log -r 'date(&amp;quot;2015-10-01&amp;quot;):date(&amp;quot;2015-12-31&amp;quot;)' --no-merges -u Stinner
&lt;/pre&gt;
&lt;p&gt;Statistics: 100 non-merge commits + 25 merge commits (total: 125 commits).&lt;/p&gt;
&lt;p&gt;As usual, I pushed changes of various contributors and helped them to polish
their change.&lt;/p&gt;
&lt;p&gt;I fighted against a recursion error, a regression introduced by my recent work
on the Python test suite.&lt;/p&gt;
&lt;p&gt;I focused on optimizing the bytes type during this quarter. It started with the
issue #24870 opened by INADA Naoki who works on PyMySQL: decoding bytes
using the surrogateescape error handler was the bottleneck of this benchmark.
For me, it was an opportunity for a new attempt to implement a fast &amp;quot;bytes
writer API&amp;quot;.&lt;/p&gt;
&lt;p&gt;I pushed my first change related to &lt;a class="reference external" href="http://faster-cpython.readthedocs.org/fat_python.html"&gt;FAT Python&lt;/a&gt;! Fix parser and AST:
fill lineno and col_offset of &amp;quot;arg&amp;quot; node when compiling AST from Python
objects.&lt;/p&gt;
&lt;p&gt;Previous report: &lt;a class="reference external" href="https://haypo.github.io/contrib-cpython-2015q3.html"&gt;My contributions to CPython during 2015 Q3&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="recursion-error"&gt;
&lt;h2&gt;Recursion error&lt;/h2&gt;
&lt;div class="section" id="the-bug-issue-25274"&gt;
&lt;h3&gt;The bug: issue #25274&lt;/h3&gt;
&lt;p&gt;During the previous quarter, I refactored Lib/test/regrtest.py huge file (1,600
lines) into a new Lib/test/libregrtest/ library (8 files). The problem is that
test_sys started to crash with &amp;quot;Fatal Python error: Cannot recover from stack
overflow&amp;quot; on test_recursionlimit_recovery(). The regression was introduced by a
change on regrtest which indirectly added one more Python frame in the code
executing test_sys.&lt;/p&gt;
&lt;p&gt;CPython has a limit on the depth of a call stack: &lt;tt class="docutils literal"&gt;sys.getrecursionlimit()&lt;/tt&gt;,
1000 by default. The limit is a weak protection against overflow of the C
stack. Weak because it only counts Python frames, intermediate C functions may
allocate a lot of memory on the stack.&lt;/p&gt;
&lt;p&gt;When we reach the limit, an &amp;quot;overflow&amp;quot; flag is set, but we still allow up to
limit+50 frames, because handling a RecursionError may need a few more frames.
The overflow flag is cleared when the stack level goes below a &amp;quot;low-water
mark&amp;quot;.&lt;/p&gt;
&lt;p&gt;After the regrtest change, test_recursionlimit_recovery() was called at stack
level 36. Before, it was called at level 35. The test triggers a RecursionError.
The problem is that we never goes again below the low-water mark, so the
overflow flag is never cleared.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-fix"&gt;
&lt;h3&gt;The fix&lt;/h3&gt;
&lt;p&gt;Another problem is that the function used to compute the &amp;quot;low-level mark&amp;quot; was
not monotonic:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
if limit &amp;gt; 100:
    low_water_mark = limit - 50
else:
    low_water_mark = 3 * limit // 4
&lt;/pre&gt;
&lt;p&gt;The gap occurs near a limit of 100 frames:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;limit = 99 =&amp;gt; low_level_mark = 74&lt;/li&gt;
&lt;li&gt;limit = 100 =&amp;gt; low_level_mark = 75&lt;/li&gt;
&lt;li&gt;limit = 101 =&amp;gt; low_level_mark = 51&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The formula was replaced with:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
if limit &amp;gt; 200:
    low_water_mark = limit - 50
else:
    low_water_mark = 3 * limit // 4
&lt;/pre&gt;
&lt;p&gt;The fix (&lt;a class="reference external" href="https://hg.python.org/cpython/rev/eb0c76442cee"&gt;change eb0c76442cee&lt;/a&gt;) modified the
&lt;tt class="docutils literal"&gt;sys.setrecursionlimit()&lt;/tt&gt; function to raise a &lt;tt class="docutils literal"&gt;RecursionError&lt;/tt&gt; exception if
the new limit is too low depending on the &lt;em&gt;current&lt;/em&gt; stack depth.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="optimizations"&gt;
&lt;h2&gt;Optimizations&lt;/h2&gt;
&lt;p&gt;As usual for performance, Serhiy Storchaka was very helpful on reviews, to run
independant benchmarks, etc.&lt;/p&gt;
&lt;p&gt;Optimizations on the &lt;tt class="docutils literal"&gt;bytes&lt;/tt&gt; type, ASCII, Latin1 and UTF-8 codecs:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Issue #25318: Add _PyBytesWriter API. Add a new private API to optimize
Unicode encoders. It uses a small buffer of 512 bytes allocated on the stack
and supports configurable overallocation.&lt;/li&gt;
&lt;li&gt;Use _PyBytesWriter API for UCS1 (ASCII and Latin1) and UTF-8 encoders. Enable
overallocation for the UTF-8 encoder with error handlers.&lt;/li&gt;
&lt;li&gt;unicode_encode_ucs1(): initialize collend to collstart+1 to not check the
current character twice, we already know that it is not ASCII.&lt;/li&gt;
&lt;li&gt;Issue #25267: The UTF-8 encoder is now up to 75 times as fast for error
handlers: &lt;tt class="docutils literal"&gt;ignore&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;replace&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;surrogateescape&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;surrogatepass&lt;/tt&gt;.
Patch co-written with Serhiy Storchaka.&lt;/li&gt;
&lt;li&gt;Issue #25301: The UTF-8 decoder is now up to 15 times as fast for error
handlers: &lt;tt class="docutils literal"&gt;ignore&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;replace&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;surrogateescape&lt;/tt&gt;.&lt;/li&gt;
&lt;li&gt;Issue #25318: Optimize backslashreplace and xmlcharrefreplace error handlers
in UTF-8 encoder. Optimize also backslashreplace error handler for ASCII and
Latin1 encoders.&lt;/li&gt;
&lt;li&gt;Issue #25349: Optimize bytes % args using the new private _PyBytesWriter API&lt;/li&gt;
&lt;li&gt;Optimize error handlers of ASCII and Latin1 encoders when the replacement
string is pure ASCII: use _PyBytesWriter_WriteBytes(), don't check individual
character.&lt;/li&gt;
&lt;li&gt;Issue #25349: Optimize bytes % int. Formatting is between 30% and 50% faster
on a microbenchmark.&lt;/li&gt;
&lt;li&gt;Issue #25357: Add an optional newline paramer to binascii.b2a_base64().
base64.b64encode() uses it to avoid a memory copy.&lt;/li&gt;
&lt;li&gt;Issue #25353: Optimize unicode escape and raw unicode escape encoders: use
the new _PyBytesWriter API.&lt;/li&gt;
&lt;li&gt;Rewrite PyBytes_FromFormatV() using _PyBytesWriter API&lt;/li&gt;
&lt;li&gt;Issue #25399: Optimize bytearray % args. Most formatting operations are now
between 2.5 and 5 times faster.&lt;/li&gt;
&lt;li&gt;Issue #25401: Optimize bytes.fromhex() and bytearray.fromhex(): they are now
between 2x and 3.5x faster.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="changes"&gt;
&lt;h2&gt;Changes&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Issue #25003: On Solaris 11.3 or newer, os.urandom() now uses the getrandom()
function instead of the getentropy() function. The getentropy() function is
blocking to generate very good quality entropy, os.urandom() doesn't need
such high-quality entropy.&lt;/li&gt;
&lt;li&gt;Issue #22806: Add &lt;tt class="docutils literal"&gt;python &lt;span class="pre"&gt;-m&lt;/span&gt; test &lt;span class="pre"&gt;--list-tests&lt;/span&gt;&lt;/tt&gt; command to list tests.&lt;/li&gt;
&lt;li&gt;Issue #25670: Remove duplicate getattr() in ast.NodeTransformer&lt;/li&gt;
&lt;li&gt;Issue #25557: Refactor _PyDict_LoadGlobal(). Don't fallback to
PyDict_GetItemWithError() if the hash is unknown: compute the hash instead.
Add also comments to explain the _PyDict_LoadGlobal() optimization.&lt;/li&gt;
&lt;li&gt;Issue #25868: Try to make test_eintr.test_sigwaitinfo() more reliable
especially on slow buildbots&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="changes-specific-to-python-2-7"&gt;
&lt;h2&gt;Changes specific to Python 2.7&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Closes #25742: locale.setlocale() now accepts a Unicode string for its second
parameter.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="bugfixes"&gt;
&lt;h2&gt;Bugfixes&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Fix regrtest --coverage on Windows&lt;/li&gt;
&lt;li&gt;Fix pytime on OpenBSD&lt;/li&gt;
&lt;li&gt;More fixes for test_eintr on FreeBSD&lt;/li&gt;
&lt;li&gt;Close #25373: Fix regrtest --slow with interrupted test&lt;/li&gt;
&lt;li&gt;Issue #25555: Fix parser and AST: fill lineno and col_offset of &amp;quot;arg&amp;quot; node
when compiling AST from Python objects. First contribution related
to FAT Python ;-)&lt;/li&gt;
&lt;li&gt;Issue #25696: Fix installation of Python on UNIX with make -j9.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="cpython"></category></entry><entry><title>My contributions to CPython during 2015 Q3</title><link href="https://haypo.github.io/contrib-cpython-2015q3.html" rel="alternate"></link><published>2016-02-18T01:00:00+01:00</published><author><name>Victor Stinner</name></author><id>tag:haypo.github.io,2016-02-18:contrib-cpython-2015q3.html</id><summary type="html">&lt;p&gt;A few years ago, someone asked me: &amp;quot;Why do you contribute to CPython? Python is
perfect, there are no more bugs, right?&amp;quot;. The article list most of my
contributions to CPython during 2015 Q3 (july, august, september). It gives an
idea of which areas of Python are not perfect yet :-)&lt;/p&gt;
&lt;p&gt;My contributions to &lt;a class="reference external" href="https://www.python.org/"&gt;CPython&lt;/a&gt; during 2015 Q3
(july, august, september):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
hg log -r 'date(&amp;quot;2015-07-01&amp;quot;):date(&amp;quot;2015-09-30&amp;quot;)' --no-merges -u Stinner
&lt;/pre&gt;
&lt;p&gt;Statistics: 153 non-merge commits + 75 merge commits (total: 228 commits).&lt;/p&gt;
&lt;p&gt;The major event in Python of this quarter was the release of Python 3.5.0.&lt;/p&gt;
&lt;p&gt;As usual, I helped various contributors to refine their changes and I pushed
their final changes.&lt;/p&gt;
&lt;div class="section" id="freebsd-kernel-bug"&gt;
&lt;h2&gt;FreeBSD kernel bug&lt;/h2&gt;
&lt;p&gt;It took me a while to polish the implementation of the &lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0475/"&gt;PEP 475 (retry syscall
on EINTR)&lt;/a&gt; especially its unit
test &lt;tt class="docutils literal"&gt;test_eintr&lt;/tt&gt;. The unit test is supposed to test Python, but as usual,
it also tests indirectly the operating system.&lt;/p&gt;
&lt;p&gt;I spent some days investigating a random hang on the FreeBSD buildbots: &lt;a class="reference external" href="https://bugs.python.org/issue25122"&gt;issue
#25122&lt;/a&gt;. I quickly found the guilty test
(test_eintr.test_open), but it took me a while to understand that it was a
kernel bug in the FIFO driver. Hopefully at the end, I was able to reproduce
the bug with a short C program in my FreeBSD VM. It is the best way to ask a
fix upstream.&lt;/p&gt;
&lt;p&gt;My &lt;a class="reference external" href="https://bugs.freebsd.org/bugzilla/show_bug.cgi?id=203162"&gt;FreeBSD bug report #203162&lt;/a&gt; (&amp;quot;when close(fd)
on a fifo fails with EINTR, the file descriptor is not really closed&amp;quot;) was
quickly fixed. The FreeBSD team is reactive!&lt;/p&gt;
&lt;p&gt;I like free softwares because it's possible to investigate bugs deep in the
code, and it's usually quick to get a fix.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="timestamp-rounding-issue"&gt;
&lt;h2&gt;Timestamp rounding issue&lt;/h2&gt;
&lt;p&gt;Even if the &lt;a class="reference external" href="http://bugs.python.org/issue23517"&gt;issue #23517&lt;/a&gt; is well defined
and simple to fix, it took me days (weeks?) to understand exactly how
timestamps are supposed to be rounded and agree on the &amp;quot;right&amp;quot; rounding method.
Alexander Belopolsky reminded me the important property:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
(datetime(1970,1,1) + timedelta(seconds=t)) == datetime.utcfromtimestamp(t)
&lt;/pre&gt;
&lt;p&gt;Tim Peters helped me to understand why Python rounds to nearest with ties going
away from zero (ROUND_HALF_UP) in &lt;tt class="docutils literal"&gt;round(float)&lt;/tt&gt; and other functions. At
the first look, the rounding method doesn't look natural nor logical:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;gt;&amp;gt;&amp;gt; round(0.5)
0
&amp;gt;&amp;gt;&amp;gt; round(1.5)
2
&lt;/pre&gt;
&lt;p&gt;See my previous article on the _PyTime API for the long story of rounding
methods between Python 3.2 and Python 3.6.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="enhancements"&gt;
&lt;h2&gt;Enhancements&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;type_call() now detect C bugs in type __new__() and __init__() methods.&lt;/li&gt;
&lt;li&gt;Issue #25220: Enhancements of the test runner: add more info when regrtest runs
tests in parallel, fix some features of regrtest, add functional tests to
test_regrtest.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="optimizations"&gt;
&lt;h2&gt;Optimizations&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Issue #25227: Optimize ASCII and latin1 encoders with the &lt;tt class="docutils literal"&gt;surrogateescape&lt;/tt&gt;
error handler: the encoders are now up to 3 times as fast.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="changes"&gt;
&lt;h2&gt;Changes&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Polish the implementation of the PEP 475 (retry syscall on EINTR)&lt;/li&gt;
&lt;li&gt;Work on the &amp;quot;What's New in Python 3.5&amp;quot; document: add my changes
(PEP 475, socket timeout, os.urandom)&lt;/li&gt;
&lt;li&gt;Work on asyncio: fix ResourceWarning warnings, fixes specific to Windows&lt;/li&gt;
&lt;li&gt;test_time: rewrite rounding tests of the private pytime API&lt;/li&gt;
&lt;li&gt;Issue #24707: Remove an assertion in monotonic clock. Don't check anymore at
runtime that the monotonic clock doesn't go backward.  Yes, it happens! It
occurs sometimes each month on a Debian buildbot slave running in a VM.&lt;/li&gt;
&lt;li&gt;test_eintr: replace os.fork() with subprocess (fork+exec) to make the test
more reliable&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="changes-specific-to-python-2-7"&gt;
&lt;h2&gt;Changes specific to Python 2.7&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Backport python-gdb.py changes: enhance py-bt command&lt;/li&gt;
&lt;li&gt;Issue #23375: Fix test_py3kwarn for modules implemented in C&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="bug-fixes"&gt;
&lt;h2&gt;Bug fixes&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Closes #23247: Fix a crash in the StreamWriter.reset() of CJK codecs&lt;/li&gt;
&lt;li&gt;Issue #24732, #23834: Fix sock_accept_impl() on Windows. Regression of the
PEP 475 (retry syscall on EINTR)&lt;/li&gt;
&lt;li&gt;test_gdb: fix regex to parse the GDB version and fix ResourceWarning on error&lt;/li&gt;
&lt;li&gt;Fix test_warnings: don't modify warnings.filters to fix random failures of
the test.&lt;/li&gt;
&lt;li&gt;Issue #24891: Fix a race condition at Python startup if the file descriptor
of stdin (0), stdout (1) or stderr (2) is closed while Python is creating
sys.stdin, sys.stdout and sys.stderr objects.&lt;/li&gt;
&lt;li&gt;Issue #24684: socket.socket.getaddrinfo() now calls
PyUnicode_AsEncodedString() instead of calling the encode() method of the
host, to handle correctly custom string with an encode() method which doesn't
return a byte string. The encoder of the IDNA codec is now called directly
instead of calling the encode() method of the string.&lt;/li&gt;
&lt;li&gt;Issue #25118: Fix a regression of Python 3.5.0 in os.waitpid() on Windows.
Add an unit test on os.waitpid()&lt;/li&gt;
&lt;li&gt;Issue #25122: Fix test_eintr, kill child process on error&lt;/li&gt;
&lt;li&gt;Issue #25155: Add _PyTime_AsTimevalTime_t() function to fix a regression:
support again years after 2038.&lt;/li&gt;
&lt;li&gt;Issue #25150: Hide the private _Py_atomic_xxx symbols from the public
Python.h header to fix a compilation error with OpenMP. PyThreadState_GET()
becomes an alias to PyThreadState_Get() to avoid ABI incompatibilies.&lt;/li&gt;
&lt;li&gt;Issue #25003: On Solaris 11.3 or newer, os.urandom() now uses the getrandom()
function instead of the getentropy() function.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="cpython"></category></entry><entry><title>History of the Python private C API _PyTime</title><link href="https://haypo.github.io/pytime.html" rel="alternate"></link><published>2016-02-17T22:00:00+01:00</published><author><name>Victor Stinner</name></author><id>tag:haypo.github.io,2016-02-17:pytime.html</id><summary type="html">&lt;p&gt;I added functions to the private &amp;quot;pytime&amp;quot; library to convert timestamps from/to
various formats. I expected to spend a few days, at the end I spent 3 years
(2012-2015) on them!&lt;/p&gt;
&lt;div class="section" id="python-3-3"&gt;
&lt;h2&gt;Python 3.3&lt;/h2&gt;
&lt;p&gt;In 2012, I proposed the &lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0410/"&gt;PEP 410 -- Use decimal.Decimal type for timestamps&lt;/a&gt; because storing timestamps as
floating point numbers looses precision. The PEP was rejected because it
modified many functions and had a bad API. At least, os.stat() got 3 new fields
(atime_ns, mtime_ns, ctime_ns): timestamps  as a number of nanoseconds
(&lt;tt class="docutils literal"&gt;int&lt;/tt&gt;).&lt;/p&gt;
&lt;p&gt;My &lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0418/"&gt;PEP 418 -- Add monotonic time, performance counter, and process time
functions&lt;/a&gt; was accepted, Python
3.3 got a new &lt;tt class="docutils literal"&gt;time.monotonic()&lt;/tt&gt; function (and a few others). Again, I spent
much more time than I expected on a problem which looked simple at the first
look.&lt;/p&gt;
&lt;p&gt;With the &lt;a class="reference external" href="http://bugs.python.org/issue14180"&gt;issue #14180&lt;/a&gt;, I added functions
to convert timestamps to the private &amp;quot;pytime&amp;quot; API to factorize the code of
various modules. Timestamps were rounded towards +infinity (ROUND_CEILING), but
it was not a deliberate choice.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="python-3-4"&gt;
&lt;h2&gt;Python 3.4&lt;/h2&gt;
&lt;p&gt;To fix correctly a performance issue in asyncio (&lt;a class="reference external" href="https://bugs.python.org/issue20311"&gt;issue20311&lt;/a&gt;), I added two rounding modes to the
pytime API: _PyTime_ROUND_DOWN (round towards zero), and _PyTime_ROUND_UP
(round away from zero). Polling for events (ex: using &lt;tt class="docutils literal"&gt;select.select()&lt;/tt&gt;) with
a non-zero timestamp must not call the underlying C level in non-blocking mode.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="python-3-5"&gt;
&lt;h2&gt;Python 3.5&lt;/h2&gt;
&lt;p&gt;When working on the &lt;a class="reference external" href="https://bugs.python.org/issue22117"&gt;issue #22117&lt;/a&gt;, I
noticed that the implementation of rounding methods was buggy for negative
timestamps. I replaced the _PyTime_ROUND_DOWN with _PyTime_ROUND_FLOOR (round
towards minus infinity), and _PyTime_ROUND_UP with _PyTime_ROUND_CEILING (round
towards infinity).&lt;/p&gt;
&lt;p&gt;This issue also introduced a new private &lt;tt class="docutils literal"&gt;_PyTime_t&lt;/tt&gt; type to support
nanosecond resolution.  The type is an opaque integer type to store timestamps.
In practice, it's a signed 64-bit integer. Since it's an integer, it's easy and
natural to compute the sum or differecence of two timestamps: &lt;tt class="docutils literal"&gt;t1 + t2&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;t2 - t1&lt;/tt&gt;. I added _PyTime_XXX() functions to create a timestamp and
_PyTime_AsXXX() functions to convert a timestamp to a different format.&lt;/p&gt;
&lt;p&gt;I had to keep three _PyTime_ObjectToXXX() functions for fromtimestamp() methods
of the datetime module. These methods must support extreme timestamps (year
1..9999), whereas _PyTime_t is &amp;quot;limited&amp;quot; to a delta of +/- 292 years (year
1678..2262).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="python-3-6"&gt;
&lt;h2&gt;Python 3.6&lt;/h2&gt;
&lt;p&gt;In 2015, the &lt;a class="reference external" href="http://bugs.python.org/issue23517"&gt;issue #23517&lt;/a&gt; reported that
Python 2 and Python 3 don't use the same rounding method in
datetime.datetime.fromtimestamp(): there was a difference of 1 microsecond.&lt;/p&gt;
&lt;p&gt;After a long discussion, I modified fromtimestamp() methods of the datetime
module to round to nearest with ties going away from zero (ROUND_HALF_UP), as
done in Python 2.7, as round() in all Python versions.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;It took me three years to stabilize the API and fix all issues. Well, I didn't
spend all my days on it, but it shows that handling time is not a simple issue.&lt;/p&gt;
&lt;p&gt;At the Python level, nothing changed, timestamps are still stored as float
(except of the 3 new fieleds of os.stat()).&lt;/p&gt;
&lt;p&gt;Python 3.5 only supports timezones with fixed offset, it does not support the
locale timestamp for example. Timezones are still an hot topic: the
&lt;a class="reference external" href="https://mail.python.org/mailman/listinfo/datetime-sig"&gt;datetime-sig mailing list&lt;/a&gt; was created to
enhance timezone support in Python.&lt;/p&gt;
&lt;/div&gt;
</summary><category term="cpython"></category></entry><entry><title>Status of the FAT Python project, January 12, 2016</title><link href="https://haypo.github.io/fat-python-status-janv12-2016.html" rel="alternate"></link><published>2016-01-12T13:42:00+01:00</published><author><name>Victor Stinner</name></author><id>tag:haypo.github.io,2016-01-12:fat-python-status-janv12-2016.html</id><summary type="html">&lt;a class="reference external image-reference" href="http://faster-cpython.readthedocs.org/fat_python.html"&gt;&lt;img alt="FAT Python project" class="align-right" src="https://haypo.github.io/images/fat_python.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;Previous status: &lt;a class="reference external" href="https://haypo.github.io/fat-python-status-nov26-2015.html"&gt;Status of the FAT Python project, November 26, 2015&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="summary"&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;New optimizations implemented:&lt;ul&gt;
&lt;li&gt;constant propagation&lt;/li&gt;
&lt;li&gt;constant folding&lt;/li&gt;
&lt;li&gt;dead code elimination&lt;/li&gt;
&lt;li&gt;simplify iterable&lt;/li&gt;
&lt;li&gt;replace builtin __debug__ variable with its value&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Major API refactoring to make the API more generic and reusable by other
projects, and maybe different use case.&lt;/li&gt;
&lt;li&gt;Work on 3 different Python Enhancement Proposals (PEP): API for pluggable
static optimizers and function specialization&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The two previously known major bugs, &amp;quot;Wrong Line Numbers (and Tracebacks)&amp;quot; and
&amp;quot;exec(code, dict)&amp;quot;, are now fixed.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="python-enhancement-proposals-pep"&gt;
&lt;h2&gt;Python Enhancement Proposals (PEP)&lt;/h2&gt;
&lt;p&gt;I proposed an API for to support function specialization and static optimizers.
I splitted changes in 3 different Python Enhancement Proposals (PEP):&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0509/"&gt;PEP 509 - Add a private version to dict&lt;/a&gt;: &amp;quot;Add a new private version to
builtin &lt;tt class="docutils literal"&gt;dict&lt;/tt&gt; type, incremented at each change, to implement fast guards
on namespaces.&amp;quot;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0510/"&gt;PEP 510 - Specialize functions&lt;/a&gt;: &amp;quot;Add functions to the Python C
API to specialize pure Python functions: add specialized codes with guards.
It allows to implement static optimizers respecting the Python semantics.&amp;quot;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0511/"&gt;PEP 511 - API for AST transformers&lt;/a&gt;: &amp;quot;Propose an API to
support AST transformers.&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The PEP 509 was sent to the python-ideas mailing list for a first round, and
then to python-dev mailing list.  The PEP 510 was sent to python-ideas to a
first round. The last PEP was not published yet, I'm still working on it.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="major-api-refactor"&gt;
&lt;h2&gt;Major API refactor&lt;/h2&gt;
&lt;p&gt;The API has been deeply refactored to write the Python Enhancement Proposals.&lt;/p&gt;
&lt;p&gt;First set of changes for function specialization (PEP 510):&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;astoptimizer now adds &lt;tt class="docutils literal"&gt;import fat&lt;/tt&gt; to optimized code when specialization is
used&lt;/li&gt;
&lt;li&gt;Remove the function subtype: add directly the &lt;tt class="docutils literal"&gt;specialize()&lt;/tt&gt; method to
functions&lt;/li&gt;
&lt;li&gt;Add support of any callable object to &lt;tt class="docutils literal"&gt;func.specialize()&lt;/tt&gt;, not only code
object (bytecode)&lt;/li&gt;
&lt;li&gt;Create guard objects:&lt;ul&gt;
&lt;li&gt;fat.Guard&lt;/li&gt;
&lt;li&gt;fat.GuardArgType&lt;/li&gt;
&lt;li&gt;fat.GuardBuiltins&lt;/li&gt;
&lt;li&gt;fat.GuardDict&lt;/li&gt;
&lt;li&gt;fat.GuardFunc&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Add functions to create guards:&lt;ul&gt;
&lt;li&gt;fat.GuardGlobals&lt;/li&gt;
&lt;li&gt;fat.GuardTypeDict&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Move code.replace_consts() to fat.replace_consts()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Second set of changes for AST transformers (PEP 511):&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Add sys.implementation.ast_transformers and sys.implementation.optim_tag&lt;/li&gt;
&lt;li&gt;Rename sys.asthook to sys.ast_transformers&lt;/li&gt;
&lt;li&gt;Add -X fat command line option to enable the FAT mode: register the
astoptimizer in AST transformers&lt;/li&gt;
&lt;li&gt;Replace -F command line option with -o OPTIM_TAG&lt;/li&gt;
&lt;li&gt;Remove sys.flags.fat (Python flag) and Py_FatPython (C variable)&lt;/li&gt;
&lt;li&gt;Rewrite how an AST transformer is registered&lt;/li&gt;
&lt;li&gt;importlib skips .py if optim_tag is not 'opt' and required AST transformers
are missing. Raise ImportError if the .pyc file is missing.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Third set of changes for dictionary versionning, updates after the first round
of the PEP 509 on python-ideas:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Remove dict.__version__ read-only property: the version is now only
accessible from the C API&lt;/li&gt;
&lt;li&gt;Change the type of the C field &lt;tt class="docutils literal"&gt;ma_version&lt;/tt&gt; from &lt;tt class="docutils literal"&gt;size_t&lt;/tt&gt; to &lt;tt class="docutils literal"&gt;unsigned
PY_INT64_T&lt;/tt&gt; to also use 64-bit unsigned integer on 32-bit platforms. The
risk of missing a change in a guard with a 32-bit version is too high,
whereas the risk with a 64-bit version is very very low.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Fourth set of changes for function specialization, updates after the first round
of the PEP 510 on python-ideas:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Remove func.specialize() and func.get_specialized() at the Python level,
replace them with C functions. Expose them again as fat.specialize(func, ...)
and fat.get_specialized(func)&lt;/li&gt;
&lt;li&gt;fat.get_specialized() now returns a list of tuples, instead of a list of dict&lt;/li&gt;
&lt;li&gt;Make fat.Guard type private: rename it to fat._Guard&lt;/li&gt;
&lt;li&gt;Add fat.PyGuard: toy to implement a guard in pure Python&lt;/li&gt;
&lt;li&gt;Guard C API: rename first_check to init and support reporting errors&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="change-log"&gt;
&lt;h2&gt;Change log&lt;/h2&gt;
&lt;p&gt;Detailed changes of the FAT Python between November 24, 2015 and January 12,
2016.&lt;/p&gt;
&lt;div class="section" id="end-of-november"&gt;
&lt;h3&gt;End of november&lt;/h3&gt;
&lt;p&gt;Major change:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Add a __version__ read-only property to dict, remove the verdict subtype of
dict. As a consequence, dictionary guards now hold a strong reference to the
dict value&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Minor changes:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Allocate dynamically memory for specialized code and guards, don't use fixed-size
arrays anymore&lt;/li&gt;
&lt;li&gt;astoptimizer: enhance scope detection&lt;/li&gt;
&lt;li&gt;optimize astoptimizer: don't copy a whole AST tree anymore with
copy.deepcopy(), only copy modified nodes.&lt;/li&gt;
&lt;li&gt;Add Config.max_constant_size&lt;/li&gt;
&lt;li&gt;Reenable checks on cell variables: allow cell variables if they are the same&lt;/li&gt;
&lt;li&gt;Reenable optimizations on methods calling super(), but never copy super()
builtin to constants. If super() is replaced with a string, the required free
variable (reference to the current class) is not created by the compiler&lt;/li&gt;
&lt;li&gt;Add PureBuiltin config&lt;/li&gt;
&lt;li&gt;NodeVisitor now calls generic_visit() before visit_XXX()&lt;/li&gt;
&lt;li&gt;Loop unrolling now also optimizes tuple iterators&lt;/li&gt;
&lt;li&gt;At the end of Python initialization, create a copy of the builtins dictionary
to be able later to detect if a builtin name was replaced.&lt;/li&gt;
&lt;li&gt;Implement collections.UserDict.__version__&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="december-first-half"&gt;
&lt;h3&gt;December (first half)&lt;/h3&gt;
&lt;p&gt;Major changes:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Implement 4 new optimizations:&lt;ul&gt;
&lt;li&gt;constant propagation&lt;/li&gt;
&lt;li&gt;constant folding&lt;/li&gt;
&lt;li&gt;replace builtin __debug__ variable with its value&lt;/li&gt;
&lt;li&gt;dead code elimination&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Add support of per module configuration using an __astoptimizer__ variable&lt;/li&gt;
&lt;li&gt;code.co_lnotab now supports negative line number delta.  Change the type of
line number delta in co_lnotab from unsigned 8-bit integer to signed 8-bit
integer. This change fixes almost all issues about line numbers.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Minor changes:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Change .pyc magic number to 3600&lt;/li&gt;
&lt;li&gt;Remove unused fat.specialized_method() function&lt;/li&gt;
&lt;li&gt;Remove Lib/fat.py, rename Modules/_fat.c to Modules/fat.c: fat module is now
only implemented in C&lt;/li&gt;
&lt;li&gt;Fix more tests of the Python test suite&lt;/li&gt;
&lt;li&gt;A builtin guard now adds a guard on globals. Ignore also the specialization
if globals()[name] already exists.&lt;/li&gt;
&lt;li&gt;Ignore duplicated guards&lt;/li&gt;
&lt;li&gt;Implement namespace following the control flow for constant propagation&lt;/li&gt;
&lt;li&gt;Config.max_int_bits becomes a simple integer&lt;/li&gt;
&lt;li&gt;Fix bytecode compilation for tuple constants. Don't merge (0, 0) and (0.0,
0.0) constants, they are different.&lt;/li&gt;
&lt;li&gt;Call more builtin functions&lt;/li&gt;
&lt;li&gt;Optimize the optimizer: write a metaclass to discover visitors when the class
is created, not when the class is instanciated&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="december-second-half"&gt;
&lt;h3&gt;December (second half)&lt;/h3&gt;
&lt;p&gt;Major changes:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Implement &amp;quot;simplify iterable&amp;quot; optimization. The loop unrolling optimization
now relies on it to replace &lt;tt class="docutils literal"&gt;range(n)&lt;/tt&gt;.&lt;/li&gt;
&lt;li&gt;Split the function optimization in two stages: first apply optimizations
which don't require specialization, then apply optimizations which
require specialization.&lt;/li&gt;
&lt;li&gt;Replace the builtin __fat__ variable with a new sys.flags.fat flag&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Minor changes:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Extend optimizations to optimize more cases (more builtins, more loop
unrolling, remove more dead code, etc.)&lt;/li&gt;
&lt;li&gt;Add Config.logger attribute. astoptimize logs into sys.stderr when Python is
started in verbose mode (python3 -v)&lt;/li&gt;
&lt;li&gt;Move func.patch_constants() to code.replace_consts()&lt;/li&gt;
&lt;li&gt;Enhance marshal to fix tests: call frozenset() to get the empty frozenset
singleton&lt;/li&gt;
&lt;li&gt;Don't remove code which must raise a SyntaxError. Don't remove code
containing the continue instruction.&lt;/li&gt;
&lt;li&gt;Restrict GlobalNonlocalVisitor to the current namespace&lt;/li&gt;
&lt;li&gt;Emit logs when optimizations are skipped&lt;/li&gt;
&lt;li&gt;Use some maths to avoid optimization pow() if result is an integer and will
be larger than the configuration. For example, don't optimize 2 ** (2**100).&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="january"&gt;
&lt;h3&gt;January&lt;/h3&gt;
&lt;p&gt;Major changes:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;astoptimizer now produces a single builtin guard with all names,
instead of a guard per name.&lt;/li&gt;
&lt;li&gt;Major API refactoring detailed in a dedicated section above&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Minor changes:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Start to write PEPs&lt;/li&gt;
&lt;li&gt;Dictionary guards now expect a list of names, instead of a single name, to
reduce the cost of guards.&lt;/li&gt;
&lt;li&gt;GuardFunc now uses a strong reference to the function, instead of a weak
reference to simplify the code&lt;/li&gt;
&lt;li&gt;Initialize dictionary version to 0&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
</summary><category term="optimization"></category><category term="fatpython"></category></entry><entry><title>Status of the FAT Python project, November 26, 2015</title><link href="https://haypo.github.io/fat-python-status-nov26-2015.html" rel="alternate"></link><published>2015-11-26T17:30:00+01:00</published><author><name>Victor Stinner</name></author><id>tag:haypo.github.io,2015-11-26:fat-python-status-nov26-2015.html</id><summary type="html">&lt;a class="reference external image-reference" href="http://faster-cpython.readthedocs.org/fat_python.html"&gt;&lt;img alt="FAT Python project" class="align-right" src="https://haypo.github.io/images/fat_python.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;Previous status: [python-dev] &lt;a class="reference external" href="https://mail.python.org/pipermail/python-dev/2015-November/142113.html"&gt;Second milestone of FAT Python&lt;/a&gt;
(Nov 4, 2015).&lt;/p&gt;
&lt;div class="section" id="documentation"&gt;
&lt;h2&gt;Documentation&lt;/h2&gt;
&lt;p&gt;I combined the documentation of various optimizations projects into a single
documentation: &lt;a class="reference external" href="http://faster-cpython.readthedocs.org/"&gt;Faster CPython&lt;/a&gt;.
My previous optimizations projects:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://faster-cpython.readthedocs.org/old_ast_optimizer.html"&gt;&amp;quot;old&amp;quot; astoptimizer&lt;/a&gt; (now
replaced with a &amp;quot;new&amp;quot; astoptimizer included in the FAT Python)&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://faster-cpython.readthedocs.org/registervm.html"&gt;registervm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://faster-cpython.readthedocs.org/readonly.html"&gt;read-only Python&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The FAT Python project has its own page: &lt;a class="reference external" href="http://faster-cpython.readthedocs.org/fat_python.html"&gt;FAT Python project&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="copy-builtins-to-constants-optimization"&gt;
&lt;h2&gt;Copy builtins to constants optimization&lt;/h2&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;LOAD_GLOBAL&lt;/tt&gt; instruction is used to load a builtin function.  The
instruction requires two dictionary lookup: one in the global namespace (which
almost always fail) and then in the builtin namespaces.&lt;/p&gt;
&lt;p&gt;It's rare to replace builtins, so the idea here is to replace the dynamic
&lt;tt class="docutils literal"&gt;LOAD_GLOBAL&lt;/tt&gt; instruction with a static &lt;tt class="docutils literal"&gt;LOAD_CONST&lt;/tt&gt; instruction which
loads the function from a C array, a fast O(1) lookup.&lt;/p&gt;
&lt;p&gt;It is not possible to inject a builtin function during the compilation. Python
code objects are serialized by the marshal module which only support simple
types like integers, strings and tuples, not functions. The trick is to modify
the constants at runtime when the module is loaded. I added a new
&lt;tt class="docutils literal"&gt;patch_constants()&lt;/tt&gt; method to functions.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
def log(message):
    print(message)
&lt;/pre&gt;
&lt;p&gt;This function is specialized to:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
def log(message):
    'LOAD_GLOBAL print'(message)
log.patch_constants({'LOAD_GLOBAL print': print})
&lt;/pre&gt;
&lt;p&gt;The specialized bytecode uses two guards on builtin and global namespaces to
disable the optimization if the builtin function is replaced.&lt;/p&gt;
&lt;p&gt;See &lt;a class="reference external" href="https://faster-cpython.readthedocs.org/fat_python.html#copy-builtin-functions-to-constants"&gt;Copy builtin functions to constants&lt;/a&gt;
for more information.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="loop-unrolling-optimization"&gt;
&lt;h2&gt;Loop unrolling optimization&lt;/h2&gt;
&lt;p&gt;A simple optimization is to &amp;quot;unroll&amp;quot; a loop to reduce the cost of loops. The
optimization generates assignement statements (for the loop index variable)
and duplicates the loop body.&lt;/p&gt;
&lt;p&gt;Example with a &lt;tt class="docutils literal"&gt;range()&lt;/tt&gt; iterator:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
def func():
    for i in (1, 2, 3):
        print(i)
&lt;/pre&gt;
&lt;p&gt;The function is specialized to:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
def func():
    i = 1
    print(i)

    i = 2
    print(i)

    i = 3
    print(i)
&lt;/pre&gt;
&lt;p&gt;If the iterator uses the builtin &lt;tt class="docutils literal"&gt;range&lt;/tt&gt; function, two guards are
required on builtin and global namespaces.&lt;/p&gt;
&lt;p&gt;The optimization also handles tuple iterator. No guard is needed in this case
(the code is always optimized).&lt;/p&gt;
&lt;p&gt;See &lt;a class="reference external" href="https://faster-cpython.readthedocs.org/fat_python.html#loop-unrolling"&gt;Loop unrolling&lt;/a&gt;
for more information.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="lot-of-enhancements-of-the-ast-optimizer"&gt;
&lt;h2&gt;Lot of enhancements of the AST optimizer&lt;/h2&gt;
&lt;p&gt;New optimizations helped to find bugs in the &lt;a class="reference external" href="https://faster-cpython.readthedocs.org/new_ast_optimizer.html"&gt;AST optimizer&lt;/a&gt;. Many fixes
and various enhancements were done in the AST optimizer.&lt;/p&gt;
&lt;p&gt;The number of lines of code more than doubled: 500 to 1200 lines.&lt;/p&gt;
&lt;p&gt;Optimization: &lt;tt class="docutils literal"&gt;copy.deepcopy()&lt;/tt&gt; is no more used to duplicate a full tree. The
new &lt;tt class="docutils literal"&gt;NodeTransformer&lt;/tt&gt; class now only copies a single node, if at least one
field is modified.&lt;/p&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;VariableVisitor&lt;/tt&gt; class which detects local and global variables was
heavily modified. It understands much more kinds of AST node: &lt;tt class="docutils literal"&gt;For&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;AugAssign&lt;/tt&gt;,
&lt;tt class="docutils literal"&gt;AsyncFunctionDef&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;ClassDef&lt;/tt&gt;, etc. It now also detects non-local
variables (&lt;tt class="docutils literal"&gt;nonlocal&lt;/tt&gt; keyword). The scope is now limited to the current
function, it doesn't enter inside nested &lt;tt class="docutils literal"&gt;DictComp&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;FunctionDef&lt;/tt&gt;,
&lt;tt class="docutils literal"&gt;Lambda&lt;/tt&gt;, etc. These nodes create a new separated namespace.&lt;/p&gt;
&lt;p&gt;The optimizer is now able to optimize a function without guards: it's needed to
unroll a loop using a tuple as iterator.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="known-bugs"&gt;
&lt;h2&gt;Known bugs&lt;/h2&gt;
&lt;p&gt;See the &lt;a class="reference external" href="https://hg.python.org/sandbox/fatpython/file/0d30dba5fa64/TODO.rst"&gt;TODO.rst file&lt;/a&gt; for
known bugs.&lt;/p&gt;
&lt;div class="section" id="wrong-line-numbers-and-tracebacks"&gt;
&lt;h3&gt;Wrong Line Numbers (and Tracebacks)&lt;/h3&gt;
&lt;p&gt;AST nodes have &lt;tt class="docutils literal"&gt;lineno&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;col_offset&lt;/tt&gt; fields, so an AST optimizer is not
&amp;quot;supposed&amp;quot; to break line numbers. In practice, line numbers, and so tracebacks,
are completly wrong in FAT mode. The problem is probably that AST optimizer can
copy and move instructions. Line numbers are no more motononic. CPython
probably don't handle this case (negative line delta).&lt;/p&gt;
&lt;p&gt;It should be possible to fix it, but right now I prefer to focus on new
optimizations and fix other bugs.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="exec-code-dict"&gt;
&lt;h3&gt;exec(code, dict)&lt;/h3&gt;
&lt;p&gt;In FAT mode, some optimizations require guards on the global namespace.
If &lt;tt class="docutils literal"&gt;exec()&lt;/tt&gt; if called with a Python &lt;tt class="docutils literal"&gt;dict&lt;/tt&gt; for globals, an exception
is raised because &lt;tt class="docutils literal"&gt;func.specialize()&lt;/tt&gt; requires a &lt;tt class="docutils literal"&gt;fat.verdict&lt;/tt&gt; for
globals.&lt;/p&gt;
&lt;p&gt;It's not possible to convert implicitly the &lt;tt class="docutils literal"&gt;dict&lt;/tt&gt; to a &lt;tt class="docutils literal"&gt;fat.verdict&lt;/tt&gt;,
because the &lt;tt class="docutils literal"&gt;dict&lt;/tt&gt; is expected to be mutated, and the guards be will on
&lt;tt class="docutils literal"&gt;fat.verdict&lt;/tt&gt; not on the original &lt;tt class="docutils literal"&gt;dict&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;I worked around the bug by creating manually a &lt;tt class="docutils literal"&gt;fat.verdict&lt;/tt&gt; in FAT mode,
instead of a &lt;tt class="docutils literal"&gt;dict&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;This bug will go avoid if the versionning feature is moved directly into
the builtin &lt;tt class="docutils literal"&gt;dict&lt;/tt&gt; type (and the &lt;tt class="docutils literal"&gt;fat.verdict&lt;/tt&gt; type is removed).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</summary><category term="optimization"></category><category term="fatpython"></category></entry><entry><title>Port your Python 2 applications to Python 3 with sixer</title><link href="https://haypo.github.io/python3-sixer.html" rel="alternate"></link><published>2015-06-16T15:00:00+02:00</published><author><name>Victor Stinner</name></author><id>tag:haypo.github.io,2015-06-16:python3-sixer.html</id><summary type="html">&lt;div class="section" id="from-2to3-to-2to6"&gt;
&lt;h2&gt;From 2to3 to 2to6&lt;/h2&gt;
&lt;p&gt;When Python 3.0 was released, the official statement was to port your
application using &lt;a class="reference external" href="https://docs.python.org/3.5/library/2to3.html"&gt;2to3&lt;/a&gt; and
drop Python 2 support. It didn't work because you had to port all libraries
first. If a library drops Python 2 support, existing applications running on
Python 2 cannot use this library anymore.&lt;/p&gt;
&lt;p&gt;This chicken-and-egg issue was solved by the creation of the &lt;a class="reference external" href="https://pythonhosted.org/six/"&gt;six module&lt;/a&gt; by &lt;a class="reference external" href="https://benjamin.pe/"&gt;Benjamin Peterson&lt;/a&gt;. Thank you so much Benjamin! Using the six module, it
is possible to write a single code base working on Python 2 and Python 3.&lt;/p&gt;
&lt;p&gt;2to3 was hacked to create the &lt;a class="reference external" href="http://python-modernize.readthedocs.org/"&gt;modernize&lt;/a&gt; and &lt;a class="reference external" href="https://github.com/limodou/2to6"&gt;2to6&lt;/a&gt; projects to &lt;em&gt;add Python 3 support&lt;/em&gt; without
loosing Python 2 support. Problem solved!&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="creation-of-the-sixer-tool"&gt;
&lt;h2&gt;Creation of the sixer tool&lt;/h2&gt;
&lt;p&gt;Problem solved? Well, not for my specific use case. I'm porting the huge
OpenStack project to Python 3. modernize and 2to6 modify a lot of things at
once, add unwanted changes (ex: add &lt;tt class="docutils literal"&gt;from __future__ import absolute_import&lt;/tt&gt;
at the top of each file), and don't respect the OpenStack coding style
(especially the &lt;a class="reference external" href="http://docs.openstack.org/developer/hacking/#imports"&gt;complex rules to sort and group Python imports&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;I wrote the &lt;a class="reference external" href="https://pypi.python.org/pypi/sixer"&gt;sixer&lt;/a&gt; project to
&lt;em&gt;generate&lt;/em&gt; patches for OpenStack. The problem is that OpenStack code changes
very quickly, so it's common to have to fix conflicts the day after submiting
a change. At the beginning, it took at least one week to get Python 3 changes
merged, whereas many changes are merged every day, so being able to regenerate
patches helped a lot.&lt;/p&gt;
&lt;p&gt;I created the &lt;a class="reference external" href="https://pypi.python.org/pypi/sixer"&gt;sixer&lt;/a&gt; tool using a list
of regular expressions to replace a pattern with another. For example, it
replaces &lt;tt class="docutils literal"&gt;dict.itervalues()&lt;/tt&gt; with &lt;tt class="docutils literal"&gt;six.itervalues(dict)&lt;/tt&gt;. The code was
very simple.  The most difficult part was to respect the OpenStack coding
style for Python imports.&lt;/p&gt;
&lt;p&gt;sixer is a success since its creationg, it helped me to fix the all obvious
Python 3 issues: replace &lt;tt class="docutils literal"&gt;unicode(x)&lt;/tt&gt; with &lt;tt class="docutils literal"&gt;six.text_type(x)&lt;/tt&gt;, replace
&lt;tt class="docutils literal"&gt;dict.itervalues()&lt;/tt&gt; with &lt;tt class="docutils literal"&gt;six.itervalues(dict)&lt;/tt&gt;, etc. These changes are
simple, but it's boring to have to modify manually many files. The OpenStack
Nova project has almost 1500 Python files for example.&lt;/p&gt;
&lt;p&gt;The development version of sixer supports the following operations:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;all&lt;/li&gt;
&lt;li&gt;basestring&lt;/li&gt;
&lt;li&gt;dict0&lt;/li&gt;
&lt;li&gt;dict_add&lt;/li&gt;
&lt;li&gt;iteritems&lt;/li&gt;
&lt;li&gt;iterkeys&lt;/li&gt;
&lt;li&gt;itertools&lt;/li&gt;
&lt;li&gt;itervalues&lt;/li&gt;
&lt;li&gt;long&lt;/li&gt;
&lt;li&gt;next&lt;/li&gt;
&lt;li&gt;raise&lt;/li&gt;
&lt;li&gt;six_moves&lt;/li&gt;
&lt;li&gt;stringio&lt;/li&gt;
&lt;li&gt;unicode&lt;/li&gt;
&lt;li&gt;urllib&lt;/li&gt;
&lt;li&gt;xrange&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="creation-of-the-sixer-test-suite"&gt;
&lt;h2&gt;Creation of the Sixer Test Suite&lt;/h2&gt;
&lt;p&gt;Slowly, I added more and more patterns to sixer. The code became too complex
to be able to check regressions manually, so I also started to write unit
tests. Now each operation has at least one unit test. Some complex operations
have four tests or more.&lt;/p&gt;
&lt;p&gt;At the beginning, tests called directly the Python function. It is fast and
convenient, but it failed to catch regressions on the command line program.
So I added tests running sixer has a blackbox: pass an input file and check
the output file. Then I added specific tests on the code parsing command line
options.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-new-all-operation"&gt;
&lt;h2&gt;The new &amp;quot;all&amp;quot; operation&lt;/h2&gt;
&lt;p&gt;At the beginning, I used sixer to generate a patch for a single pattern. For
example, replace &lt;tt class="docutils literal"&gt;unicode()&lt;/tt&gt; in a whole project.&lt;/p&gt;
&lt;p&gt;Later, I started to use it differently: I fixed all Python 3 issues at once,
but only in some selected files. I did that when we reached a minimum set of
tests which pass on Python 3 to have a green py34 check on Jenkins. Then we
ported tests one by one. It's better to write short patches, they are easier
and faster to review. And the review process is the bottlebeck of the
OpenStack development process.&lt;/p&gt;
&lt;p&gt;To fix all Python 3 at once, I added an &lt;tt class="docutils literal"&gt;all&lt;/tt&gt; operation which simply applies
sequentially each operation. So &lt;tt class="docutils literal"&gt;sixer&lt;/tt&gt; can now be used as &lt;tt class="docutils literal"&gt;modernize&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;2to6&lt;/tt&gt; to fix all Python 3 issues at once in a whole project.&lt;/p&gt;
&lt;p&gt;I also added the ability to pass filenames instead of having to pass a
directory to modify all files in all subdirectories.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="new-urllib-six-moves-and-stringio-operations"&gt;
&lt;h2&gt;New urllib, six_moves and stringio operations&lt;/h2&gt;
&lt;div class="section" id="urllib"&gt;
&lt;h3&gt;urllib&lt;/h3&gt;
&lt;p&gt;I tried to keep the sixer code simple. But some changes are boring to write,
like replacing &lt;tt class="docutils literal"&gt;urllib&lt;/tt&gt; imports &lt;tt class="docutils literal"&gt;six.moves.urllib&lt;/tt&gt; imports. Python 2 has 3
modules (&lt;tt class="docutils literal"&gt;urllib&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;urllib2&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;urlparse&lt;/tt&gt;), whereas Pytohn 3 uses a
single &lt;tt class="docutils literal"&gt;urllib&lt;/tt&gt; namespace with submodules (&lt;tt class="docutils literal"&gt;urllib.request&lt;/tt&gt;,
&lt;tt class="docutils literal"&gt;urllib.parse&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;urllib.error&lt;/tt&gt;). Some Python 2 functions moved to one
submodule, whereas others moved to another submodules. It required to know
well the old and new layout.&lt;/p&gt;
&lt;p&gt;After loosing many hours to write manually patches for &lt;tt class="docutils literal"&gt;urllib&lt;/tt&gt;, I decided
to add a &lt;tt class="docutils literal"&gt;urllib&lt;/tt&gt; operation. In fact, it was so not long to implement it,
compared to the time taken to write patches manually.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="stringio"&gt;
&lt;h3&gt;stringio&lt;/h3&gt;
&lt;p&gt;Handling StringIO is also a little bit tricky because String.StringIO and
String.cStringIO don't have the same performance on Python 2. Producing
patches without killing performances require to pick the right module or
symbol from six: &lt;tt class="docutils literal"&gt;six.StringIO()&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;six.moves.cStringIO.StringIO&lt;/tt&gt; for
example.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="six-moves"&gt;
&lt;h3&gt;six_moves&lt;/h3&gt;
&lt;p&gt;The generic &lt;tt class="docutils literal"&gt;six_moves&lt;/tt&gt; operation replaces various Python 2 imports with
imports from &lt;tt class="docutils literal"&gt;six.moves&lt;/tt&gt;:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;BaseHTTPServer&lt;/li&gt;
&lt;li&gt;ConfigParser&lt;/li&gt;
&lt;li&gt;Cookie&lt;/li&gt;
&lt;li&gt;HTMLParser&lt;/li&gt;
&lt;li&gt;Queue&lt;/li&gt;
&lt;li&gt;SimpleHTTPServer&lt;/li&gt;
&lt;li&gt;SimpleXMLRPCServer&lt;/li&gt;
&lt;li&gt;__builtin__&lt;/li&gt;
&lt;li&gt;cPickle&lt;/li&gt;
&lt;li&gt;cookielib&lt;/li&gt;
&lt;li&gt;htmlentitydefs&lt;/li&gt;
&lt;li&gt;httplib&lt;/li&gt;
&lt;li&gt;repr&lt;/li&gt;
&lt;li&gt;xmlrpclib&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="kiss-emit-warnings-instead-of-complex-implementation"&gt;
&lt;h2&gt;KISS: emit warnings instead of complex implementation&lt;/h2&gt;
&lt;p&gt;As I wrote, I tried to keep sixer simple (KISS principle: Keep It Simple,
Stupid). I'm also lazy, I didn't try to write a perfect tool. I don't want to
spend hours on the sixer project.&lt;/p&gt;
&lt;p&gt;When it was too tricky to make a decision or to implement a pattern, sixer
emits &amp;quot;warnings&amp;quot; instead. For example, a warning is emitted on
&lt;tt class="docutils literal"&gt;def next(self):&lt;/tt&gt; to remind that a &lt;tt class="docutils literal"&gt;__next__ = next&lt;/tt&gt; alias is probably
needed on this class for Python 3.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;The sixer tool is incomplete and generates invalid changes. For example, it
replaces patterns in comments, docstrings and strings, whereas usually these
changes don't make sense. But I'm happy because the tool helped me a lot
for to port OpenStack, it saved me hours.&lt;/p&gt;
&lt;p&gt;I hope that the tool will now be useful to others! Don't hesitate to give me
feedback.&lt;/p&gt;
&lt;/div&gt;
</summary><category term="python3"></category><category term="sixer"></category></entry></feed>