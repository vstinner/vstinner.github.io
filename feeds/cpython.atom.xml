<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Victor Stinner blog 3 - cpython</title><link href="https://vstinner.github.io/" rel="alternate"></link><link href="https://vstinner.github.io/feeds/cpython.atom.xml" rel="self"></link><id>https://vstinner.github.io/</id><updated>2022-12-12T23:00:00+01:00</updated><entry><title>Convert macros to functions in the Python C API</title><link href="https://vstinner.github.io/c-api-convert-macros-functions.html" rel="alternate"></link><published>2022-12-12T23:00:00+01:00</published><updated>2022-12-12T23:00:00+01:00</updated><author><name>Victor Stinner</name></author><id>tag:vstinner.github.io,2022-12-12:/c-api-convert-macros-functions.html</id><summary type="html">&lt;a class="reference external image-reference" href="https://www.exemplaire-editions.fr/librairie/livre/loeil-du-cyclone"&gt;&lt;img alt="L'oeil du cyclone - Théo Grosjean" src="https://vstinner.github.io/images/loeil_cyclone.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;&lt;em&gt;Drawing: &amp;quot;L'oeil du cyclone&amp;quot; by Théo Grosjean.&lt;/em&gt;&lt;/p&gt;
&lt;div class="section" id="convert-macros-to-functions"&gt;
&lt;h2&gt;Convert macros to functions&lt;/h2&gt;
&lt;p&gt;For 4 years, between Python 3.7 (2018) and Python 3.12 (2022), I made many
changes on macros in the Python C API to make the API less error prone (avoid
&lt;a class="reference external" href="https://gcc.gnu.org/onlinedocs/cpp/Macro-Pitfalls.html"&gt;macro pitfalls&lt;/a&gt;) and
better define the API …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;a class="reference external image-reference" href="https://www.exemplaire-editions.fr/librairie/livre/loeil-du-cyclone"&gt;&lt;img alt="L'oeil du cyclone - Théo Grosjean" src="https://vstinner.github.io/images/loeil_cyclone.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;&lt;em&gt;Drawing: &amp;quot;L'oeil du cyclone&amp;quot; by Théo Grosjean.&lt;/em&gt;&lt;/p&gt;
&lt;div class="section" id="convert-macros-to-functions"&gt;
&lt;h2&gt;Convert macros to functions&lt;/h2&gt;
&lt;p&gt;For 4 years, between Python 3.7 (2018) and Python 3.12 (2022), I made many
changes on macros in the Python C API to make the API less error prone (avoid
&lt;a class="reference external" href="https://gcc.gnu.org/onlinedocs/cpp/Macro-Pitfalls.html"&gt;macro pitfalls&lt;/a&gt;) and
better define the API (parameter types and return types, variable scope, etc.).
&lt;a class="reference external" href="https://peps.python.org/pep-0670/"&gt;PEP 670&lt;/a&gt; &amp;quot;Convert macros to functions in
the Python C API&amp;quot; describes in length the rationale of these changes.&lt;/p&gt;
&lt;p&gt;I moved private functions to the internal C API to reduce the C API size.&lt;/p&gt;
&lt;p&gt;Some changes are also related to preparing the API to make members of
structures like &lt;tt class="docutils literal"&gt;PyObject&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;PyTypeObject&lt;/tt&gt; private.&lt;/p&gt;
&lt;p&gt;Converting macros and static inline functions to regular functions hides
implementation details and bends the API towards the limited C API and the
stable ABI (build a C extension once, use the binary on multiple Python
versions). Regular functions are usable in programming languages and use cases
which cannot use C macros and C static inline functions.&lt;/p&gt;
&lt;p&gt;Most macros are converted to static inline functions, rather regular functions,
to have no impact on performance.&lt;/p&gt;
&lt;p&gt;This work was made incrementally in 5 Python versions (3.8, 3.9, 3.10, 3.11 and
3.12) to limit the number of impacted projects at each Python release.&lt;/p&gt;
&lt;p&gt;Changing &lt;tt class="docutils literal"&gt;Py_TYPE()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;Py_SIZE()&lt;/tt&gt; macros impacted most projects. Python
3.11 contains the change. During Python 3.10 development cycle, the change has
to be reverted since it impacted too many projects.&lt;/p&gt;
&lt;p&gt;Note: I didn't modify all macros and functions listed in this article, it's a
collaborative work as usual.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="statistics"&gt;
&lt;h2&gt;Statistics&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="https://pythoncapi.readthedocs.io/stats.html"&gt;Statistics on public functions&lt;/a&gt;:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Python 3.7: 893 regular functions, 315 macros.&lt;/li&gt;
&lt;li&gt;Python 3.12: 943 regular functions, 246 macros, 69 static inline functions.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Cumulative changes on macros between Python 3.7 and Python 3.12 on public,
private and internal APIs:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Converted 88 macros to static inline functions&lt;/li&gt;
&lt;li&gt;Converted 11 macros to regular functions&lt;/li&gt;
&lt;li&gt;Converted 3 static inline functions to regular functions:&lt;/li&gt;
&lt;li&gt;Removed 47 macros&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See &lt;a class="reference external" href="https://pythoncapi.readthedocs.io/stats.html"&gt;Statistics on the Python C API&lt;/a&gt; for more numbers.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="python-3-12"&gt;
&lt;h2&gt;Python 3.12&lt;/h2&gt;
&lt;p&gt;Convert 39 macros to static inline functions:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyCell_GET()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyCell_SET()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyCode_GetNumFree()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyDict_GET_SIZE()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyFloat_AS_DOUBLE()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyFunction_GET_ANNOTATIONS()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyFunction_GET_CLOSURE()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyFunction_GET_CODE()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyFunction_GET_DEFAULTS()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyFunction_GET_GLOBALS()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyFunction_GET_KW_DEFAULTS()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyFunction_GET_MODULE()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyInstanceMethod_GET_FUNCTION()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyMemoryView_GET_BASE()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyMemoryView_GET_BUFFER()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyMethod_GET_FUNCTION()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyMethod_GET_SELF()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PySet_GET_SIZE()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_UNICODE_HIGH_SURROGATE()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_UNICODE_ISALNUM()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_UNICODE_ISSPACE()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_UNICODE_IS_HIGH_SURROGATE()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_UNICODE_IS_LOW_SURROGATE()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_UNICODE_IS_SURROGATE()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_UNICODE_JOIN_SURROGATES()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_UNICODE_LOW_SURROGATE()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyGCHead_FINALIZED()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyGCHead_NEXT()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyGCHead_PREV()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyGCHead_SET_FINALIZED()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyGCHead_SET_NEXT()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyGCHead_SET_PREV()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyGC_FINALIZED()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyGC_SET_FINALIZED()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyObject_GC_IS_TRACKED()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyObject_GC_MAY_BE_TRACKED()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyObject_SIZE()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyObject_VAR_SIZE()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_Py_AS_GC()&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Remove 5 macros:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_AS_DATA()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_AS_UNICODE()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_GET_DATA_SIZE()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_GET_SIZE()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_WSTR_LENGTH()&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following 4 macros can be used as l-values in Python 3.12:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyList_GET_ITEM()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyTuple_GET_ITEM()&lt;/tt&gt;:&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyDescr_NAME()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyDescr_TYPE()&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Code pattern like &lt;tt class="docutils literal"&gt;&amp;amp;PyTuple_GET_ITEM(tuple, 0)&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;&amp;amp;PyList_GET_ITEM(list,
0)&lt;/tt&gt; is still commonly used to get a direct access to items as &lt;tt class="docutils literal"&gt;PyObject**&lt;/tt&gt;.
&lt;tt class="docutils literal"&gt;PyDescr_NAME()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;PyDescr_TYPE()&lt;/tt&gt; are used by SWIG: see
&lt;a class="reference external" href="https://bugs.python.org/issue46538"&gt;https://bugs.python.org/issue46538&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="python-3-11"&gt;
&lt;h2&gt;Python 3.11&lt;/h2&gt;
&lt;p&gt;Convert 33 macros to static inline functions:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyByteArray_AS_STRING()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyByteArray_GET_SIZE()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyBytes_AS_STRING()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyBytes_GET_SIZE()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyCFunction_GET_CLASS()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyCFunction_GET_FLAGS()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyCFunction_GET_FUNCTION()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyCFunction_GET_SELF()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyList_GET_SIZE()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyList_SET_ITEM()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyTuple_GET_SIZE()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyTuple_SET_ITEM()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_AS_DATA()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_AS_UNICODE()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_CHECK_INTERNED()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_DATA()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_GET_DATA_SIZE()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_GET_LENGTH()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_GET_SIZE()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_IS_ASCII()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_IS_COMPACT()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_IS_COMPACT_ASCII()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_IS_READY()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_MAX_CHAR_VALUE()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_READ()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_READY()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_READ_CHAR()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_WRITE()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyWeakref_GET_OBJECT()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_SIZE()&lt;/tt&gt;: &lt;tt class="docutils literal"&gt;Py_SET_SIZE()&lt;/tt&gt; must be used to set an object size&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_TYPE()&lt;/tt&gt;: &lt;tt class="docutils literal"&gt;Py_SET_TYPE()&lt;/tt&gt; must be used to set an object type&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyUnicode_COMPACT_DATA()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyUnicode_NONCOMPACT_DATA()&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Convert 2 macros to regular functions:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyType_SUPPORTS_WEAKREFS()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_GETENV()&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Remove 11 macros:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Moved to the internal C API:&lt;ul&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyHeapType_GET_MEMBERS()&lt;/tt&gt;: renamed to &lt;tt class="docutils literal"&gt;_PyHeapType_GET_MEMBERS()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_Py_InIntegralTypeRange()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_Py_IntegralTypeMax()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_Py_IntegralTypeMin()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_Py_IntegralTypeSigned()&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyFunction_AS_FRAME_CONSTRUCTOR()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_FORCE_DOUBLE()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_OVERFLOWED()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_SET_ERANGE_IF_OVERFLOW()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_SET_ERRNO_ON_MATH_ERROR()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_Py_SET_EDOM_FOR_NAN()&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Add &lt;tt class="docutils literal"&gt;_Py_RVALUE()&lt;/tt&gt; to 7 macros to disallow using them as l-value:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyGCHead_SET_FINALIZED()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyGCHead_SET_NEXT()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;asdl_seq_GET()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;asdl_seq_GET_UNTYPED()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;asdl_seq_LEN()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;asdl_seq_SET()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;asdl_seq_SET_UNTYPED()&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note: the &lt;tt class="docutils literal"&gt;PyCell_SET()&lt;/tt&gt; macro was modified to use &lt;tt class="docutils literal"&gt;_Py_RVALUE()&lt;/tt&gt;, but it
already used &lt;tt class="docutils literal"&gt;(void)&lt;/tt&gt; in Python 3.10.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="python-3-10"&gt;
&lt;h2&gt;Python 3.10&lt;/h2&gt;
&lt;p&gt;Convert 3 macros to regular functions:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyDescr_IsData()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyExceptionClass_Name()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyIter_Check()&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Convert 2 macros to static inline functions:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyObject_TypeCheck()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_REFCNT()&lt;/tt&gt;: &lt;tt class="docutils literal"&gt;Py_SET_REFCNT()&lt;/tt&gt; must be used to set an object reference
count&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Remove 6 macros:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyAST_Compile()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyParser_SimpleParseFile()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyParser_SimpleParseString()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PySTEntry_Check()&lt;/tt&gt;: moved to the internal C API&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyErr_OCCURRED()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyList_ITEMS()&lt;/tt&gt;: moved to the internal C API&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Modify 3 macros to disallow using them as l-values by adding &lt;tt class="docutils literal"&gt;(void)&lt;/tt&gt; cast:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyCell_SET()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyList_SET_ITEM()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyTuple_SET_ITEM()&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="python-3-9"&gt;
&lt;h2&gt;Python 3.9&lt;/h2&gt;
&lt;p&gt;Convert 6 macros to regular functions:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyIndex_Check()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyObject_CheckBuffer()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyObject_GET_WEAKREFS_LISTPTR()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyObject_IS_GC()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_EnterRecursiveCall()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_LeaveRecursiveCall()&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Convert 5 macros to static inline functions:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyType_Check()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyType_CheckExact()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyType_HasFeature()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_UNICODE_COPY()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_UNICODE_FILL()&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Convert 3 static inline functions to regular functions:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_Py_Dealloc()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_Py_ForgetReference()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_Py_NewReference()&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Remove 18 macros:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Moved to the internal C API:&lt;ul&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyDoc_STRVAR_shared()&lt;/tt&gt;:&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyObject_GC_IS_TRACKED()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyObject_GC_MAY_BE_TRACKED()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_AS_GC()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyGCHead_FINALIZED()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyGCHead_NEXT()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyGCHead_PREV()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyGCHead_SET_FINALIZED()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyGCHead_SET_NEXT()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyGCHead_SET_PREV()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyGC_SET_FINALIZED()&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_UNICODE_MATCH()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_Py_DEC_TPFREES()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_Py_INC_TPALLOCS()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_Py_INC_TPFREES()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_Py_MakeEndRecCheck()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_Py_MakeRecCheck()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_Py_RecursionLimitLowerWaterMark()&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="python-3-8"&gt;
&lt;h2&gt;Python 3.8&lt;/h2&gt;
&lt;p&gt;Convert 9 macros to static inline functions:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_DECREF()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_INCREF()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_XDECREF()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_XINCREF()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyObject_CallNoArg()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyObject_FastCall()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_Py_Dealloc()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_Py_ForgetReference()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_Py_NewReference()&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Remove 7 macros:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyGCHead_DECREF()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyGCHead_REFS()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyGCHead_SET_REFS()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyGC_REFS()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyObject_GC_TRACK()&lt;/tt&gt;: moved to the internal C API&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyObject_GC_UNTRACK()&lt;/tt&gt;: moved to the internal C API&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_Py_CHECK_REFCNT()&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content><category term="cpython"></category><category term="c-api"></category><category term="cpython"></category></entry><entry><title>Debug a Python reference leak</title><link href="https://vstinner.github.io/debug-python-refleak.html" rel="alternate"></link><published>2022-11-04T13:00:00+01:00</published><updated>2022-11-04T13:00:00+01:00</updated><author><name>Victor Stinner</name></author><id>tag:vstinner.github.io,2022-11-04:/debug-python-refleak.html</id><summary type="html">&lt;a class="reference external image-reference" href="https://twitter.com/djamilaknopf/status/1587441869403099136"&gt;&lt;img alt="Childhood memories in the countryside" src="https://vstinner.github.io/images/refleak.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;This morning, I got &lt;a class="reference external" href="https://mail.python.org/archives/list/buildbot-status&amp;#64;python.org/message/MU2EJRTFF4ZCYTDXYER7KCL3IQUM5F3T/"&gt;this email&lt;/a&gt;
from the buildbot-status mailing list:&lt;/p&gt;
&lt;blockquote&gt;
The Buildbot has detected a new failure on builder PPC64LE Fedora Rawhide
&lt;strong&gt;Refleaks&lt;/strong&gt; 3.x while building Python.&lt;/blockquote&gt;
&lt;p&gt;I get many of buildbot failures per month (by email), but I like to debug
reference leaks: they are more challenging …&lt;/p&gt;</summary><content type="html">&lt;a class="reference external image-reference" href="https://twitter.com/djamilaknopf/status/1587441869403099136"&gt;&lt;img alt="Childhood memories in the countryside" src="https://vstinner.github.io/images/refleak.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;This morning, I got &lt;a class="reference external" href="https://mail.python.org/archives/list/buildbot-status&amp;#64;python.org/message/MU2EJRTFF4ZCYTDXYER7KCL3IQUM5F3T/"&gt;this email&lt;/a&gt;
from the buildbot-status mailing list:&lt;/p&gt;
&lt;blockquote&gt;
The Buildbot has detected a new failure on builder PPC64LE Fedora Rawhide
&lt;strong&gt;Refleaks&lt;/strong&gt; 3.x while building Python.&lt;/blockquote&gt;
&lt;p&gt;I get many of buildbot failures per month (by email), but I like to debug
reference leaks: they are more challenging :-) I decided to write this article
to document and explain my work on maintaining Python (buildbots).&lt;/p&gt;
&lt;p&gt;I truncated most the output of most commands in this article to make it easier
to read.&lt;/p&gt;
&lt;p&gt;Drawing: &lt;a class="reference external" href="https://twitter.com/djamilaknopf/status/1587441869403099136"&gt;Childhood memories in the countryside&lt;/a&gt; by &lt;a class="reference external" href="https://twitter.com/djamilaknopf/"&gt;Djamila
Knopf&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="reproduce-the-bug"&gt;
&lt;h2&gt;Reproduce the bug&lt;/h2&gt;
&lt;p&gt;I look into &lt;a class="reference external" href="https://buildbot.python.org/all/#builders/300/builds/548"&gt;buildbot logs&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
test_int leaked [1, 1, 1] references, sum=3
&lt;/pre&gt;
&lt;p&gt;Aha, interesting: the &lt;tt class="docutils literal"&gt;test_int&lt;/tt&gt; test leaks Python strong references, each
test iteration leaks exactly one reference. Well, in short, it leaks memory.&lt;/p&gt;
&lt;p&gt;I build Python to check if the refleak is still there:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
git switch main
make clean
./configure --with-pydebug
make
&lt;/pre&gt;
&lt;p&gt;The main branch is currently at this commit:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ git show main
commit 2844aa6a8eb1d486b5c432f0ed33a2082998f41e
(...)
&lt;/pre&gt;
&lt;p&gt;I run the test with &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-R&lt;/span&gt; 3:3&lt;/tt&gt; to check for reference leaks:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ./python -m test -R 3:3 test_int
(...)
test_int leaked [1, 1, 1] references, sum=3
(...)
Total duration: 4.8 sec
&lt;/pre&gt;
&lt;p&gt;Great! It's still there, it's real regression. I told you, I love this kind of
bugs :-)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="identify-which-test-leaks-test-bisect-cmd"&gt;
&lt;h2&gt;Identify which test leaks (test.bisect_cmd)&lt;/h2&gt;
&lt;pre class="literal-block"&gt;
$ ./python -m test test_int --list-cases|wc -l
42
$ wc -l Lib/test/test_int.py
885 Lib/test/test_int.py
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;test_int&lt;/tt&gt; has only 42 methods and takes 4.8 seconds to run (with &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-R&lt;/span&gt;
3:3&lt;/tt&gt;).  That's small, but the file is made of 885 lines of Python code. I'm
lazy, I don't want to read so many lines. I will use &lt;tt class="docutils literal"&gt;python &lt;span class="pre"&gt;-m&lt;/span&gt;
test.bisect_cmd&lt;/tt&gt; to identify which test method leaks so I have less test code
to read and reproducing the test will be even faster.&lt;/p&gt;
&lt;p&gt;I run &lt;tt class="docutils literal"&gt;python &lt;span class="pre"&gt;-m&lt;/span&gt; test.bisect_cmd&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ./python -m test.bisect_cmd -R 3:3 test_int
(...)
[+] Iteration 17: run 1 tests/2
(...)
test_int leaked [1, 1, 1] references, sum=3
(...)
* test.test_int.PyLongModuleTests.test_pylong_misbehavior_error_path_from_str
&lt;/pre&gt;
&lt;p&gt;I love watching this tool doing my job, I don't have anything to do! :-)&lt;/p&gt;
&lt;p&gt;I confirm that the &lt;tt class="docutils literal"&gt;test_pylong_misbehavior_error_path_from_str()&lt;/tt&gt; test
leaks:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ./python -m test -R 3:3 test_int -m test_pylong_misbehavior_error_path_from_str
test_int leaked [1, 1, 1] references, sum=3
Total duration: 445 ms
&lt;/pre&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;test_pylong_misbehavior_error_path_from_str()&lt;/tt&gt; method is only 17 lines
of code, it's way better than 885 lines of code (52x less code to read). And
reproducing the bug now only takes 445 ms instead of 4.8 seconds (10x faster).&lt;/p&gt;
&lt;p&gt;At this point, there is the brave method of looking into the C code: Python is
made of 500 000 lines of C code. Good luck! Or maybe there is another way?&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="git-bisection"&gt;
&lt;h2&gt;Git bisection&lt;/h2&gt;
&lt;p&gt;Again, I'm lazy. I always begin with the &amp;quot;divide to conquer&amp;quot; method. A Git
bisection is an efficient method for that.&lt;/p&gt;
&lt;p&gt;I start &lt;tt class="docutils literal"&gt;git bisect&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
git bisect reset
git bisect start --term-bad=leak --term-good=noleak
git bisect leak  # we just saw that current commit leaks
&lt;/pre&gt;
&lt;p&gt;Defining &amp;quot;good&amp;quot; and &amp;quot;bad&amp;quot; terms helps me a lot to prevent mistakes: it's a nice
Git bisect feature! In the past, I always picked the wrong one at some point
which messed up the whole bisection.&lt;/p&gt;
&lt;p&gt;Ok, now how can I know when the leak was introduced? Well, I like to move in
the past step by step: one day, two days, one week, one month, one year, etc.&lt;/p&gt;
&lt;p&gt;I pick a random commit merged yesterday:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ date
Fri Nov  4 11:55:12 CET 2022

$ git log
(...)
commit 016c7d37b6acfe2203542a2655080c6402b3be1f
Date:   Thu Nov 3 23:21:01 2022 +0000
(...)
commit 4c4b5ce2e529a1279cd287e2d2d73ffcb6cf2ead
Date:   Thu Nov 3 16:18:38 2022 -0700
(...)
&lt;/pre&gt;
&lt;p&gt;I'm not lucky at my first bet, the code already leaked yesterday:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ git checkout 4c4b5ce2e529a1279cd287e2d2d73ffcb6cf2ead^C
$ make &amp;amp;&amp;amp; ./python -m test -R 3:3 test_int -m test_pylong_misbehavior_error_path_from_str
test_int leaked [1, 1, 1] references, sum=3
&lt;/pre&gt;
&lt;p&gt;I repeat the process, I pick a random commit the day before:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ git log
(...)
commit f3007ac3702ea22c7dd0abf8692b1504ea3c9f63
Author: Victor Stinner &amp;lt;vstinner&amp;#64;python.org&amp;gt;
Date:   Wed Nov 2 20:45:58 2022 +0100
(...)
&lt;/pre&gt;
&lt;p&gt;For my greatest pleasure, I pick a commit made by myself. Maybe I'm lucky and
I'm the one who introduced the leak :-D&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ git checkout f3007ac3702ea22c7dd0abf8692b1504ea3c9f63
$ make &amp;amp;&amp;amp; ./python -m test -R 3:3 test_int -m test_pylong_misbehavior_error_path_from_str
(...)
Tests result: NO TESTS RAN
&lt;/pre&gt;
&lt;p&gt;&amp;quot;NO TESTS RAN&amp;quot; means that the test doesn't exist. Oh wait, the test didn't
exist 2 days ago? So the test itself is new? Well, no tests ran also means...
&amp;quot;no leak&amp;quot;.&lt;/p&gt;
&lt;p&gt;I will make the assumption that &amp;quot;NO TESTS RAN&amp;quot; means &amp;quot;no leak&amp;quot; and see what's
going on:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ git bisect noleak
Bisecting: 13 revisions left to test after this (roughly 4 steps)

$ make &amp;amp;&amp;amp; ./python -m test -R 3:3 test_int -m test_pylong_misbehavior_error_path_from_str
Tests result: NO TESTS RAN
$ git bisect noleak
Bisecting: 6 revisions left to test after this (roughly 3 steps)

$ make &amp;amp;&amp;amp; ./python -m test -R 3:3 test_int -m test_pylong_misbehavior_error_path_from_str
Tests result: NO TESTS RAN
$ git bisect noleak
Bisecting: 3 revisions left to test after this (roughly 2 steps)

$ make &amp;amp;&amp;amp; ./python -m test -R 3:3 test_int -m test_pylong_misbehavior_error_path_from_str
Tests result: NO TESTS RAN
$ git bisect noleak
Bisecting: 1 revision left to test after this (roughly 1 step)

$ make &amp;amp;&amp;amp; ./python -m test -R 3:3 test_int -m test_pylong_misbehavior_error_path_from_str
test_int leaked [1, 1, 1] references, sum=3
$ git bisect leak
Bisecting: 0 revisions left to test after this (roughly 0 steps)

$ make &amp;amp;&amp;amp; ./python -m test -R 3:3 test_int -m test_pylong_misbehavior_error_path_from_str
test_int leaked [1, 1, 1] references, sum=3

vstinner&amp;#64;mona$ git bisect leak
4c4b5ce2e529a1279cd287e2d2d73ffcb6cf2ead is the first leak commit

commit 4c4b5ce2e529a1279cd287e2d2d73ffcb6cf2ead
Author: Gregory P. Smith &amp;lt;greg&amp;#64;krypto.org&amp;gt;
Date:   Thu Nov 3 16:18:38 2022 -0700

    gh-90716: bugfixes and more tests for _pylong. (#99073)

    * Properly decref on _pylong import error.
    * Improve the error message on _pylong TypeError.
    * Fix the assertion error in pydebug builds to be a TypeError.
    * Tie the return value comments together.

    These are minor followups to issues not caught among the reviewers on
    https://github.com/python/cpython/pull/96673.

 Lib/test/test_int.py | 39 +++++++++++++++++++++++++++++++++++++++
 Objects/longobject.c | 15 +++++++++++----
 2 files changed, 50 insertions(+), 4 deletions(-)
&lt;/pre&gt;
&lt;p&gt;In total, it took 7 &lt;tt class="docutils literal"&gt;git bisect&lt;/tt&gt; steps to identify a single commit. That's
quick! I also love this tool, I feel that it does my job!&lt;/p&gt;
&lt;p&gt;Sometimes, I mess up with Git bisection. Here, &lt;a class="reference external" href="https://github.com/python/cpython/commit/4c4b5ce2e529a1279cd287e2d2d73ffcb6cf2ead"&gt;the guilty commit&lt;/a&gt;
seems like a good candidate since it changes &lt;tt class="docutils literal"&gt;Objects/longobject.c&lt;/tt&gt; which is
C code, so it can likely introduce a leak. Moreover, this C file is the
implementation of the Python &lt;tt class="docutils literal"&gt;int&lt;/tt&gt; type, so it is directly related to
&lt;tt class="docutils literal"&gt;test_int&lt;/tt&gt; (the test suite of the &lt;tt class="docutils literal"&gt;int&lt;/tt&gt; type).&lt;/p&gt;
&lt;p&gt;Just in case, I test manually the the leak before/after:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# after
$ git checkout 4c4b5ce2e529a1279cd287e2d2d73ffcb6cf2ead
$ make &amp;amp;&amp;amp; ./python -m test -R 3:3 test_int -m test_pylong_misbehavior_error_path_from_str
test_int leaked [1, 1, 1] references, sum=3

# before
$ git checkout 4c4b5ce2e529a1279cd287e2d2d73ffcb6cf2ead^
$ make &amp;amp;&amp;amp; ./python -m test -R 3:3 test_int -m test_pylong_misbehavior_error_path_from_str
Tests result: NO TESTS RAN
&lt;/pre&gt;
&lt;p&gt;Ok, there is no doubt anymore: the commit introduced the leak. But since the
commit also adds the leaking test, maybe the leak already existed, and it's
just that nobody noticed the leak before.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="debug-the-leak"&gt;
&lt;h2&gt;Debug the leak&lt;/h2&gt;
&lt;p&gt;Since I identified the commit introducing the leak, I only have to review code
changes by this single commit. But to debug the code, I prefer to come back to
the main branch. To prepare a fix, I will have to start from the main branch
anyway.&lt;/p&gt;
&lt;p&gt;Go back to the main branch:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ git bisect reset
$ git switch main
&lt;/pre&gt;
&lt;p&gt;The second command is useless, I was already at the main branch. I did some
many mistakes with Git in the past, that I took the habit of doing things very
carefully. I don't care of doing things twice, just in case. It's cheaper than
messing with the Git god! Trust me.&lt;/p&gt;
&lt;p&gt;Just in case, I double check that the leak is still there in the main branch:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ make &amp;amp;&amp;amp; ./python -m test -R 3:3 test_int -m test_pylong_misbehavior_error_path_from_str
test_int leaked [1, 1, 1] references, sum=3
&lt;/pre&gt;
&lt;p&gt;Ok, we are good to start debugging. Let me open Lib/test/test_int.py and look
for the test_pylong_misbehavior_error_path_from_str() method:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;#64;support.cpython_only  # tests implementation details of CPython.
&amp;#64;unittest.skipUnless(_pylong, &amp;quot;_pylong module required&amp;quot;)
&amp;#64;mock.patch.object(_pylong, &amp;quot;int_from_string&amp;quot;)
def test_pylong_misbehavior_error_path_from_str(
        self, mock_int_from_str):
    big_value = '7'*19_999
    with support.adjust_int_max_str_digits(20_000):
        mock_int_from_str.return_value = b'not an int'
        with self.assertRaises(TypeError) as ctx:
            int(big_value)
        self.assertIn('_pylong.int_from_string did not',
                      str(ctx.exception))

        mock_int_from_str.side_effect = RuntimeError(&amp;quot;test123&amp;quot;)
        with self.assertRaises(RuntimeError):
            int(big_value)
&lt;/pre&gt;
&lt;p&gt;Always divide to conquer: let me try to make the code as short as possible (7
lines), I also make the &amp;quot;big_value&amp;quot; smaller:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;#64;mock.patch.object(_pylong, &amp;quot;int_from_string&amp;quot;)
def test_pylong_misbehavior_error_path_from_str(self, mock_int_from_str):
    big_value = '7' * 9999
    with support.adjust_int_max_str_digits(10_000):
        mock_int_from_str.return_value = b'not an int'
        with self.assertRaises(TypeError) as ctx:
            int(big_value)
&lt;/pre&gt;
&lt;p&gt;Ok, so the test is about converting a long string (9999 decimal digits) to an
integer using the new &lt;tt class="docutils literal"&gt;_pylong&lt;/tt&gt; module which is implemented
in pure Python (&lt;tt class="docutils literal"&gt;Lib/_pylong.py&lt;/tt&gt;) and called from C code
(&lt;tt class="docutils literal"&gt;Objects/longobject.c&lt;/tt&gt;). Well, I followed recent developments, so I don't
have to dig into the C code to know that. It helps!&lt;/p&gt;
&lt;p&gt;If I search for &lt;tt class="docutils literal"&gt;_pylong&lt;/tt&gt; in &lt;tt class="docutils literal"&gt;Objects/longobject.c&lt;/tt&gt;, I find this
interesting function:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
/* asymptotically faster str-to-long conversion for base 10, using _pylong.py */
static int
pylong_int_from_string(const char *start, const char *end, PyLongObject **res)
{
    PyObject *mod = PyImport_ImportModule(&amp;quot;_pylong&amp;quot;);
    ...
}
&lt;/pre&gt;
&lt;p&gt;With a quick look, I don't see any obvious reference leak in this code. I add
&lt;tt class="docutils literal"&gt;printf()&lt;/tt&gt; to make sure that I'm looking at the right function:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static int
pylong_int_from_string(const char *start, const char *end, PyLongObject **res)
{
    ...
    PyObject *s = PyUnicode_FromStringAndSize(start, end-start);
    if (s == NULL) {
        Py_DECREF(mod);
        goto error;
    }
printf(&amp;quot;pylong_int_from_string()\n&amp;quot;);
    PyObject *result = PyObject_CallMethod(mod, &amp;quot;int_from_string&amp;quot;, &amp;quot;O&amp;quot;, s);
    ...
}
&lt;/pre&gt;
&lt;p&gt;I added the print before the int_from_string() call, since this function is
overriden by the test.&lt;/p&gt;
&lt;p&gt;I build Python and run the test:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ make
$ ./python -m test -R 3:3 test_int -m test_pylong_misbehavior_error_path_from_str
(...)
beginning 6 repetitions
123456
pylong_int_from_string()
.pylong_int_from_string()
.pylong_int_from_string()
.pylong_int_from_string()
.pylong_int_from_string()
.pylong_int_from_string()
(...)
&lt;/pre&gt;
&lt;p&gt;Ok, I'm looking at the right place. The print happens when the test runs. So
which code path is taken?  Let me add print calls &lt;em&gt;after&lt;/em&gt; the function call:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static int
pylong_int_from_string(const char *start, const char *end, PyLongObject **res)
{
    ...
    PyObject *result = PyObject_CallMethod(mod, &amp;quot;int_from_string&amp;quot;, &amp;quot;O&amp;quot;, s);
    Py_DECREF(s);
    Py_DECREF(mod);
    if (result == NULL) {
printf(&amp;quot;pylong_int_from_string() error\n&amp;quot;);   // &amp;lt;====== ADD
        goto error;
    }
    if (!PyLong_Check(result)) {
printf(&amp;quot;pylong_int_from_string() wrong type\n&amp;quot;);   // &amp;lt;====== ADD
        PyErr_SetString(PyExc_TypeError,
                        &amp;quot;_pylong.int_from_string did not return an int&amp;quot;);
        goto error;
    }
printf(&amp;quot;pylong_int_from_string() ok\n&amp;quot;);   // &amp;lt;====== ADD
    ...
}
&lt;/pre&gt;
&lt;p&gt;Test output:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
...
pylong_int_from_string() wrong type
.pylong_int_from_string() wrong type
.pylong_int_from_string() wrong type
...
&lt;/pre&gt;
&lt;p&gt;Aha, the bug should be around the &lt;tt class="docutils literal"&gt;if (!PyLong_Check(result))&lt;/tt&gt; code path. Oh
wait... &lt;tt class="docutils literal"&gt;result&lt;/tt&gt; is a Python object, and in this code path, the function exits
without returning &lt;tt class="docutils literal"&gt;result&lt;/tt&gt; to the caller, nor removing the reference to
&lt;tt class="docutils literal"&gt;result&lt;/tt&gt;. That's our leak!&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="write-a-fix"&gt;
&lt;h2&gt;Write a fix&lt;/h2&gt;
&lt;p&gt;To write a fix, I start by reverting all local changes (remove debug traces,
restore the original test code):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ git checkout .
&lt;/pre&gt;
&lt;p&gt;I write a fix:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ git diff
diff --git a/Objects/longobject.c b/Objects/longobject.c
index a872938990..652fdb7974 100644
--- a/Objects/longobject.c
+++ b/Objects/longobject.c
&amp;#64;&amp;#64; -2376,6 +2376,7 &amp;#64;&amp;#64; pylong_int_from_string(const char *start, const char *end, PyLongObject **res)
         goto error;
     }
     if (!PyLong_Check(result)) {
+        Py_DECREF(result);
         PyErr_SetString(PyExc_TypeError,
                         &amp;quot;_pylong.int_from_string did not return an int&amp;quot;);
         goto error;
&lt;/pre&gt;
&lt;p&gt;I build and test my fix:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ make &amp;amp;&amp;amp; ./python -m test -R 3:3 test_int -m test_pylong_misbehavior_error_path_from_str
(...)
Tests result: SUCCESS
&lt;/pre&gt;
&lt;p&gt;Ok, the leak is fixed! So it was a just a missing &lt;tt class="docutils literal"&gt;Py_DECREF()&lt;/tt&gt; in code
recently added to Python. It's a common mistake. By the way, when I looked at
the code the first code, I also missed this &amp;quot;obvious&amp;quot; leak.&lt;/p&gt;
&lt;p&gt;I prepare a PR:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ git switch -c int_str
$ git commit -a
# Commit message:
# gh-90716: Fix pylong_int_from_string() refleak
&lt;/pre&gt;
&lt;p&gt;Let me validate my work from the new clean commit:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ make &amp;amp;&amp;amp; ./python -m test -R 3:3 test_int
(...)
Tests result: SUCCESS
&lt;/pre&gt;
&lt;p&gt;I complete the commit message using &lt;tt class="docutils literal"&gt;git commit &lt;span class="pre"&gt;--amend&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
gh-90716: Fix pylong_int_from_string() refleak

Fix validated by:

    $ ./python -m test -R 3:3 test_int
    Tests result: SUCCESS
&lt;/pre&gt;
&lt;p&gt;I run &lt;tt class="docutils literal"&gt;gh_pr.sh&lt;/tt&gt; (my short shell script) to create a PR from the command
line.&lt;/p&gt;
&lt;p&gt;I add the &lt;tt class="docutils literal"&gt;skip news&lt;/tt&gt; label on the PR, since this refleak is not part of any
Python release, no user is impacted. It's not worth documenting it. I don't
think that the change is part of Python 3.12 alpha 1. Moreover, only very few
users test alpha 1 releases.&lt;/p&gt;
&lt;p&gt;Here it is, my shiny PR fixing the leak! &lt;a class="reference external" href="https://github.com/python/cpython/pull/99094"&gt;https://github.com/python/cpython/pull/99094&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Since Gregory worked on longobject.c recently, I add him in copy of my PR. I
just add the comment &lt;tt class="docutils literal"&gt;cc &amp;#64;gpshead&lt;/tt&gt; to my PR.&lt;/p&gt;
&lt;p&gt;I don't plan to wait for this review. The change is just one line, I'm
confident that it does fix the issue, I don't need a review.&lt;/p&gt;
&lt;p&gt;To finish, I &lt;a class="reference external" href="https://mail.python.org/archives/list/buildbot-status&amp;#64;python.org/message/J3MC7FIPFN6GNQAWQQRHE4EDLE7J2MIQ/"&gt;reply by email to the buildbot-status failure email&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;In total, it took me between one and two hours to reproduce, debug and fix this
reference leak.&lt;/p&gt;
&lt;p&gt;In the meanwhile, I also looked into other Python stuffs (and I discussed with
friends!), while the bisection was running, or during the Python build. It's
hard to estimate exactly how much time it takes me to fix a refleak.&lt;/p&gt;
&lt;p&gt;I consider that I'm efficient on fixing such leak since I'm following the
Python development: I was already aware of the on-going &lt;tt class="docutils literal"&gt;_pylong&lt;/tt&gt; work. I
also fixed many refleaks in the past.&lt;/p&gt;
&lt;p&gt;By the way, I wrote the &lt;tt class="docutils literal"&gt;python &lt;span class="pre"&gt;-m&lt;/span&gt; test.bisect_cmd&lt;/tt&gt; tool exactly to
accelerate my work on debugging reference leaks. I'm now also used to Git
bisection.&lt;/p&gt;
&lt;p&gt;For me, &lt;strong&gt;the key of my whole methodology is to &amp;quot;divide to conquer&amp;quot;&lt;/strong&gt;:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Reproduce the issue&lt;/li&gt;
&lt;li&gt;Get a reproducer&lt;/li&gt;
&lt;li&gt;Make the reproducer as fast as possible and as short as possible&lt;/li&gt;
&lt;li&gt;Use Git bisection to identify the change introducing the change&lt;/li&gt;
&lt;li&gt;Add print calls to identify which parts of the code and the test are
taken by the issue&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Oh by the way, while I finished my article, my PR got reviewed and I merged it:
&lt;a class="reference external" href="https://github.com/python/cpython/commit/387f72588d538bc56669f0f28cc41df854fc5b43"&gt;my commit fixing the leak&lt;/a&gt;!&lt;/p&gt;
&lt;/div&gt;
</content><category term="cpython"></category><category term="refleak"></category><category term="cpython"></category></entry><entry><title>Python C API: Add functions to access PyObject</title><link href="https://vstinner.github.io/c-api-abstract-pyobject.html" rel="alternate"></link><published>2021-10-05T14:00:00+02:00</published><updated>2021-10-05T14:00:00+02:00</updated><author><name>Victor Stinner</name></author><id>tag:vstinner.github.io,2021-10-05:/c-api-abstract-pyobject.html</id><summary type="html">&lt;a class="reference external image-reference" href="https://twitter.com/Kekeflipnote/status/1433139994516934663"&gt;&lt;img alt="A spider in my bedroom" src="https://vstinner.github.io/images/spider.png" /&gt;&lt;/a&gt;
&lt;p&gt;The PyObject structure prevents indirectly to optimize CPython. We will see why
and how I prepared the C API to make this structure opaque. It took me 1 year
and a half to add functions and to introduce &lt;strong&gt;incompatible C API changes&lt;/strong&gt;
(fear!).&lt;/p&gt;
&lt;p&gt;In February 2020, I started by adding …&lt;/p&gt;</summary><content type="html">&lt;a class="reference external image-reference" href="https://twitter.com/Kekeflipnote/status/1433139994516934663"&gt;&lt;img alt="A spider in my bedroom" src="https://vstinner.github.io/images/spider.png" /&gt;&lt;/a&gt;
&lt;p&gt;The PyObject structure prevents indirectly to optimize CPython. We will see why
and how I prepared the C API to make this structure opaque. It took me 1 year
and a half to add functions and to introduce &lt;strong&gt;incompatible C API changes&lt;/strong&gt;
(fear!).&lt;/p&gt;
&lt;p&gt;In February 2020, I started by adding functions like &lt;tt class="docutils literal"&gt;Py_SET_TYPE()&lt;/tt&gt; to
abstract accesses to the &lt;tt class="docutils literal"&gt;PyObject&lt;/tt&gt; structure. I modified C extensions of the
standard library to use functions like &lt;tt class="docutils literal"&gt;Py_TYPE()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;Py_SET_TYPE()&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;I converted the &lt;tt class="docutils literal"&gt;Py_TYPE()&lt;/tt&gt; macro to a static inline function, but my change
was reverted twice. I had to fix many C extensions and fix a test_exceptions
crash on Windows to be able to finally merge my change in September 2021.&lt;/p&gt;
&lt;p&gt;Finally, we will also see what can be done next to be able to fully make the
PyObject structure opaque.&lt;/p&gt;
&lt;p&gt;Thanks to &lt;strong&gt;Dong-hee Na&lt;/strong&gt;, &lt;strong&gt;Hai Shi&lt;/strong&gt; and &lt;strong&gt;Andy Lester&lt;/strong&gt; who helped me to
make these changes, and thanks to &lt;strong&gt;Miro Hrončok&lt;/strong&gt; who reported C extensions
broken by my incompatible C API changes.&lt;/p&gt;
&lt;p&gt;This article is a follow-up of the &lt;a class="reference external" href="https://vstinner.github.io/c-api-opaque-structures.html"&gt;Make structures opaque in the Python C API&lt;/a&gt; article.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Drawing: &amp;quot;A spider in my bedroom&amp;quot; by Kéké&lt;/em&gt;&lt;/p&gt;
&lt;div class="section" id="the-c-api-prevents-to-optimize-cpython"&gt;
&lt;h2&gt;The C API prevents to optimize CPython&lt;/h2&gt;
&lt;p&gt;The C API allows to access directly to structure members by deferencing an
&lt;tt class="docutils literal"&gt;PyObject*&lt;/tt&gt; pointer. Example getting directly the reference count of an
object:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Py_ssize_t get_refcnt(PyObject *obj)
{
    return obj-&amp;gt;ob_refcnt;
}
&lt;/pre&gt;
&lt;p&gt;This ability to access directly structure members prevents optimizing CPython.&lt;/p&gt;
&lt;div class="section" id="mandatory-inefficient-boxing-unboxing"&gt;
&lt;h3&gt;Mandatory inefficient boxing/unboxing&lt;/h3&gt;
&lt;p&gt;The ability to dereference a &lt;tt class="docutils literal"&gt;PyObject*&lt;/tt&gt; pointer prevents optimizations which
avoid inefficient boxing/unboxing, like tagged pointers or list strategies.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="no-tagged-pointer"&gt;
&lt;h3&gt;No tagged pointer&lt;/h3&gt;
&lt;p&gt;Tagged pointers require adding code to all functions which currently
dereference object pointers. The current C API prevents doing that in C
extensions, since pointers can be dereferenced directly.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="no-list-strategies"&gt;
&lt;h3&gt;No list strategies&lt;/h3&gt;
&lt;p&gt;Since all Python object structures must start with a &lt;tt class="docutils literal"&gt;PyObject ob_base;&lt;/tt&gt;
member, it is not possible to make other structures opaque before PyObject is
made opaque. It prevents implementing PyPy list strategies to reduce the memory
footprint, like storing an array of numbers directly as numbers, not as boxed
numbers (&lt;tt class="docutils literal"&gt;PyLongObject&lt;/tt&gt; objects).&lt;/p&gt;
&lt;p&gt;Currently, the &lt;tt class="docutils literal"&gt;PyListObject&lt;/tt&gt; structure cannot be made opaque. If
&lt;tt class="docutils literal"&gt;PyListObject&lt;/tt&gt; could be made opaque, it would be possible to store an array
of numbers directly as numbers, and to box objects in &lt;tt class="docutils literal"&gt;PyList_GetItem()&lt;/tt&gt; on
demand.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="no-moving-garbage-collector"&gt;
&lt;h3&gt;No moving garbage collector&lt;/h3&gt;
&lt;p&gt;Being able to dereference a &lt;tt class="docutils literal"&gt;PyObject**&lt;/tt&gt; pointer also prevents to move
objects in memory. A moving garbage collector can compact memory to reduce the
fragmentation. Currently, it cannot be implemented in CPython.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="cannot-allocate-temporarily-objects-on-the-stack"&gt;
&lt;h3&gt;Cannot allocate temporarily objects on the stack&lt;/h3&gt;
&lt;p&gt;In CPython, all objects must be allocated on the heap. If an object is
allocated on the stack, stored in a list and the list is still accessible after
the function completes: the stack memory is no longer valid, and so the list is
corrupted at the function exit.&lt;/p&gt;
&lt;p&gt;If objects would only be referenced by opaque handles, as the HPy project does,
it would be possible to copy the object from the stack to the heap memory, when
the object is added to the list.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="reference-counting-doesn-t-scale"&gt;
&lt;h3&gt;Reference counting doesn't scale&lt;/h3&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;PyObject&lt;/tt&gt; structure has a reference count (&lt;tt class="docutils literal"&gt;ob_refcnt&lt;/tt&gt; member),
whereas reference counting is a performance bottleneck when using the same
objects from multiple threads running in parallel. Quickly, there is a race for
the memory cacheline which contains the &lt;tt class="docutils literal"&gt;PyObject.ob_refcnt&lt;/tt&gt; counter. It is
especially true for the most commonly used Python objects like None and True
singletons. All CPUs want to read or modify it in parallel.&lt;/p&gt;
&lt;p&gt;This problem killed the Gilectomy project which attempted to remove the GIL
from CPython.&lt;/p&gt;
&lt;p&gt;A &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Tracing_garbage_collection"&gt;tracing garbage collector&lt;/a&gt; doesn't need
reference counting, but it cannot be implemented currently because of the
&lt;tt class="docutils literal"&gt;PyObject&lt;/tt&gt; structure.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="creation-of-the-issue-feb-2020"&gt;
&lt;h2&gt;Creation of the issue (Feb 2020)&lt;/h2&gt;
&lt;p&gt;In February 2020, I created the &lt;a class="reference external" href="https://bugs.python.org/issue39573"&gt;bpo-39573&lt;/a&gt; : &amp;quot;[C API] Make PyObject an opaque
structure in the limited C API&amp;quot;. It is related to my work on the my &lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0620/"&gt;PEP 620
(Hide implementation details from the C API)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;My initial plan was to make the PyObject structure fully opaque in the C API.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="add-functions"&gt;
&lt;h2&gt;Add functions&lt;/h2&gt;
&lt;p&gt;In Python 3.8, &lt;tt class="docutils literal"&gt;Py_REFCNT()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;Py_TYPE()&lt;/tt&gt; macros can be used to set directly an
object reference count or an object type:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Py_REFCNT(obj) = new_refcnt;
Py_TYPE(obj) = new_type;
&lt;/pre&gt;
&lt;p&gt;Such syntax requires a direct access to &lt;tt class="docutils literal"&gt;PyObject.ob_refcnt&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;PyObject.ob_type&lt;/tt&gt; members as l-value.&lt;/p&gt;
&lt;p&gt;In Python 3.9, I added Py_SET_REFCNT() and Py_SET_TYPE() functions to add an
abstraction to &lt;tt class="docutils literal"&gt;PyObject&lt;/tt&gt; members, and I added &lt;tt class="docutils literal"&gt;Py_SET_SIZE()&lt;/tt&gt; to add an
abstraction to the &lt;tt class="docutils literal"&gt;PyVarObject.ob_size&lt;/tt&gt; member.&lt;/p&gt;
&lt;p&gt;In Python 3.9, I also added &lt;tt class="docutils literal"&gt;Py_IS_TYPE(obj, type,)&lt;/tt&gt; helper function to test
an object type. It is equivalent to: &lt;tt class="docutils literal"&gt;Py_TYPE(obj) == type&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="use-py-type-and-py-set-size-in-the-stdlib"&gt;
&lt;h2&gt;Use Py_TYPE() and Py_SET_SIZE() in the stdlib&lt;/h2&gt;
&lt;p&gt;I modified the standard library (C extensions) to no longer access directly
&lt;tt class="docutils literal"&gt;PyObject&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;PyVarObject&lt;/tt&gt; members directly:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Replace &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;&amp;quot;obj-&amp;gt;ob_refcnt&amp;quot;&lt;/span&gt;&lt;/tt&gt; with &lt;tt class="docutils literal"&gt;Py_REFCNT(obj)&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;Replace &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;&amp;quot;obj-&amp;gt;ob_type&amp;quot;&lt;/span&gt;&lt;/tt&gt; with &lt;tt class="docutils literal"&gt;Py_TYPE(obj)&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;Replace &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;&amp;quot;obj-&amp;gt;ob_size&amp;quot;&lt;/span&gt;&lt;/tt&gt; with &lt;tt class="docutils literal"&gt;Py_SIZE(obj)&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;Replace &lt;tt class="docutils literal"&gt;&amp;quot;Py_REFCNT(obj) = new_refcnt&amp;quot;&lt;/tt&gt; with &lt;tt class="docutils literal"&gt;Py_SET_REFCNT(obj, new_refcnt)&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;Replace &lt;tt class="docutils literal"&gt;&amp;quot;Py_TYPE(obj) = new_type&amp;quot;&lt;/tt&gt; with &lt;tt class="docutils literal"&gt;Py_SET_TYPE(obj, new_type)&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;Replace &lt;tt class="docutils literal"&gt;&amp;quot;Py_SIZE(obj) = new_size&amp;quot;&lt;/tt&gt; with &lt;tt class="docutils literal"&gt;Py_SET_SIZE(obj, new_size)&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;Replace &lt;tt class="docutils literal"&gt;&amp;quot;Py_TYPE(obj) == type&amp;quot;&lt;/tt&gt; test with &lt;tt class="docutils literal"&gt;Py_IS_TYPE(obj, type)&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="enforce-py-set-type"&gt;
&lt;h2&gt;Enforce Py_SET_TYPE()&lt;/h2&gt;
&lt;p&gt;In Python 3.10, I converted Py_REFCNT(), Py_TYPE() and Py_SIZE() macros to
static inline functions, so &lt;tt class="docutils literal"&gt;Py_TYPE(obj) = new_type&lt;/tt&gt; becomes a compiler
error.&lt;/p&gt;
&lt;p&gt;Static inline functions still access directly &lt;tt class="docutils literal"&gt;PyObject&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;PyVarObject&lt;/tt&gt;
members at the ABI level, and so don't solve the initial goal: &amp;quot;make the
PyObject structure opaque&amp;quot;. Not accessing members at the ABI level can have a
negative impact on performance and I prefer to address it later. I already get
enough backfire with the other C API changes that I made :-)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="broken-c-extensions-first-revert"&gt;
&lt;h2&gt;Broken C extensions (first revert)&lt;/h2&gt;
&lt;p&gt;Converting Py_TYPE() and Py_SIZE() macros to static inline functions broke 16 C
extensions:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;Cython&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;PyPAM&lt;/li&gt;
&lt;li&gt;bitarray&lt;/li&gt;
&lt;li&gt;boost&lt;/li&gt;
&lt;li&gt;breezy&lt;/li&gt;
&lt;li&gt;duplicity&lt;/li&gt;
&lt;li&gt;gobject-introspection&lt;/li&gt;
&lt;li&gt;immutables&lt;/li&gt;
&lt;li&gt;mercurial&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;numpy&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;pybluez&lt;/li&gt;
&lt;li&gt;pycurl&lt;/li&gt;
&lt;li&gt;pygobject3&lt;/li&gt;
&lt;li&gt;pylibacl&lt;/li&gt;
&lt;li&gt;pyside2&lt;/li&gt;
&lt;li&gt;rdiff-backup&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In November 2020, during the Python 3.10 devcycle, I preferred to revert
Py_TYPE() and Py_SIZE() changes.&lt;/p&gt;
&lt;p&gt;I kept the Py_REFCNT() change since it only broke a single C extension
(PySide2) and it was simple to update it to Py_SET_REFCNT().&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pythoncapi-compat"&gt;
&lt;h2&gt;pythoncapi_compat&lt;/h2&gt;
&lt;p&gt;I created the &lt;a class="reference external" href="https://github.com/pythoncapi/pythoncapi_compat"&gt;pythoncapi_compat&lt;/a&gt; project to provide the
following functions to Python 3.8 and older:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_SET_REFCNT()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_SET_TYPE()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_SET_SIZE()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_IS_TYPE()&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I also wrote a upgrade_pythoncapi.py script to upgrade C extensions to use
these functions, without losing support for Python 3.8 and older.&lt;/p&gt;
&lt;p&gt;Using the pythoncapi_compat project, I succeeded to update multiple C
extensions to prepare them for Py_TYPE() becoming a static inline function.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="test-exceptions-crash-second-revert"&gt;
&lt;h2&gt;test_exceptions crash (second revert)&lt;/h2&gt;
&lt;p&gt;In June 2021, during the Python 3.11 devcycle, I changed again Py_TYPE() and
Py_SIZE() since &lt;a class="reference external" href="https://bugs.python.org/issue39573#msg401378"&gt;most C extensions have been fixed in the meanwhile&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Problem: &lt;tt class="docutils literal"&gt;test_recursion_in_except_handler()&lt;/tt&gt; of &lt;tt class="docutils literal"&gt;test_exceptions&lt;/tt&gt; started
to crash on a Python debug build on Windows: see &lt;a class="reference external" href="https://bugs.python.org/issue44348"&gt;bpo-44348&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Since nobody understood the issue, it was decided to revert my change again to
repair buildbots.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="fix-baseexception-deallocator"&gt;
&lt;h2&gt;Fix BaseException deallocator&lt;/h2&gt;
&lt;p&gt;In September 2021, I looked at the test_exceptions crash. In a &lt;strong&gt;debug build&lt;/strong&gt;,
the MSC compiler &lt;strong&gt;doesn't inline&lt;/strong&gt; calls to static inline functions. Because
of that, converting Py_TYPE() macro to a static inline functions &lt;strong&gt;increases
the stack memory usage&lt;/strong&gt; on a Python debug build on Windows.&lt;/p&gt;
&lt;p&gt;I proposed to enable compiler optimizations when building Python in debug mode
on Windows, to inline calls to static inline functions like Py_TYPE(). This
idea was rejected, since the debug build must remain fully usable in a
debugger.&lt;/p&gt;
&lt;p&gt;I looked again at the crash and found the root issue.
test_recursion_in_except_handler() creates chained of exceptions. When an
exception is deallocated, it calls the deallocator of another exception, etc.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;recurse_in_except() sub-test creates chains of 11 nested deallocator calls&lt;/li&gt;
&lt;li&gt;recurse_in_body_and_except() sub-test creates a chain of &lt;strong&gt;8192 nested deallocator calls&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I proposed a change to use the &lt;strong&gt;trashcan mechanism&lt;/strong&gt;. It limits the call stack to
50 function calls. I checked with a benchmark that the performance overhead is
acceptable. My change fixed the test_exceptions crash!&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="close-the-pyobject-issue"&gt;
&lt;h2&gt;Close the PyObject issue&lt;/h2&gt;
&lt;p&gt;Since most C extensions have been fixed and test_exceptions is fixed, I was
able to change Py_TYPE() and Py_SIZE() for the third time. My final commit:
&lt;a class="reference external" href="https://github.com/python/cpython/commit/cb15afcccffc6c42cbfb7456ce8db89cd2f77512"&gt;Py_TYPE becomes a static inline function&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I changed the issue topic to restrict it to adding functions to access PyObject
members. Previously, the goal was to make the PyObject structure opaque.
It took 1 year and a half to add made all these changes.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="what-s-next-to-make-pyobject-opaque"&gt;
&lt;h2&gt;What's Next to Make PyObject opaque?&lt;/h2&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;PyObject&lt;/tt&gt; structure is used to define structurres of all Python types,
like &lt;tt class="docutils literal"&gt;PyListObject&lt;/tt&gt;. All structures start with &lt;tt class="docutils literal"&gt;PyObject ob_base;&lt;/tt&gt; and so
the compiler must have access to the &lt;tt class="docutils literal"&gt;PyObject&lt;/tt&gt; structure.&lt;/p&gt;
&lt;p&gt;Moreover, &lt;tt class="docutils literal"&gt;PyType_FromSpec()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;PyType_Spec&lt;/tt&gt; API use indirectly
&lt;tt class="docutils literal"&gt;sizeof(PyObject)&lt;/tt&gt; in the &lt;tt class="docutils literal"&gt;PyType_Spec.basicsize&lt;/tt&gt; member when defining a
type.&lt;/p&gt;
&lt;p&gt;One option to make the &lt;tt class="docutils literal"&gt;PyObject&lt;/tt&gt; structure opaque would be to modify the
&lt;tt class="docutils literal"&gt;PyObject&lt;/tt&gt; structure to make it empty, and move its members into a new
private &lt;tt class="docutils literal"&gt;_PyObject&lt;/tt&gt; structure. This &lt;tt class="docutils literal"&gt;_PyObject&lt;/tt&gt; structure would be
allocated before the &lt;tt class="docutils literal"&gt;PyObject*&lt;/tt&gt; pointer, same idea as the current
&lt;tt class="docutils literal"&gt;PyGC_Head&lt;/tt&gt; header which is also allocated before the &lt;tt class="docutils literal"&gt;PyObject*&lt;/tt&gt; pointer.&lt;/p&gt;
&lt;p&gt;These changes are more complex than what I expected and so I prefer to open a
new issue later to propose these changes. Also, the performance of these
changes must be checked with benchmarks, to ensure that there is no performance
overhead or that the overhead is acceptable.&lt;/p&gt;
&lt;/div&gt;
</content><category term="cpython"></category><category term="c-api"></category><category term="cpython"></category></entry><entry><title>C API changes between Python 3.5 to 3.10</title><link href="https://vstinner.github.io/c-api-python3_10-changes.html" rel="alternate"></link><published>2021-10-04T15:00:00+02:00</published><updated>2021-10-04T15:00:00+02:00</updated><author><name>Victor Stinner</name></author><id>tag:vstinner.github.io,2021-10-04:/c-api-python3_10-changes.html</id><summary type="html">&lt;img alt="Homer Simpson hiding" src="https://vstinner.github.io/images/homer_hiding.webp" /&gt;
&lt;p&gt;I'm trying to enhance and to fix the Python C API for 5 years. My first goal
was to shrink the C API without breaking third party C extensions. I hid many
private functions from the public functions: I moved them to the &amp;quot;internal C
API&amp;quot;. I also deprecated and …&lt;/p&gt;</summary><content type="html">&lt;img alt="Homer Simpson hiding" src="https://vstinner.github.io/images/homer_hiding.webp" /&gt;
&lt;p&gt;I'm trying to enhance and to fix the Python C API for 5 years. My first goal
was to shrink the C API without breaking third party C extensions. I hid many
private functions from the public functions: I moved them to the &amp;quot;internal C
API&amp;quot;. I also deprecated and removed many functions.&lt;/p&gt;
&lt;p&gt;Between Python 3.5 and 3.10, 80 symbols have been removed. Python 3.10 is the
first Python version exporting less symbols than its previous version!&lt;/p&gt;
&lt;p&gt;Since Python 3.8, the C API is organized as 3 parts:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Include/&lt;/tt&gt; directory: Limited API&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Include/cpython/&lt;/tt&gt; directory: CPython implementation details&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Include/internal/&lt;/tt&gt; directory: The internal API&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The devguide &lt;a class="reference external" href="https://devguide.python.org/c-api/"&gt;Changing Python’s C API&lt;/a&gt;
documentation now gives guidelines for C API additions, like avoiding borrowed
references.&lt;/p&gt;
&lt;p&gt;The limited C API got a few more functions, whereas broken and private
functions have been removed. The Stable ABI is now explicitly defined and
documented in the &lt;a class="reference external" href="https://docs.python.org/dev/c-api/stable.html#stable"&gt;C API Stability&lt;/a&gt; page.&lt;/p&gt;
&lt;p&gt;This article lists all C API changes, not only the ones done by me.&lt;/p&gt;
&lt;div class="section" id="shrink-the-the-c-api"&gt;
&lt;h2&gt;Shrink the the C API&lt;/h2&gt;
&lt;p&gt;Between Python 3.5 and 3.10, 80 symbols (functions or variables) have been
removed, 3 structures have been removed, and 21 functions have been deprecated.
In meanwhile, other symbols have been added to implement new Python features at
each Python version.&lt;/p&gt;
&lt;p&gt;Python 3.10 is the first Python version exporting less symbols than its
previous version.&lt;/p&gt;
&lt;div class="section" id="python-3-6"&gt;
&lt;h3&gt;Python 3.6&lt;/h3&gt;
&lt;p&gt;Deprecate 4 functions:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_AsDecodedObject()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_AsDecodedUnicode()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_AsEncodedObject()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_AsEncodedUnicode()&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="python-3-7"&gt;
&lt;h3&gt;Python 3.7&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Deprecate &lt;tt class="docutils literal"&gt;PyOS_AfterFork()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;Remove &lt;tt class="docutils literal"&gt;PyExc_RecursionErrorInst&lt;/tt&gt; singleton (also removed in Python 3.6.4).&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="python-3-8"&gt;
&lt;h3&gt;Python 3.8&lt;/h3&gt;
&lt;p&gt;Remove 3 functions:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyByteArray_Init()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyByteArray_Fini()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyEval_ReInitThreads()&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Remove 1 structure:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyInterpreterState&lt;/tt&gt; (moved to the internal C API)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="python-3-9"&gt;
&lt;h3&gt;Python 3.9&lt;/h3&gt;
&lt;p&gt;Remove 32 symbols:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyAsyncGen_ClearFreeLists()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyCFunction_ClearFreeList()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyCmpWrapper_Type&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyContext_ClearFreeList()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyDict_ClearFreeList()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyFloat_ClearFreeList()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyFrame_ClearFreeList()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyFrame_ExtendStack()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyList_ClearFreeList()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyMethod_ClearFreeList()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyNoArgsFunction type&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyNullImporter_Type&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PySet_ClearFreeList()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PySortWrapper_Type&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyTuple_ClearFreeList()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_ClearFreeList()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_UNICODE_MATCH()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyAIterWrapper_Type&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyBytes_InsertThousandsGrouping()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyBytes_InsertThousandsGroupingLocale()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyDebug_PrintTotalRefs()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyFloat_Digits()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyFloat_DigitsInit()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyFloat_Repr()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyThreadState_GetFrame()&lt;/tt&gt; (and &lt;tt class="docutils literal"&gt;_PyRuntime.getframe&lt;/tt&gt;)&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyUnicode_ClearStaticStrings()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_Py_AddToAllObjects()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_Py_InitializeFromArgs()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_Py_InitializeFromWideArgs()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_Py_PrintReferenceAddresses()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_Py_PrintReferences()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_Py_tracemalloc_config&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Remove 1 structure:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyGC_Head&lt;/tt&gt; (moved to the internal C API)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Deprecate 15 functions:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyEval_CallFunction()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyEval_CallMethod()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyEval_CallObject()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyEval_CallObjectWithKeywords()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyNode_Compile()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyParser_SimpleParseFileFlags()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyParser_SimpleParseStringFlags()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyParser_SimpleParseStringFlagsFilename()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_AsUnicode()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_AsUnicodeAndSize()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_FromUnicode()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_WSTR_LENGTH()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_UNICODE_COPY()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_UNICODE_FILL()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyUnicode_AsUnicode()&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="python-3-10"&gt;
&lt;h3&gt;Python 3.10&lt;/h3&gt;
&lt;p&gt;Remove 44 symbols:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyAST_Compile()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyAST_CompileEx()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyAST_CompileObject()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyAST_Validate()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyArena_AddPyObject()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyArena_Free()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyArena_Malloc()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyArena_New()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyFuture_FromAST()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyFuture_FromASTObject()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyLong_FromUnicode()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyNode_Compile()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyOS_InitInterrupts()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyObject_AsCharBuffer()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyObject_AsReadBuffer()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyObject_AsWriteBuffer()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyObject_CheckReadBuffer()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyParser_ASTFromFile()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyParser_ASTFromFileObject()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyParser_ASTFromFilename()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyParser_ASTFromString()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyParser_ASTFromStringObject()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyParser_SimpleParseFileFlags()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyParser_SimpleParseStringFlags()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyParser_SimpleParseStringFlagsFilename()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyST_GetScope()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PySymtable_Build()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PySymtable_BuildObject()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PySymtable_Free()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_AsUnicodeCopy()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_GetMax()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_ALLOW_RECURSION&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_END_ALLOW_RECURSION&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_SymtableString()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_SymtableStringObject()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_UNICODE_strcat()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_UNICODE_strchr()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_UNICODE_strcmp()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_UNICODE_strcpy()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_UNICODE_strlen()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_UNICODE_strncmp()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_UNICODE_strncpy()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_UNICODE_strrchr()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_Py_CheckRecursionLimit&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Remove 1 structure:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyUnicode_Name_CAPI&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Deprecate 1 function:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_InternImmortal()&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Moreover, &lt;tt class="docutils literal"&gt;PyUnicode_FromStringAndSize(NULL, size)&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;PyUnicode_FromUnicode(NULL, size)&lt;/tt&gt; have been deprecated.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="statistics"&gt;
&lt;h3&gt;Statistics&lt;/h3&gt;
&lt;p&gt;Public Python symbols exported with &lt;tt class="docutils literal"&gt;PyAPI_FUNC()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;PyAPI_DATA()&lt;/tt&gt;:&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="39%" /&gt;
&lt;col width="61%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;Python&lt;/th&gt;
&lt;th class="head"&gt;Symbols&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;2.7&lt;/td&gt;
&lt;td&gt;891&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;3.6&lt;/td&gt;
&lt;td&gt;1041 (+150)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;3.7&lt;/td&gt;
&lt;td&gt;1068 (+27)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;3.8&lt;/td&gt;
&lt;td&gt;1105 (+37)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;3.9&lt;/td&gt;
&lt;td&gt;1115 (+10)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;3.10&lt;/td&gt;
&lt;td&gt;1080 (-35)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Command used to count public symbols:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
grep -E 'PyAPI_(FUNC|DATA)' Include/*.h Include/cpython/*.h|grep -v ' _Py'|wc -l
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="reorganize-header-files"&gt;
&lt;h2&gt;Reorganize header files&lt;/h2&gt;
&lt;p&gt;Since Python 3.8, the C API is organized as 3 parts:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Include/&lt;/tt&gt; directory: Limited API&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Include/cpython/&lt;/tt&gt; directory: CPython implementation details&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Include/internal/&lt;/tt&gt; directory: The internal API&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The intent is to help developers to think about if their additions must be part
of the limited C API, the CPython C API or the internal C API.&lt;/p&gt;
&lt;div class="section" id="python-3-7-1"&gt;
&lt;h3&gt;Python 3.7&lt;/h3&gt;
&lt;p&gt;Creation on the &lt;tt class="docutils literal"&gt;Include/internal/&lt;/tt&gt; directory.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="python-3-8-1"&gt;
&lt;h3&gt;Python 3.8&lt;/h3&gt;
&lt;p&gt;Creation on the &lt;tt class="docutils literal"&gt;Include/cpython/&lt;/tt&gt; directory.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="python-3-10-1"&gt;
&lt;h3&gt;Python 3.10&lt;/h3&gt;
&lt;p&gt;Move 8 header files from &lt;tt class="docutils literal"&gt;Include/&lt;/tt&gt; to &lt;tt class="docutils literal"&gt;Include/cpython/&lt;/tt&gt;:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;odictobject.h&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;parser_interface.h&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;picklebufobject.h&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;pyarena.h&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;pyctype.h&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;pydebug.h&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;pyfpe.h&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;pytime.h&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Python 3.10 added a &lt;a class="reference external" href="https://github.com/python/cpython/blob/master/Include/README.rst"&gt;Include/README.rst documentation&lt;/a&gt; to explain
this organization and give guidelines for adding new functions. For example,
new functions in the public C API must not steal references nor return borrowed
references. In the meanwhile, this documentation moved to the devguide:
&lt;a class="reference external" href="https://devguide.python.org/c-api/"&gt;Changing Python’s C API&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="statistics-1"&gt;
&lt;h3&gt;Statistics&lt;/h3&gt;
&lt;p&gt;Number of C API line numbers per Python version:&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="14%" /&gt;
&lt;col width="27%" /&gt;
&lt;col width="22%" /&gt;
&lt;col width="24%" /&gt;
&lt;col width="14%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;Python&lt;/th&gt;
&lt;th class="head"&gt;Limited API&lt;/th&gt;
&lt;th class="head"&gt;CPython API&lt;/th&gt;
&lt;th class="head"&gt;Internal API&lt;/th&gt;
&lt;th class="head"&gt;Total&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;2.7&lt;/td&gt;
&lt;td&gt;12,686 (100%)&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;12,686&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;3.6&lt;/td&gt;
&lt;td&gt;16,011 (100%)&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;16,011&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;3.7&lt;/td&gt;
&lt;td&gt;16,517 (96%)&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;705 (4%)&lt;/td&gt;
&lt;td&gt;17,222&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;3.8&lt;/td&gt;
&lt;td&gt;13,160 (70%)&lt;/td&gt;
&lt;td&gt;3,417 (18%)&lt;/td&gt;
&lt;td&gt;2,230 (12%)&lt;/td&gt;
&lt;td&gt;18,807&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;3.9&lt;/td&gt;
&lt;td&gt;12,264 (62%)&lt;/td&gt;
&lt;td&gt;4,343 (22%)&lt;/td&gt;
&lt;td&gt;3,066 (16%)&lt;/td&gt;
&lt;td&gt;19,673&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;3.10&lt;/td&gt;
&lt;td&gt;10,305 (52%)&lt;/td&gt;
&lt;td&gt;4,513 (23%)&lt;/td&gt;
&lt;td&gt;5,092 (26%)&lt;/td&gt;
&lt;td&gt;19,910&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Commands:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Limited: &lt;tt class="docutils literal"&gt;wc &lt;span class="pre"&gt;-l&lt;/span&gt; &lt;span class="pre"&gt;Include/*.h&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;CPython: &lt;tt class="docutils literal"&gt;wc &lt;span class="pre"&gt;-l&lt;/span&gt; &lt;span class="pre"&gt;Include/cpython/*.h&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;Internal: &lt;tt class="docutils literal"&gt;wc &lt;span class="pre"&gt;-l&lt;/span&gt; &lt;span class="pre"&gt;Include/internal/*.h&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="changes-in-the-limited-c-api"&gt;
&lt;h2&gt;Changes in the Limited C API&lt;/h2&gt;
&lt;p&gt;Between Python 3.8 and 3.10, 4 new functions have been and 14 symbols
(functions or variables) have been removed from the limited C API.&lt;/p&gt;
&lt;p&gt;The trashcan API was excluded from the limited C API since it never worked.
The implementation accessed directly PyThreadState members, whereas this
structure is opaque in the limited C API.&lt;/p&gt;
&lt;p&gt;On the other side, Py_EnterRecursiveCall() and Py_LeaveRecursiveCall()
functions have been added to the limited C API. In Python 3.8, they were
defined as macros accessing directly PyThreadState members. In Python 3.9, they
became opaque function calls and so are now compatible with the stable ABI.&lt;/p&gt;
&lt;div class="section" id="python-3-9-1"&gt;
&lt;h3&gt;Python 3.9&lt;/h3&gt;
&lt;p&gt;Add 3 functions to the limited C API:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_EnterRecursiveCall()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_LeaveRecursiveCall()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyFrame_GetLineNumber()&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Remove 14 symbols from the limited C API:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyFPE_START_PROTECT()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyFPE_END_PROTECT()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyThreadState_DeleteCurrent()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyTrash_UNWIND_LEVEL&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_TRASHCAN_BEGIN&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_TRASHCAN_BEGIN_CONDITION&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_TRASHCAN_END&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_TRASHCAN_SAFE_BEGIN&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_TRASHCAN_SAFE_END&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_PyTraceMalloc_NewReference()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_Py_CheckRecursionLimit&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_Py_GetRefTotal()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_Py_NewReference()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_Py_ForgetReference()&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="python-3-10-2"&gt;
&lt;h3&gt;Python 3.10&lt;/h3&gt;
&lt;p&gt;Add 1 function to the limited C API:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PyUnicode_AsUTF8AndSize()&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="pep-652-maintaining-the-stable-abi"&gt;
&lt;h2&gt;PEP 652: Maintaining the Stable ABI&lt;/h2&gt;
&lt;p&gt;Petr Viktorin wrote and implemented the &lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0652/"&gt;PEP 652: Maintaining the Stable ABI&lt;/a&gt; in Python 3.10.&lt;/p&gt;
&lt;p&gt;The Stable ABI (Application Binary Interface) for extension modules or
embedding Python is now explicitly defined. The &lt;a class="reference external" href="https://docs.python.org/dev/c-api/stable.html#stable"&gt;C API Stability&lt;/a&gt; documentation
describes C API and ABI stability guarantees along with best practices for
using the Stable ABI.&lt;/p&gt;
&lt;/div&gt;
</content><category term="cpython"></category><category term="c-api"></category><category term="cpython"></category></entry><entry><title>Creation of the pythoncapi_compat project</title><link href="https://vstinner.github.io/pythoncapi_compat.html" rel="alternate"></link><published>2021-03-30T20:00:00+02:00</published><updated>2021-03-30T20:00:00+02:00</updated><author><name>Victor Stinner</name></author><id>tag:vstinner.github.io,2021-03-30:/pythoncapi_compat.html</id><summary type="html">&lt;a class="reference external image-reference" href="https://twitter.com/Kekeflipnote/status/1378034391872638980"&gt;&lt;img alt="Strange Cat by Kéké" src="https://vstinner.github.io/images/strange_cat.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;In 2020, I created a new &lt;a class="reference external" href="https://github.com/pythoncapi/pythoncapi_compat"&gt;pythoncapi_compat project&lt;/a&gt; to add Python 3.10 support
to C extensions without losing support for old Python versions. It supports
Python 2.7-3.10 and PyPy 2.7-3.7. The project is made of two parts:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;pythoncapi_compat.h&lt;/tt&gt;: Header file providing new C API …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;a class="reference external image-reference" href="https://twitter.com/Kekeflipnote/status/1378034391872638980"&gt;&lt;img alt="Strange Cat by Kéké" src="https://vstinner.github.io/images/strange_cat.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;In 2020, I created a new &lt;a class="reference external" href="https://github.com/pythoncapi/pythoncapi_compat"&gt;pythoncapi_compat project&lt;/a&gt; to add Python 3.10 support
to C extensions without losing support for old Python versions. It supports
Python 2.7-3.10 and PyPy 2.7-3.7. The project is made of two parts:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;pythoncapi_compat.h&lt;/tt&gt;: Header file providing new C API functions to old
Python versions, like &lt;tt class="docutils literal"&gt;Py_SET_TYPE()&lt;/tt&gt;.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;upgrade_pythoncapi.py&lt;/tt&gt;: Script upgrading C extension modules using
&lt;tt class="docutils literal"&gt;pythoncapi_compat.h&lt;/tt&gt;. For example, it replaces &lt;tt class="docutils literal"&gt;Py_TYPE(obj) = type;&lt;/tt&gt;
with &lt;tt class="docutils literal"&gt;Py_SET_TYPE(obj, type);&lt;/tt&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This article is about the creation of the header file and the upgrade script.&lt;/p&gt;
&lt;p&gt;Photo: Strange cats 🐾 by Kéké.&lt;/p&gt;
&lt;div class="section" id="py-set-type-macro-for-python-3-8-and-older"&gt;
&lt;h2&gt;Py_SET_TYPE() macro for Python 3.8 and older&lt;/h2&gt;
&lt;div class="section" id="py-type-macro-converted-to-a-static-inline-function"&gt;
&lt;h3&gt;Py_TYPE() macro converted to a static inline function&lt;/h3&gt;
&lt;p&gt;In May 2020 in the &lt;a class="reference external" href="https://bugs.python.org/issue39573"&gt;bpo-39573 &amp;quot;Make PyObject an opaque structure&amp;quot;&lt;/a&gt;, &lt;a class="reference external" href="https://github.com/python/cpython/commit/ad3252bad905d41635bcbb4b76db30d570cf0087"&gt;Py_TYPE()&lt;/a&gt;
(change by Dong-hee Na), &lt;a class="reference external" href="https://github.com/python/cpython/commit/fe2978b3b940fe2478335e3a2ca5ad22338cdf9c"&gt;Py_REFCNT() and Py_SIZE()&lt;/a&gt;
(change by me) macros were converted to static inline functions. This change
broke 17 C extension modules (see my previous article &lt;a class="reference external" href="https://vstinner.github.io/c-api-opaque-structures.html"&gt;Make structures opaque
in the Python C API&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;I prepared this change in Python 3.9 by adding Py_SET_REFCNT(), Py_SET_TYPE()
and Py_SET_SIZE() functions, and by modifying Python to use these functions. I
also &lt;a class="reference external" href="https://github.com/python/cpython/commit/d905df766c367c350f20c46ccd99d4da19ed57d8"&gt;added Py_IS_TYPE() function&lt;/a&gt;
which tests the type of an object:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static inline int _Py_IS_TYPE(PyObject *ob, PyTypeObject *type) {
    return ob-&amp;gt;ob_type == type;
}
#define Py_IS_TYPE(ob, type) _Py_IS_TYPE(_PyObject_CAST(ob), type)
&lt;/pre&gt;
&lt;p&gt;For example, &lt;tt class="docutils literal"&gt;Py_TYPE(ob) == (tp)&lt;/tt&gt; can be replaced with &lt;tt class="docutils literal"&gt;Py_IS_TYPE(ob, tp)&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="cython-and-numpy-fixes"&gt;
&lt;h3&gt;Cython and numpy fixes&lt;/h3&gt;
&lt;p&gt;I fixed Cython by &lt;a class="reference external" href="https://github.com/cython/cython/commit/d8e93b332fe7d15459433ea74cd29178c03186bd"&gt;adding __Pyx_SET_REFCNT() and __Pyx_SET_SIZE() macros&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#if PY_VERSION_HEX &amp;gt;= 0x030900A4
  #define __Pyx_SET_REFCNT(obj, refcnt) Py_SET_REFCNT(obj, refcnt)
  #define __Pyx_SET_SIZE(obj, size) Py_SET_SIZE(obj, size)
#else
  #define __Pyx_SET_REFCNT(obj, refcnt) Py_REFCNT(obj) = (refcnt)
  #define __Pyx_SET_SIZE(obj, size) Py_SIZE(obj) = (size)
#endif
&lt;/pre&gt;
&lt;p&gt;The &lt;a class="reference external" href="https://github.com/numpy/numpy/commit/a96b18e3d4d11be31a321999cda4b795ea9eccaa"&gt;numpy fix&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#if PY_VERSION_HEX &amp;lt; 0x030900a4
    #define Py_SET_TYPE(obj, typ) (Py_TYPE(obj) = typ)
    #define Py_SET_SIZE(obj, size) (Py_SIZE(obj) = size)
#endif
&lt;/pre&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/numpy/numpy/commit/f1671076c80bd972421751f2d48186ee9ac808aa"&gt;The numpy fix was updated&lt;/a&gt;
to not have a return value by adding &lt;tt class="docutils literal"&gt;&amp;quot;, (void)0&amp;quot;&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#if PY_VERSION_HEX &amp;lt; 0x030900a4
    #define Py_SET_TYPE(obj, type) ((Py_TYPE(obj) = (type)), (void)0)
    #define Py_SET_SIZE(obj, size) ((Py_SIZE(obj) = (size)), (void)0)
#endif
&lt;/pre&gt;
&lt;p&gt;So the macros better mimicks the static inline functions behavior.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="c-api-porting-guide"&gt;
&lt;h3&gt;C API Porting Guide&lt;/h3&gt;
&lt;p&gt;I copied the numpy macros &lt;a class="reference external" href="https://github.com/python/cpython/commit/dc24b8a2ac32114313bae519db3ccc21fe45c982"&gt;to the C API section of the Python 3.10 porting
guide (What's New in Python 3.10)&lt;/a&gt;.
Py_SET_TYPE() documentation.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Since &lt;tt class="docutils literal"&gt;Py_TYPE()&lt;/tt&gt; is changed to the inline static function,
&lt;tt class="docutils literal"&gt;Py_TYPE(obj) = new_type&lt;/tt&gt; must be replaced with
&lt;tt class="docutils literal"&gt;Py_SET_TYPE(obj, new_type)&lt;/tt&gt;: see &lt;tt class="docutils literal"&gt;Py_SET_TYPE()&lt;/tt&gt; (available since
Python 3.9). For backward compatibility, this macro can be used:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#if PY_VERSION_HEX &amp;lt; 0x030900A4
#  define Py_SET_TYPE(obj, type) ((Py_TYPE(obj) = (type)), (void)0)
#endif
&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="copy-paste-macros"&gt;
&lt;h3&gt;Copy/paste macros&lt;/h3&gt;
&lt;p&gt;Up to 3 macros must be copied/pasted for backward compatibility in each
project:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#if PY_VERSION_HEX &amp;lt; 0x030900A4
#  define Py_SET_TYPE(obj, type) ((Py_TYPE(obj) = (type)), (void)0)
#endif

#if PY_VERSION_HEX &amp;lt; 0x030900A4
#  define Py_SET_REFCNT(obj, refcnt) ((Py_REFCNT(obj) = (refcnt)), (void)0)
#endif

#if PY_VERSION_HEX &amp;lt; 0x030900A4
#  define Py_SET_SIZE(obj, size) ((Py_SIZE(obj) = (size)), (void)0)
#endif
&lt;/pre&gt;
&lt;p&gt;These macros started to be copied into multiple projects. Examples:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://bazaar.launchpad.net/~brz/brz/3.1/revision/7647"&gt;breezy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/numpy/numpy/commit/f1671076c80bd972421751f2d48186ee9ac808aa"&gt;numpy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/pycurl/pycurl/commit/e633f9a1ac4df5e249e78c218d5fbbd848219042"&gt;pycurl&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There might be a better way than copying/pasting these compatibility layer in
each project, adding macros one by one...&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="creation-of-the-pythoncapi-compat-h-header-file"&gt;
&lt;h2&gt;Creation of the pythoncapi_compat.h header file&lt;/h2&gt;
&lt;p&gt;While the code for Py_SET_REFCNT(), Py_SET_TYPE() and Py_SET_SIZE() macros is
short, I also wanted to use the new seven Python 3.9 getter functions on Python
3.8 and older:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Py_IS_TYPE()&lt;/li&gt;
&lt;li&gt;PyFrame_GetBack()&lt;/li&gt;
&lt;li&gt;PyFrame_GetCode()&lt;/li&gt;
&lt;li&gt;PyInterpreterState_Get()&lt;/li&gt;
&lt;li&gt;PyThreadState_GetFrame()&lt;/li&gt;
&lt;li&gt;PyThreadState_GetID()&lt;/li&gt;
&lt;li&gt;PyThreadState_GetInterpreter()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In June 2020, I created &lt;a class="reference external" href="https://github.com/pythoncapi/pythoncapi_compat"&gt;the pythoncapi_compat project&lt;/a&gt; project with a
&lt;a class="reference external" href="https://github.com/pythoncapi/pythoncapi_compat/blob/main/pythoncapi_compat.h"&gt;pythoncapi_compat.h header file&lt;/a&gt;
which defines these functions as static inline functions. An
&lt;tt class="docutils literal"&gt;&amp;quot;#if PY_VERSION_HEX&amp;quot;&lt;/tt&gt; guard prevents to define a function if it's already
provided by &lt;tt class="docutils literal"&gt;Python.h&lt;/tt&gt;. Example of the current implementation of
PyThreadState_GetInterpreter() for Python 3.8 and older:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
// bpo-39947 added PyThreadState_GetInterpreter() to Python 3.9.0a5
#if PY_VERSION_HEX &amp;lt; 0x030900A5
static inline PyInterpreterState *
PyThreadState_GetInterpreter(PyThreadState *tstate)
{
    assert(tstate != NULL);
    return tstate-&amp;gt;interp;
}
#endif
&lt;/pre&gt;
&lt;p&gt;I wrote tests on each function using a C extension. The project initially
supported Python 3.6 to Python 3.10. The test runner checks also for reference
leaks.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="mercurial-and-python-2-7"&gt;
&lt;h2&gt;Mercurial and Python 2.7&lt;/h2&gt;
&lt;p&gt;The Mercurial project has multiple C extensions, was broken on Python 3.10 by
the Py_TYPE() change, and is one of the last project still requiring Python 2.7
in 2021. It's a good candidate to check if pythoncapi_compat.h is useful.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://bz.mercurial-scm.org/show_bug.cgi?id=6451"&gt;I proposed a patch&lt;/a&gt; then
&lt;a class="reference external" href="https://foss.heptapod.net/octobus/mercurial-devel/-/merge_requests/61"&gt;converted to a merge request&lt;/a&gt;. It
got accepted in the &amp;quot;next&amp;quot; branch, but compatibility with Visual Studio 2008
had to be fixed for Python 2.7 on Windows. I fixed pythoncapi_compat.h by
defining &lt;tt class="docutils literal"&gt;inline&lt;/tt&gt; as &lt;tt class="docutils literal"&gt;__inline&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
// Compatibility with Visual Studio 2013 and older which don't support
// the inline keyword in C (only in C++): use __inline instead.
#if (defined(_MSC_VER) &amp;amp;&amp;amp; _MSC_VER &amp;lt; 1900 \
     &amp;amp;&amp;amp; !defined(__cplusplus) &amp;amp;&amp;amp; !defined(inline))
#  define inline __inline
#  define PYTHONCAPI_COMPAT_MSC_INLINE
   // These two macros are undefined at the end of this file
#endif

(...)

#ifdef PYTHONCAPI_COMPAT_MSC_INLINE
#  undef inline
#  undef PYTHONCAPI_COMPAT_MSC_INLINE
#endif
&lt;/pre&gt;
&lt;p&gt;I chose to continue writing &lt;tt class="docutils literal"&gt;static inline&lt;/tt&gt;, so pythoncapi_compat.h remains
close to Python header files. I also modified the pythoncapi_compat test suite
to also test Python 2.7.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pybind11-and-pypy"&gt;
&lt;h2&gt;pybind11 and PyPy&lt;/h2&gt;
&lt;p&gt;More recently, I added PyPy 2.7, 3.6 and 3.7 support for pybind11, since PyPy
is tested by their CI. The fix is to no longer define the following functions
on PyPy:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;PyFrame_GetBack(), _PyFrame_GetBackBorrow()&lt;/li&gt;
&lt;li&gt;PyThreadState_GetFrame(), _PyThreadState_GetFrameBorrow()&lt;/li&gt;
&lt;li&gt;PyThreadState_GetID()&lt;/li&gt;
&lt;li&gt;PyObject_GC_IsTracked()&lt;/li&gt;
&lt;li&gt;PyObject_GC_IsFinalized()&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="creation-of-the-upgrade-pythoncapi-py-script"&gt;
&lt;h2&gt;Creation of the upgrade_pythoncapi.py script&lt;/h2&gt;
&lt;div class="section" id="upgrade-pythoncapi-py"&gt;
&lt;h3&gt;upgrade_pythoncapi.py&lt;/h3&gt;
&lt;p&gt;In November 2020, I created a new &lt;tt class="docutils literal"&gt;upgrade_pythoncapi.py&lt;/tt&gt; script to replace
&lt;tt class="docutils literal"&gt;&amp;quot;Py_TYPE(obj) = type;&amp;quot;&lt;/tt&gt; with &lt;tt class="docutils literal"&gt;&amp;quot;Py_SET_TYPE(obj, &lt;span class="pre"&gt;type);&amp;quot;&lt;/span&gt;&lt;/tt&gt;. The script is
based on my &lt;a class="reference external" href="https://github.com/vstinner/sixer"&gt;old sixer.py project&lt;/a&gt; which
adds Python 3 support to a Python project without losing Python 2 support. The
&lt;tt class="docutils literal"&gt;upgrade_pythoncapi.py&lt;/tt&gt; script uses regular expressions to replace one
pattern with another.&lt;/p&gt;
&lt;p&gt;Similar to &lt;tt class="docutils literal"&gt;sixer&lt;/tt&gt; which adds &lt;tt class="docutils literal"&gt;import six&lt;/tt&gt; to support Python 2 and Python 3
in a single code base, &lt;tt class="docutils literal"&gt;upgrade_pythoncapi.py&lt;/tt&gt; adds
&lt;tt class="docutils literal"&gt;#include &amp;quot;pythoncapi_compat.h&amp;quot;&lt;/tt&gt; to support old and new versions of the
Python C API in a single code base.&lt;/p&gt;
&lt;p&gt;I first created a new GitHub project for upgrade_pythoncapi.py, but since it
was too tightly coupled to the pythoncapi_compat.h header file, I moved the
script to the pythoncapi_compat project.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="tests"&gt;
&lt;h3&gt;Tests&lt;/h3&gt;
&lt;p&gt;I added more and more &amp;quot;operations&amp;quot; to update C extensions. For me, &lt;strong&gt;the most
important part is the test suite&lt;/strong&gt; to ensure that the script doesn't introduce
bugs. It contains code which must not be replaced. For example, it ensures that
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;frame-&amp;gt;f_code&lt;/span&gt; = code&lt;/tt&gt; is not replaced with &lt;tt class="docutils literal"&gt;_PyFrame_GetCodeBorrow(frame) =
code&lt;/tt&gt; by mistake.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="borrowed-references"&gt;
&lt;h3&gt;Borrowed references&lt;/h3&gt;
&lt;p&gt;Code accessing &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;frame-&amp;gt;f_code&lt;/span&gt;&lt;/tt&gt; directly must use &lt;tt class="docutils literal"&gt;PyFrame_GetCode()&lt;/tt&gt; but
this function returns a strong reference, whereas
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;frame-&amp;gt;f_code&lt;/span&gt;&lt;/tt&gt; gives a borrowed reference. I added &amp;quot;Borrow&amp;quot; variants of the
functions to &lt;tt class="docutils literal"&gt;pythoncapi_compat.h&lt;/tt&gt; for &lt;tt class="docutils literal"&gt;upgrade_pythoncapi.py&lt;/tt&gt;. For
example, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;frame-&amp;gt;f_code&lt;/span&gt;&lt;/tt&gt; is replaced with &lt;tt class="docutils literal"&gt;_PyFrame_GetCodeBorrow()&lt;/tt&gt; which
is defined as:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static inline PyCodeObject*
_PyFrame_GetCodeBorrow(PyFrameObject *frame)
{
    return (PyCodeObject *)_Py_StealRef(PyFrame_GetCode(frame));
}
&lt;/pre&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;_Py_StealRef(obj)&lt;/tt&gt; function converts a strong reference to a borrowed
reference (simplified code):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static inline PyObject* _Py_StealRef(PyObject *obj)
{
    Py_DECREF(obj);
    return obj;
}
&lt;/pre&gt;
&lt;p&gt;It is the opposite of &lt;tt class="docutils literal"&gt;Py_NewRef()&lt;/tt&gt;. It is similar to &lt;tt class="docutils literal"&gt;Py_DECREF(obj)&lt;/tt&gt; but
it can be used as an expression: it returns &lt;em&gt;obj&lt;/em&gt;.  pythoncapi_compat.h defines
private &lt;tt class="docutils literal"&gt;_Py_StealRef()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;_Py_XStealRef()&lt;/tt&gt; static inline functions.
First I proposed to add them to Python, but I abandoned the idea (see
&lt;a class="reference external" href="https://bugs.python.org/issue42522"&gt;bpo-42522&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Thanks to the &amp;quot;Borrow&amp;quot; suffix in function names, it becomes easier to discover
the usage of borrowed references. Using a borrowed reference is unsafe if it is
possible that the object is destroyed before the last usage of borrowed
reference. In case of doubt, it's better to use a strong reference. For
example, &lt;tt class="docutils literal"&gt;_PyFrame_GetCodeBorrow()&lt;/tt&gt; can be replaced with
&lt;tt class="docutils literal"&gt;PyFrame_GetCode()&lt;/tt&gt;, but it requires to explicitly delete the created strong
reference with &lt;tt class="docutils literal"&gt;Py_DECREF()&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="practical-solution-for-incompatible-c-api-changes"&gt;
&lt;h2&gt;Practical solution for incompatible C API changes&lt;/h2&gt;
&lt;p&gt;So far, I succeeded to convince 4 projects to use pythoncapi_compat.h:
bitarray, immutables, Mercurial and python-zstandard.&lt;/p&gt;
&lt;p&gt;In my opinion, pythoncapi_compat.h is the right approach to introduce
incompatible C API changes: provide a practical solution to support old and new
Python versions in a single code base.&lt;/p&gt;
&lt;p&gt;The next steps is to get it adopted more widely and get it endorsed by the
Python project, maybe by moving it under the PSF organization on GitHub.&lt;/p&gt;
&lt;/div&gt;
</content><category term="cpython"></category><category term="c-api"></category><category term="cpython"></category></entry><entry><title>Make structures opaque in the Python C API</title><link href="https://vstinner.github.io/c-api-opaque-structures.html" rel="alternate"></link><published>2021-03-26T12:00:00+01:00</published><updated>2021-03-26T12:00:00+01:00</updated><author><name>Victor Stinner</name></author><id>tag:vstinner.github.io,2021-03-26:/c-api-opaque-structures.html</id><summary type="html">&lt;a class="reference external image-reference" href="https://fr.wikipedia.org/wiki/Incendie_du_centre_de_donn%C3%A9es_d%27OVHcloud_%C3%A0_Strasbourg"&gt;&lt;img alt="OVHcloud datacenter fire in Strasbourg" src="https://vstinner.github.io/images/incendie-ovh.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;This article is about changes that I made, with the help other developers, in
the Python C API in Python 3.8, 3.9 and 3.10 to avoid accessing structures
members: prepare the C API to &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Opaque_data_type"&gt;make structures opaque&lt;/a&gt;. These changes are related
to my &lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0620/"&gt;PEP 620 &amp;quot;Hide implementation …&lt;/a&gt;&lt;/p&gt;</summary><content type="html">&lt;a class="reference external image-reference" href="https://fr.wikipedia.org/wiki/Incendie_du_centre_de_donn%C3%A9es_d%27OVHcloud_%C3%A0_Strasbourg"&gt;&lt;img alt="OVHcloud datacenter fire in Strasbourg" src="https://vstinner.github.io/images/incendie-ovh.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;This article is about changes that I made, with the help other developers, in
the Python C API in Python 3.8, 3.9 and 3.10 to avoid accessing structures
members: prepare the C API to &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Opaque_data_type"&gt;make structures opaque&lt;/a&gt;. These changes are related
to my &lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0620/"&gt;PEP 620 &amp;quot;Hide implementation details from the C API&amp;quot;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;One change had &lt;strong&gt;negative impact on performance&lt;/strong&gt; and had to be
reverted. Making Python slower just to make structures opaque would first
require to get the PEP 620 accepted.&lt;/p&gt;
&lt;p&gt;While compatible changes merged in Python 3.8 and Python 3.9 went fine, one
Python 3.10 &lt;strong&gt;incompatible change caused more troubles&lt;/strong&gt; and had to be
reverted.&lt;/p&gt;
&lt;p&gt;Photo: OVHcloud data center fire in Strasbourg.&lt;/p&gt;
&lt;div class="section" id="rationale"&gt;
&lt;h2&gt;Rationale&lt;/h2&gt;
&lt;p&gt;The C API currently exposes most object structures, C extensions indirectly
access structures members through the API, but can also access them directly.
It causes different issues:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Modifying a structure can break an unknown number of C extensions. To prevent
any risk, CPython core developers avoid modifying structures. Once most
structures will be opaque, it will be possible to experiment &lt;strong&gt;optimizations&lt;/strong&gt;
which require deep structures changes without breaking C extensions. The
irony is that we first have to break the backward compatibility and C
extensions for that.&lt;/li&gt;
&lt;li&gt;Any structure change breaks the ABI. The &lt;strong&gt;stable ABI&lt;/strong&gt; solved this issue by
not exposing structures into its limited C API. The idea is to bend the
default C API towards the limited C API to provide a stable ABI for everyone
in the long term.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="issues"&gt;
&lt;h2&gt;Issues&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://bugs.python.org/issue39573"&gt;PyObject: bpo-39573&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://bugs.python.org/issue40170"&gt;PyTypeObject: bpo-40170&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://bugs.python.org/issue39947"&gt;PyThreadState: bpo-39947&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://bugs.python.org/issue40421"&gt;PyFrameObject: bpo-40421&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="opaque-structures"&gt;
&lt;h2&gt;Opaque structures&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Python 3.8 made the PyInterpreterState structure opaque.&lt;/li&gt;
&lt;li&gt;Python 3.9 made the PyGC_Head structure opaque.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="add-getter-functions-to-python-3-9"&gt;
&lt;h2&gt;Add getter functions to Python 3.9&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;PyObject, PyVarObject:&lt;ul&gt;
&lt;li&gt;Py_SET_REFCNT()&lt;/li&gt;
&lt;li&gt;Py_SET_TYPE()&lt;/li&gt;
&lt;li&gt;Py_SET_SIZE()&lt;/li&gt;
&lt;li&gt;Py_IS_TYPE()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PyFrameObject:&lt;ul&gt;
&lt;li&gt;PyFrame_GetCode()&lt;/li&gt;
&lt;li&gt;PyFrame_GetBack()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PyThreadState:&lt;ul&gt;
&lt;li&gt;PyThreadState_GetInterpreter()&lt;/li&gt;
&lt;li&gt;PyThreadState_GetFrame()&lt;/li&gt;
&lt;li&gt;PyThreadState_GetID()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PyInterpreterState:&lt;ul&gt;
&lt;li&gt;PyInterpreterState_Get()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PyInterpreterState_Get() can be used to replace &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;PyThreadState_Get()-&amp;gt;interp&lt;/span&gt;&lt;/tt&gt;
and &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;PyThreadState_GetInterpreter(PyThreadState_Get())&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="convert-macros-to-static-inline-functions-in-python-3-8"&gt;
&lt;h2&gt;Convert macros to static inline functions in Python 3.8&lt;/h2&gt;
&lt;div class="section" id="macro-pitfalls"&gt;
&lt;h3&gt;Macro pitfalls&lt;/h3&gt;
&lt;p&gt;Macros are convenient but have &lt;a class="reference external" href="https://gcc.gnu.org/onlinedocs/cpp/Macro-Pitfalls.html"&gt;multiple pitfalls&lt;/a&gt;. Some macros
can be abused in surprising ways. For example, the following code is valid with
Python 3.9:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
if (obj == NULL || PyList_SET_ITEM (l, i, obj) &amp;lt; 0) { ... }
&lt;/pre&gt;
&lt;p&gt;In Python 3.9, PyList_SET_ITEM() returns &lt;em&gt;obj&lt;/em&gt; in this case, &lt;em&gt;obj&lt;/em&gt; is a
pointer, and so the test checks if a pointer is negative which makes no sense
(but is accepted by C compilers by default). This code is likely a confusion
with PyList_SetItem() which returns a int, negative in case of an error.&lt;/p&gt;
&lt;p&gt;Zackery Spytz and me modified &lt;a class="reference external" href="https://github.com/python/cpython/commit/556d97f473fa538cef780f84bd29239ecf57d9c5"&gt;PyList_SET_ITEM()&lt;/a&gt;
and &lt;a class="reference external" href="https://github.com/python/cpython/commit/0ef96c2b2a291c9d2d9c0ba42bbc1900a21e65f3"&gt;PyCell_SET()&lt;/a&gt;
macros in Python 3.10 to return void.&lt;/p&gt;
&lt;p&gt;This change broke alsa-python: I proposed a &lt;a class="reference external" href="https://github.com/alsa-project/alsa-python/commit/5ea2f8709b4d091700750661231f8a3ddce0fc7c"&gt;fix which was merged&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;One nice side effect of converting macros to static inline functions is that
debuggers and profilers are able to retrieve the name of the function.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="converted-macros"&gt;
&lt;h3&gt;Converted macros&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Py_INCREF(), Py_XINCREF()&lt;/li&gt;
&lt;li&gt;Py_DECREF(), Py_XDECREF()&lt;/li&gt;
&lt;li&gt;PyObject_INIT(), PyObject_INIT_VAR()&lt;/li&gt;
&lt;li&gt;_PyObject_GC_TRACK(), _PyObject_GC_UNTRACK(), _Py_Dealloc()&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="performance"&gt;
&lt;h3&gt;Performance&lt;/h3&gt;
&lt;p&gt;Since &lt;tt class="docutils literal"&gt;Py_INCREF()&lt;/tt&gt; is criticial for general Python performance, the impact
of the change was analyzed in depth before &lt;a class="reference external" href="https://github.com/python/cpython/commit/2aaf0c12041bcaadd7f2cc5a54450eefd7a6ff12"&gt;being merged&lt;/a&gt;
in &lt;a class="reference external" href="https://bugs.python.org/issue35059"&gt;bpo-35059&lt;/a&gt;. The usage of
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;__attribute__((always_inline))&lt;/span&gt;&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;__forceinline&lt;/tt&gt; to force inlining was
rejected.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="cast-to-pyobject"&gt;
&lt;h3&gt;Cast to PyObject*&lt;/h3&gt;
&lt;p&gt;Old Py_INCREF() implementation in Python 3.7:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#define Py_INCREF(op) (                   \
    _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA \
    ((PyObject *)(op))-&amp;gt;ob_refcnt++)
&lt;/pre&gt;
&lt;p&gt;where &lt;tt class="docutils literal"&gt;_Py_INC_REFTOTAL _Py_REF_DEBUG_COMMA&lt;/tt&gt; becomes &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;_Py_RefTotal++,&lt;/span&gt;&lt;/tt&gt; if
the &lt;tt class="docutils literal"&gt;Py_REF_DEBUG&lt;/tt&gt; macro is defined, or nothing otherwise. Current
Py_INCREF() implementation in Python 3.10:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static inline void _Py_INCREF(PyObject *op)
{
#ifdef Py_REF_DEBUG
    _Py_RefTotal++;
#endif
    op-&amp;gt;ob_refcnt++;
}
#define Py_INCREF(op) _Py_INCREF(_PyObject_CAST(op))
&lt;/pre&gt;
&lt;p&gt;Most static inline functions go through a macro to cast their argument to
&lt;tt class="docutils literal"&gt;PyObject*&lt;/tt&gt; using the macro:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#define _PyObject_CAST(op) ((PyObject*)(op))
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="convert-macros-to-regular-functions-in-python-3-9"&gt;
&lt;h2&gt;Convert macros to regular functions in Python 3.9&lt;/h2&gt;
&lt;div class="section" id="converted-macros-1"&gt;
&lt;h3&gt;Converted macros&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;PyIndex_Check()&lt;/li&gt;
&lt;li&gt;PyObject_CheckBuffer()&lt;/li&gt;
&lt;li&gt;PyObject_GET_WEAKREFS_LISTPTR()&lt;/li&gt;
&lt;li&gt;PyObject_IS_GC()&lt;/li&gt;
&lt;li&gt;PyObject_NEW(): alias to PyObject_New()&lt;/li&gt;
&lt;li&gt;PyObject_NEW_VAR(): alias to PyObjectVar_New()&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="performance-1"&gt;
&lt;h3&gt;Performance&lt;/h3&gt;
&lt;p&gt;PyType_HasFeature() was modified to always call PyType_GetFlags() function,
rather than accessing directly &lt;tt class="docutils literal"&gt;PyTypeObject.tp_flags&lt;/tt&gt;. The problem is that
on macOS, Python is built without LTO, the PyType_GetFlags() call is not
inlined, making functions like tuplegetter_descr_get() &lt;strong&gt;slower&lt;/strong&gt;: see
&lt;a class="reference external" href="https://bugs.python.org/issue39542#msg372962"&gt;bpo-39542&lt;/a&gt;. I &lt;strong&gt;reverted the
PyType_HasFeature() change&lt;/strong&gt; until the PEP 620 is accepted. macOS does not
use LTO to keep support support for macOS 10.6 (Snow Leopard): see &lt;a class="reference external" href="https://bugs.python.org/issue41181"&gt;bpo-41181&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="fast-static-inline-functions"&gt;
&lt;h3&gt;Fast static inline functions&lt;/h3&gt;
&lt;p&gt;To keep best performances on Python built without LTO, fast private variants
were added as static inline functions to the internal C API:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;_PyIndex_Check()&lt;/li&gt;
&lt;li&gt;_PyObject_IS_GC()&lt;/li&gt;
&lt;li&gt;_PyType_HasFeature()&lt;/li&gt;
&lt;li&gt;_PyType_IS_GC()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For example, PyObject_IS_GC() is defined as a function, whereas
_PyObject_IS_GC() is defined as an internal static inline function. Header
file:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
/* Test if an object implements the garbage collector protocol */
PyAPI_FUNC(int) PyObject_IS_GC(PyObject *obj);

// Fast inlined version of PyObject_IS_GC()
static inline int _PyObject_IS_GC(PyObject *obj)
{
    return (PyType_IS_GC(Py_TYPE(obj))
            &amp;amp;&amp;amp; (Py_TYPE(obj)-&amp;gt;tp_is_gc == NULL
                || Py_TYPE(obj)-&amp;gt;tp_is_gc(obj)));
}
&lt;/pre&gt;
&lt;p&gt;C code:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
int
PyObject_IS_GC(PyObject *obj)
{
    return _PyObject_IS_GC(obj);
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="python-3-10-incompatible-c-api-change"&gt;
&lt;h2&gt;Python 3.10 incompatible C API change&lt;/h2&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;Py_REFCNT()&lt;/tt&gt; macro was converted to a static inline function:
&lt;tt class="docutils literal"&gt;Py_REFCNT(obj) = refcnt;&lt;/tt&gt; now fails with a compiler error. It must be
replaced with &lt;tt class="docutils literal"&gt;Py_SET_REFCNT(obj, refcnt)&lt;/tt&gt;: Py_SET_REFCNT() was added to
Python 3.9.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-complex-case-of-py-type-and-py-size-macros"&gt;
&lt;h2&gt;The complex case of Py_TYPE() and Py_SIZE() macros&lt;/h2&gt;
&lt;div class="section" id="macros-converted-and-then-reverted"&gt;
&lt;h3&gt;Macros converted and then reverted&lt;/h3&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;Py_TYPE()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;Py_SIZE()&lt;/tt&gt; macros were also converted to static inline
functions in Python 3.10, but the change &lt;a class="reference external" href="https://bugs.python.org/issue39573#msg370303"&gt;broke 17 C extensions&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Since the change broke too many C extensions, I reverted the change: I
&lt;a class="reference external" href="https://github.com/python/cpython/commit/0e2ac21dd4960574e89561243763eabba685296a"&gt;converted Py_TYPE() and Py_SIZE() back to macros&lt;/a&gt;
to have more time to fix fix C extensions.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="i-fixed-6-extensions"&gt;
&lt;h3&gt;I fixed 6 extensions&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Cython: &lt;a class="reference external" href="https://github.com/cython/cython/commit/d8e93b332fe7d15459433ea74cd29178c03186bd"&gt;my fix adding __Pyx_SET_SIZE() and __Pyx_SET_REFCNT()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;immutables: &lt;a class="reference external" href="https://github.com/MagicStack/immutables/commit/45105ecd8b56a4d88dbcb380fcb8ff4b9cc7b19c"&gt;my fix adding pythoncapi_compat.h for Py_SET_SIZE()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;breezy: &lt;a class="reference external" href="https://bazaar.launchpad.net/~brz/brz/3.1/revision/7647"&gt;my fix adding Py_SET_REFCNT() macro&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;bitarray: &lt;a class="reference external" href="https://github.com/ilanschnell/bitarray/commit/a0cca9f2986ec796df74ca8f42aff56c4c7103ba"&gt;my fix adding pythoncapi_compat.h&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;python-zstandard: &lt;a class="reference external" href="https://github.com/indygreg/python-zstandard/commit/e5a3baf61b65f3075f250f504ddad9f8612bfedf"&gt;my fix adding pythoncapi_compat.h&lt;/a&gt;
followed by &lt;a class="reference external" href="https://github.com/indygreg/python-zstandard/commit/477776e6019478ca1c0b5777b073afbec70975f5"&gt;a pythoncapi_compat.h update for Python 2.7&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;mercurial: &lt;a class="reference external" href="https://www.mercurial-scm.org/repo/hg/rev/e92ca942ddca"&gt;my fix adding pythoncapi_compat.h&lt;/a&gt;
followed by a &lt;a class="reference external" href="https://www.mercurial-scm.org/repo/hg/rev/38b9a63d3a13"&gt;fix for Python 2.7&lt;/a&gt;
(then &lt;a class="reference external" href="https://github.com/pythoncapi/pythoncapi_compat/commit/3e0bde93954ea8df328d36900c7060a3f3433eb0"&gt;fixed into upstream pythoncapi_compat.h&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="extensions-fixed-by-others"&gt;
&lt;h3&gt;Extensions fixed by others&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;numpy: &lt;a class="reference external" href="https://github.com/numpy/numpy/commit/a96b18e3d4d11be31a321999cda4b795ea9eccaa"&gt;fix defining Py_SET_TYPE() and Py_SET_SIZE()&lt;/a&gt;,
followed by a &lt;a class="reference external" href="https://github.com/numpy/numpy/commit/f1671076c80bd972421751f2d48186ee9ac808aa"&gt;cleanup commit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;pycurl: &lt;a class="reference external" href="https://github.com/pycurl/pycurl/commit/e633f9a1ac4df5e249e78c218d5fbbd848219042"&gt;fix defining Py_SET_TYPE()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;boost: &lt;a class="reference external" href="https://github.com/boostorg/python/commit/500194edb7833d0627ce7a2595fec49d0aae2484#diff-b06ac66c98951b48056826c904be75263cdf56ec9b79d3274ea493e7d27cbac4"&gt;fix adding Py_SET_TYPE() and Py_SET_SIZE() macros&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;duplicity:
&lt;a class="reference external" href="https://git.launchpad.net/duplicity/commit/?id=9c63dcb83e922e0afac206188203891e203b4e66"&gt;fix 1&lt;/a&gt;,
&lt;a class="reference external" href="https://git.launchpad.net/duplicity/commit/?id=bbaae91b5ac6ef7e295968e508522884609fbf84"&gt;fix 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;pylibacl: &lt;a class="reference external" href="https://github.com/iustin/pylibacl/commit/26712b8fd92f1146102248cac1c92cb344620eff"&gt;fixed&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;gobject-introspection: &lt;a class="reference external" href="https://gitlab.gnome.org/GNOME/gobject-introspection/-/commit/c4d7d21a2ad838077c6310532fdf7505321f0ae7"&gt;fix adding Py_SET_TYPE() macro&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="extensions-still-not-fixed"&gt;
&lt;h3&gt;Extensions still not fixed&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;pyside2:&lt;ul&gt;
&lt;li&gt;My patch is not merged upstream yet&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://bugreports.qt.io/browse/PYSIDE-1436"&gt;https://bugreports.qt.io/browse/PYSIDE-1436&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://src.fedoraproject.org/rpms/python-pyside2/pull-request/7"&gt;https://src.fedoraproject.org/rpms/python-pyside2/pull-request/7&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://bugzilla.redhat.com/show_bug.cgi?id=1898974"&gt;https://bugzilla.redhat.com/show_bug.cgi?id=1898974&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://bugzilla.redhat.com/show_bug.cgi?id=1902618"&gt;https://bugzilla.redhat.com/show_bug.cgi?id=1902618&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;pybluez: &lt;a class="reference external" href="https://github.com/pybluez/pybluez/pull/371"&gt;closed PR (not merged)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;PyPAM&lt;/li&gt;
&lt;li&gt;pygobject3&lt;/li&gt;
&lt;li&gt;rdiff-backup&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="what-s-next"&gt;
&lt;h2&gt;What's Next?&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Convert again Py_TYPE() and Py_SIZE() macros to static inline functions.&lt;/li&gt;
&lt;li&gt;Add &amp;quot;%T&amp;quot; formatter for &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;Py_TYPE(obj)-&amp;gt;tp_name&lt;/span&gt;&lt;/tt&gt;:
see &lt;a class="reference external" href="https://bugs.python.org/issue34595"&gt;rejected bpo-34595&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Modify Cython to use getter functions.&lt;/li&gt;
&lt;li&gt;Attempt to make some structures opaque, like PyThreadState.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content><category term="cpython"></category><category term="c-api"></category><category term="cpython"></category></entry><entry><title>Isolate Python Subinterpreters</title><link href="https://vstinner.github.io/isolate-subinterpreters.html" rel="alternate"></link><published>2020-12-27T22:00:00+01:00</published><updated>2020-12-27T22:00:00+01:00</updated><author><name>Victor Stinner</name></author><id>tag:vstinner.github.io,2020-12-27:/isolate-subinterpreters.html</id><summary type="html">&lt;img alt="Christmas gift." src="https://vstinner.github.io/images/christmas-gift.jpg" /&gt;
&lt;p&gt;This article is about the work done in Python in 2019 and 2020 to better
isolate subinterpreters. Static types are converted to heap types, extension
modules are converted to use the new multiphase initialization API (PEP 489),
caches, states, singletons and free lists are made per-interpreter, many bugs
have been …&lt;/p&gt;</summary><content type="html">&lt;img alt="Christmas gift." src="https://vstinner.github.io/images/christmas-gift.jpg" /&gt;
&lt;p&gt;This article is about the work done in Python in 2019 and 2020 to better
isolate subinterpreters. Static types are converted to heap types, extension
modules are converted to use the new multiphase initialization API (PEP 489),
caches, states, singletons and free lists are made per-interpreter, many bugs
have been fixed, etc.&lt;/p&gt;
&lt;p&gt;Running multiple interpreters in parallel with one &amp;quot;GIL&amp;quot; per interpreter cannot
be done yet, but a lot of complex technical challenges have been solved.&lt;/p&gt;
&lt;div class="section" id="why-isolating-subinterpreters"&gt;
&lt;h2&gt;Why isolating subinterpreters?&lt;/h2&gt;
&lt;p&gt;The final goal is to be able run multiple interpreters in parallel in the same
process, like one interpreter per CPU, each interpreter would run in its own
thread. The principle is the same than the multiprocessing module and has the
same limitations: no Python object can be shared directly between two
interpreters. Later, we can imagine helpers to share Python mutable objects
using proxies which would prevent race conditions.&lt;/p&gt;
&lt;p&gt;The work on subinterpreter requires to modify many functions and extension
modules. It will benefit to Python in different ways.&lt;/p&gt;
&lt;p&gt;Converting static types to heap types and convert extension modules to the
multiphase initialization API (PEP 489) makes extension modules implemented in
C to behave closer to modules implemented in Python, which is good for the &lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0399/"&gt;PEP
399 -- Pure Python/C Accelerator Module Compatibility Requirements&lt;/a&gt;. So &lt;strong&gt;this work also helps
Python implementations other than CPython, like PyPy&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;These changes also destroy more Python objects and release more memory at
Python exit which matters &lt;strong&gt;when Python is embedded in an application&lt;/strong&gt;. Python
should be &amp;quot;state less&amp;quot;, especially release all memory at exit. This work slowly
fix the &lt;a class="reference external" href="https://bugs.python.org/issue1635741"&gt;bpo-163574: Py_Finalize() doesn't clear all Python objects at exit&lt;/a&gt;. Python leaks less and less Python
objects at exit.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="proof-of-concept-in-may-2020"&gt;
&lt;h2&gt;Proof-of-concept in May 2020&lt;/h2&gt;
&lt;p&gt;In May 2020, I wrote a proof-of-concept to prove the feasability of the project
and to prove that it is faster than sequential execution: &lt;a class="reference external" href="https://mail.python.org/archives/list/python-dev&amp;#64;python.org/thread/S5GZZCEREZLA2PEMTVFBCDM52H4JSENR/#RIK75U3ROEHWZL4VENQSQECB4F4GDELV"&gt;PoC: Subinterpreters
4x faster than sequential execution or threads on CPU-bound workaround&lt;/a&gt;.
Benchmark on 4 CPUs:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Sequential: 1.99 sec +- 0.01 sec&lt;/li&gt;
&lt;li&gt;Threads: 3.15 sec +- 0.97 sec (1.5x &lt;strong&gt;slower&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;Multiprocessing: 560 ms +- 12 ms (3.6x &lt;strong&gt;faster&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;Subinterpreters: 583 ms +- 7 ms (3.4x &lt;strong&gt;faster&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The performance of subintepreters is basically the same speed than
multiprocessing on this benchmark which is promising.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="experimental-isolated-subintepreters"&gt;
&lt;h2&gt;Experimental isolated subintepreters&lt;/h2&gt;
&lt;p&gt;To write this PoC, I added a &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--with-experimental-isolated-subinterpreters&lt;/span&gt;&lt;/tt&gt;
option to &lt;tt class="docutils literal"&gt;./configure&lt;/tt&gt; in &lt;a class="reference external" href="https://bugs.python.org/issue40514"&gt;bpo-40514&lt;/a&gt;
which defines the &lt;tt class="docutils literal"&gt;EXPERIMENTAL_ISOLATED_SUBINTERPRETERS&lt;/tt&gt; macro. Effects of
this special build:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Make the GIL per-interpreter.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_xxsubinterpreters.run_string()&lt;/tt&gt; releases the GIL when running the
subinterpreter.&lt;/li&gt;
&lt;li&gt;Add a thread local storage for the Python thread state (&amp;quot;tstate&amp;quot;).&lt;/li&gt;
&lt;li&gt;Disable the garbage collector in subinterpreters.&lt;/li&gt;
&lt;li&gt;Disable the type attribute lookup cache.&lt;/li&gt;
&lt;li&gt;Disable free lists: frame, list, tuple, type attribute lookup cache.&lt;/li&gt;
&lt;li&gt;Disable singletons: latin1 characters.&lt;/li&gt;
&lt;li&gt;Disable interned strings.&lt;/li&gt;
&lt;li&gt;Disable the fast pymalloc memory allocator (force libc malloc memory
allocator).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Features are disabled because their implementation is currently not compatible
with multiple interpreters running in parallel.&lt;/p&gt;
&lt;p&gt;This special build is designed to be temporary. It should ease the development
of isolated subinterpreters. It will be removed once subinterpreters will be
fully isolated (once each interpreter will have its own GIL).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="convert-static-types-to-heap-types"&gt;
&lt;h2&gt;Convert static types to heap types&lt;/h2&gt;
&lt;p&gt;Types declared in Python (&lt;tt class="docutils literal"&gt;class MyType: ...&lt;/tt&gt;) are always &amp;quot;heap types&amp;quot;:
types dynamically allocated on the heap memory. Historically, all types
declared in C were declared as &amp;quot;static types&amp;quot;: defined statically at build
time.&lt;/p&gt;
&lt;p&gt;In C, static types are referenced directly using the using &lt;tt class="docutils literal"&gt;&amp;amp;&lt;/tt&gt; operator to
get their address, they are not copied. For example, the Python &lt;tt class="docutils literal"&gt;str&lt;/tt&gt; type is
referenced as &lt;tt class="docutils literal"&gt;&amp;amp;PyUnicode_Type&lt;/tt&gt; in C.&lt;/p&gt;
&lt;p&gt;Types are also regular objects (&lt;tt class="docutils literal"&gt;PyTypeObject&lt;/tt&gt; inherits from &lt;tt class="docutils literal"&gt;PyObject&lt;/tt&gt;)
and have a reference count, whereas the &lt;tt class="docutils literal"&gt;PyObject.ob_refcnt&lt;/tt&gt; member is not
atomic and so must not be modified in parallel. Problem: all interpreters share
the same static types.  Static types have other problems:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;A type &lt;tt class="docutils literal"&gt;__mro__&lt;/tt&gt; tuple (&lt;tt class="docutils literal"&gt;PyTypeObject.tp_mro&lt;/tt&gt; member) has the same
problem of non-atomic reference count.&lt;/li&gt;
&lt;li&gt;When a subtype is created, it is stored in the &lt;tt class="docutils literal"&gt;PyTypeObject.tp_subclasses&lt;/tt&gt;
dictionary member (accessible in Python with the &lt;tt class="docutils literal"&gt;__subclasses__()&lt;/tt&gt;
method), whereas Python dictionaries are not thread-safe.&lt;/li&gt;
&lt;li&gt;Static types behave differently than regular Python types. For example,
usually it is not possible to add an arbitrary attribute or override
an attribute. It goes against the &lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0399/"&gt;PEP 399 -- Pure Python/C Accelerator
Module Compatibility Requirements&lt;/a&gt; principles.&lt;/li&gt;
&lt;li&gt;etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Right now, &lt;strong&gt;43% (89/206)&lt;/strong&gt; of types are declared as heap types on a total of
206 types. For comparison, in Python 3.8, only 9% (15/172) of types were
declared as heap types: &lt;strong&gt;74 types&lt;/strong&gt; have been converted in the meanwhile.&lt;/p&gt;
&lt;p&gt;TODO: convert the remaining 117 static types: see &lt;a class="reference external" href="https://bugs.python.org/issue40077"&gt;bpo-40077&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="multiphase-initialization-api"&gt;
&lt;h2&gt;Multiphase initialization API&lt;/h2&gt;
&lt;p&gt;Historically, extension modules are declared with the &lt;tt class="docutils literal"&gt;PyModule_Create()&lt;/tt&gt;
function. Usually, such extension can be instanciated exactly once. It is
stored in an internal &lt;tt class="docutils literal"&gt;PyInterpreterState.modules_by_index&lt;/tt&gt; list; an unique
index is assigned to the module and stored in &lt;tt class="docutils literal"&gt;PyModuleDef.m_base.m_index&lt;/tt&gt;.
Usually, such extension use static global variables.&lt;/p&gt;
&lt;p&gt;Such &amp;quot;static&amp;quot; extension has multiple issues:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;The extension cannot be unloaded: its memory is not released at Python exit.
It is an issue when Python is embedded in an application.&lt;/li&gt;
&lt;li&gt;The extension behaves differently than modules defined in Python. When an
extension is reimported, its namespace (&lt;tt class="docutils literal"&gt;module.__dict__&lt;/tt&gt;) is duplicated,
but mutable objects and static global variables are still shared. It goes
against the &lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0399/"&gt;PEP 399 -- Pure Python/C Accelerator Module Compatibility
Requirements&lt;/a&gt; principles.&lt;/li&gt;
&lt;li&gt;etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In 2013, &lt;strong&gt;Petr Viktorin&lt;/strong&gt;, &lt;strong&gt;Stefan Behnel&lt;/strong&gt; and &lt;strong&gt;Nick Coghlan&lt;/strong&gt; wrote the
&lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0489/"&gt;PEP 489 -- Multi-phase extension module initialization&lt;/a&gt; which has been approved and
implemented in Python 3.5. For example, the &lt;tt class="docutils literal"&gt;_abc&lt;/tt&gt; module initialization
function is now just a call to the new &lt;tt class="docutils literal"&gt;PyModuleDef_Init()&lt;/tt&gt; function:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
PyMODINIT_FUNC
PyInit__abc(void)
{
    return PyModuleDef_Init(&amp;amp;_abcmodule);
}
&lt;/pre&gt;
&lt;p&gt;An extension module can have a module state, if &lt;tt class="docutils literal"&gt;PyModuleDef.m_size&lt;/tt&gt; is
greater than zero. Example:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
typedef struct {
    PyTypeObject *_abc_data_type;
    unsigned long long abc_invalidation_counter;
} _abcmodule_state;

static struct PyModuleDef _abcmodule = {
    ...
    .m_size = sizeof(_abcmodule_state),  // &amp;lt;=== HERE ===
};
&lt;/pre&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;PyModule_GetState()&lt;/tt&gt; can be used to retrieve the module state. Example:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static inline _abcmodule_state*
get_abc_state(PyObject *module)
{
    void *state = PyModule_GetState(module);
    assert(state != NULL);
    return (_abcmodule_state *)state;
}

static PyObject *
_abc__abc_init(PyObject *module, PyObject *self)
{
    _abcmodule_state *state = get_abc_state(module);
    ...
    data = abc_data_new(state-&amp;gt;_abc_data_type, NULL, NULL);
    ...
}
&lt;/pre&gt;
&lt;p&gt;Right now, &lt;strong&gt;77% (102/132)&lt;/strong&gt; of extension modules use the new multiphase
initialization API (PEP 489) on a total of 132 extension modules.  For
comparison, in Python 3.8, only 23% (27/118) of extensions used the new
multiphase initialization API: &lt;strong&gt;75 extensions&lt;/strong&gt; have been converted in the
meanwhile.&lt;/p&gt;
&lt;p&gt;TODO: convert the remaining 30 extension modules (&lt;a class="reference external" href="https://bugs.python.org/issue1635741"&gt;bpo-163574&lt;/a&gt;).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="module-states"&gt;
&lt;h2&gt;Module states&lt;/h2&gt;
&lt;p&gt;Some modules have a state which should be stored in the interpreter to share
its state between multiple instances of the module, and also to give access to
the state in functions of the public C API (ex: &lt;tt class="docutils literal"&gt;PyAST_Check()&lt;/tt&gt;).&lt;/p&gt;
&lt;p&gt;States made per-interpreter:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;2019-05-10: &lt;strong&gt;warnings&lt;/strong&gt;
(&lt;a class="reference external" href="https://bugs.python.org/issue36737"&gt;bpo-36737&lt;/a&gt;,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/86ea58149c3e83f402cecd17e6a536865fb06ce1"&gt;commit&lt;/a&gt; by &lt;strong&gt;Eric Snow&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;2019-11-07: &lt;strong&gt;parser&lt;/strong&gt;
(&lt;a class="reference external" href="https://bugs.python.org/issue36876"&gt;bpo-36876&lt;/a&gt;,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/9def81aa52adc3cc89554156e40742cf17312825"&gt;commit&lt;/a&gt; by &lt;strong&gt;Vinay Sajip&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;2019-11-20: &lt;strong&gt;gc&lt;/strong&gt;
(&lt;a class="reference external" href="https://bugs.python.org/issue36854"&gt;bpo-36854&lt;/a&gt;,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/7247407c35330f3f6292f1d40606b7ba6afd5700"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;li&gt;2020-11-02: &lt;strong&gt;ast&lt;/strong&gt;
(&lt;a class="reference external" href="https://bugs.python.org/issue41796"&gt;bpo-41796&lt;/a&gt;,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/5cf4782a2630629d0978bf4cf6b6340365f449b2"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;li&gt;2020-12-15: &lt;strong&gt;atexit&lt;/strong&gt;
(&lt;a class="reference external" href="https://bugs.python.org/issue42639"&gt;bpo-42639&lt;/a&gt;,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/b8fa135908d294b350cdad04e2f512327a538dee"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="singletons"&gt;
&lt;h2&gt;Singletons&lt;/h2&gt;
&lt;p&gt;Singletons must not be shared between interpreters.&lt;/p&gt;
&lt;p&gt;Singletons made per-interpreter.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://bugs.python.org/issue38858"&gt;bpo-38858&lt;/a&gt;:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;2019-12-17: small &lt;strong&gt;integer&lt;/strong&gt;, the [-5; 256] range
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/630c8df5cf126594f8c1c4579c1888ca80a29d59"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a class="reference external" href="https://bugs.python.org/issue40521"&gt;bpo-40521&lt;/a&gt;:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;2020-06-04: empty &lt;strong&gt;tuple&lt;/strong&gt; singleton
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/69ac6e58fd98de339c013fe64cd1cf763e4f9bca"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;li&gt;2020-06-23: empty &lt;strong&gt;bytes&lt;/strong&gt; string singleton and single byte character
(&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;b'\x00'&lt;/span&gt;&lt;/tt&gt; to &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;b'\xFF'&lt;/span&gt;&lt;/tt&gt;) singletons
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/c41eed1a874e2f22bde45c3c89418414b7a37f46"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;li&gt;2020-06-23: empty &lt;strong&gt;Unicode&lt;/strong&gt; string singleton
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/f363d0a6e9cfa50677a6de203735fbc0d06c2f49"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;li&gt;2020-06-23: empty &lt;strong&gt;frozenset&lt;/strong&gt; singleton
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/261cfedf7657a515e04428bba58eba2a9bb88208"&gt;commit&lt;/a&gt; by me);
later removed.&lt;/li&gt;
&lt;li&gt;2020-06-24: single &lt;strong&gt;Unicode&lt;/strong&gt; character (U+0000-U+00FF range)
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/2f9ada96e0d420fed0d09a032b37197f08ef167a"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I also micro-optimized the code: most singletons are now always created at
startup, it's no longer needed to check if it is created at each function call.
Moreover, an assertion now ensures that singletons are no longer used after
they are deleted.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="free-lists"&gt;
&lt;h2&gt;Free lists&lt;/h2&gt;
&lt;p&gt;A free list is a micro-optimization on memory allocations. The memory of
recently destroyed objects is not freed to be able to reuse it for new objects.
Free lists must not be shared between interpreters.&lt;/p&gt;
&lt;p&gt;Free lists made per-interpreter (&lt;a class="reference external" href="https://bugs.python.org/issue40521"&gt;bpo-40521&lt;/a&gt;):&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;2020-06-04: &lt;strong&gt;slice&lt;/strong&gt;
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/7daba6f221e713f7f60c613b246459b07d179f91"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;li&gt;2020-06-04: &lt;strong&gt;tuple&lt;/strong&gt;
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/69ac6e58fd98de339c013fe64cd1cf763e4f9bca"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;li&gt;2020-06-04: &lt;strong&gt;float&lt;/strong&gt;
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/2ba59370c3dda2ac229c14510e53a05074b133d1"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;li&gt;2020-06-04: &lt;strong&gt;frame&lt;/strong&gt;
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/3744ed2c9c0b3905947602fc375de49533790cb9"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;li&gt;2020-06-05: &lt;strong&gt;async generator&lt;/strong&gt;
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/78a02c2568714562e23e885b6dc5730601f35226"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;li&gt;2020-06-05: &lt;strong&gt;context&lt;/strong&gt;
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/e005ead49b1ee2b1507ceea94e6f89c28ecf1f81"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;li&gt;2020-06-05: &lt;strong&gt;list&lt;/strong&gt;
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/88ec9190105c9b03f49aaef601ce02b242a75273"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;li&gt;2020-06-23: &lt;strong&gt;dict&lt;/strong&gt;
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/b4e85cadfbc2b1b24ec5f3159e351dbacedaa5e0"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;li&gt;2020-06-23: &lt;strong&gt;MemoryError&lt;/strong&gt;
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/281cce1106568ef9fec17e3c72d289416fac02a5"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="caches"&gt;
&lt;h2&gt;Caches&lt;/h2&gt;
&lt;p&gt;Caches made per interpreter:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;2020-06-04: &lt;strong&gt;slice&lt;/strong&gt; cache
(&lt;a class="reference external" href="https://bugs.python.org/issue40521"&gt;bpo-40521&lt;/a&gt;,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/7daba6f221e713f7f60c613b246459b07d179f91"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;li&gt;2020-12-26: &lt;strong&gt;type&lt;/strong&gt; attribute lookup cache
(&lt;a class="reference external" href="https://bugs.python.org/issue42745"&gt;bpo-42745&lt;/a&gt;,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/41010184880151d6ae02a226dbacc796e5c90d11"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="interned-strings-and-identifiers"&gt;
&lt;h2&gt;Interned strings and identifiers&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;2020-12-25: Per-interpreter identifiers: &lt;tt class="docutils literal"&gt;_PyUnicode_FromId()&lt;/tt&gt;
(&lt;a class="reference external" href="https://bugs.python.org/issue39465"&gt;bpo-39465&lt;/a&gt;,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/ba3d67c2fb04a7842741b1b6da5d67f22c579f33"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;li&gt;2020-12-26: Per-interpreter interned strings: &lt;tt class="docutils literal"&gt;PyUnicode_InternInPlace()&lt;/tt&gt;
(&lt;a class="reference external" href="https://bugs.python.org/issue40521"&gt;bpo-40521&lt;/a&gt;,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/ea251806b8dffff11b30d2182af1e589caf88acf"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For &lt;tt class="docutils literal"&gt;_PyUnicode_FromId()&lt;/tt&gt;, I added the &lt;tt class="docutils literal"&gt;pycore_atomic_funcs.h&lt;/tt&gt; header file
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/52a327c1cbb86c7f2f5c460645889b23615261bf"&gt;commit&lt;/a&gt;)
which adds functions for atomic memory accesses (to variables of type
&lt;tt class="docutils literal"&gt;Py_ssize_t&lt;/tt&gt;). It uses &lt;tt class="docutils literal"&gt;__atomic_load_n()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;__atomic_store_n()&lt;/tt&gt; on GCC
and clang, or &lt;tt class="docutils literal"&gt;_InterlockedCompareExchange64()&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;_InterlockedExchange64()&lt;/tt&gt; on MSC (Windows).&lt;/p&gt;
&lt;p&gt;First, I tried to use the &lt;tt class="docutils literal"&gt;_Py_hashtable&lt;/tt&gt; type: &lt;a class="reference external" href="https://github.com/python/cpython/pull/20048"&gt;PR 20048&lt;/a&gt;. Using &lt;tt class="docutils literal"&gt;_Py_hashtable&lt;/tt&gt;,
&lt;tt class="docutils literal"&gt;_PyUnicode_FromId()&lt;/tt&gt; took 15.5 ns +- 0.1 ns.  I optimized &lt;tt class="docutils literal"&gt;_Py_hashtable&lt;/tt&gt;:
&lt;tt class="docutils literal"&gt;_PyUnicode_FromId()&lt;/tt&gt; took 6.65 ns +- 0.09 ns. But it was still slower than
the reference code: 2.38 ns +- 0.00 ns.&lt;/p&gt;
&lt;p&gt;The merged implementation uses an array. An unique index is assigned, index in
this array. The array is made larger on demand. The final change adds 1 ns
per function call:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
[ref] 2.42 ns +- 0.00 ns -&amp;gt; [atomic] 3.39 ns +- 0.00 ns: 1.40x slower
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="misc"&gt;
&lt;h2&gt;Misc&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;2020-03-19: Per-interpreter pending calls
(&lt;a class="reference external" href="https://bugs.python.org/issue39984"&gt;bpo-39984&lt;/a&gt;,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/50e6e991781db761c496561a995541ca8d83ff87"&gt;commit&lt;/a&gt; by me).&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="bugfixes"&gt;
&lt;h2&gt;Bugfixes&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://vstinner.github.io/gil-bugfixes-daemon-threads-python39.html"&gt;GIL bugfixes for daemon threads in Python 3.9&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Fix many &lt;a class="reference external" href="https://vstinner.github.io/subinterpreter-leaks.html"&gt;leaks discovered by subinterpreters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Fix pickling heap types implemented in C with protocols 0 and 1
(&lt;a class="reference external" href="https://bugs.python.org/issue41052"&gt;bpo-41052&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="pep-630-isolating-extension-modules"&gt;
&lt;h2&gt;PEP 630: Isolating Extension Modules&lt;/h2&gt;
&lt;p&gt;In August 2020, &lt;strong&gt;Petr Viktorin&lt;/strong&gt; wrote &lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0630/"&gt;PEP 630 -- Isolating Extension Modules&lt;/a&gt; which gives practical advices on
how to update an extension module to make it stateless using previous PEPs
(heap types, multi-phase init, etc.). Once a module is stateless, it becomes
safe to use it subinterpreters running in parallel.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="thanks"&gt;
&lt;h2&gt;Thanks&lt;/h2&gt;
&lt;p&gt;The work on subintepreters, multiphase init and heap types is a collaborative
work on-going for 2 years. I would like to thank the following developers for
helping on this large task:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;Christian Heimes&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dong-hee Na&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Eric Snow&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Erlend Egeberg Aasland&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hai Shi&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mohamed Koubaa&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Nick Coghlan&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Paulo Henrique Silva&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Petr Viktorin&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Vinay Sajip&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note: Since the work is scattered in many issues and pull requests, it's hard
to track who helped: sorry if I forgot someone! (Please contact me and I
will complete the list.)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="what-s-next"&gt;
&lt;h2&gt;What's Next?&lt;/h2&gt;
&lt;p&gt;There are still multiple interesting technical challenges:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://bugs.python.org/issue39511"&gt;bpo-39511: Per-interpreter singletons (None, True, False, etc.)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://bugs.python.org/issue40601"&gt;bpo-40601: Hide static types from the C API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Make pymalloc allocator compatible with subinterpreters.&lt;/li&gt;
&lt;li&gt;Make the GIL per interpreter. Maybe even give the choice to share or not
the GIL when a subinterpreter is created.&lt;/li&gt;
&lt;li&gt;Make the &lt;tt class="docutils literal"&gt;_PyArg_Parser&lt;/tt&gt; (&lt;tt class="docutils literal"&gt;parser_init()&lt;/tt&gt;) function compatible with
subinterpreters. Maybe use a per-interpreter array, similar solution than
&lt;tt class="docutils literal"&gt;_PyUnicode_FromId()&lt;/tt&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://bugs.python.org/issue15751"&gt;bpo-15751: Make the PyGILState API compatible with subinterpreters&lt;/a&gt; (issue created in 2012!)&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://bugs.python.org/issue40522"&gt;bpo-40522: Get the current Python interpreter state from Thread Local
Storage (autoTSSkey)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Also, there are still many static types to convert to heap types (&lt;a class="reference external" href="https://bugs.python.org/issue40077"&gt;bpo-40077&lt;/a&gt;) and many extension modules to convert
to the multiphase initialization API (&lt;a class="reference external" href="https://bugs.python.org/issue1635741"&gt;bpo-163574&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;I'm tracking the work in my &lt;a class="reference external" href="https://pythondev.readthedocs.io/subinterpreters.html"&gt;Python Subinterpreters&lt;/a&gt; page
and in the &lt;a class="reference external" href="https://bugs.python.org/issue40512"&gt;bpo-40512: Meta issue: per-interpreter GIL&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
</content><category term="cpython"></category><category term="cpython"></category><category term="subinterpreters"></category></entry><entry><title>Hide implementation details from the Python C API</title><link href="https://vstinner.github.io/hide-implementation-details-python-c-api.html" rel="alternate"></link><published>2020-12-25T22:00:00+01:00</published><updated>2020-12-25T22:00:00+01:00</updated><author><name>Victor Stinner</name></author><id>tag:vstinner.github.io,2020-12-25:/hide-implementation-details-python-c-api.html</id><summary type="html">&lt;img alt="My cat attacking the Python C API" src="https://vstinner.github.io/images/pepsie.jpg" /&gt;
&lt;p&gt;This article is the history of Python C API discussions over the last 4 years,
and the creation of C API projects: &lt;a class="reference external" href="https://pythoncapi.readthedocs.io/"&gt;pythoncapi website&lt;/a&gt;, &lt;a class="reference external" href="https://github.com/pythoncapi/pythoncapi_compat"&gt;pythoncapi_compat.h header file&lt;/a&gt; and &lt;a class="reference external" href="https://hpy.readthedocs.io/"&gt;HPy (new clean C API)&lt;/a&gt;. More and more people are aware of issues
caused by the C API and are working …&lt;/p&gt;</summary><content type="html">&lt;img alt="My cat attacking the Python C API" src="https://vstinner.github.io/images/pepsie.jpg" /&gt;
&lt;p&gt;This article is the history of Python C API discussions over the last 4 years,
and the creation of C API projects: &lt;a class="reference external" href="https://pythoncapi.readthedocs.io/"&gt;pythoncapi website&lt;/a&gt;, &lt;a class="reference external" href="https://github.com/pythoncapi/pythoncapi_compat"&gt;pythoncapi_compat.h header file&lt;/a&gt; and &lt;a class="reference external" href="https://hpy.readthedocs.io/"&gt;HPy (new clean C API)&lt;/a&gt;. More and more people are aware of issues
caused by the C API and are working on solutions.&lt;/p&gt;
&lt;p&gt;It took me a lot of iterations to find the right approach to evolve the C API
without breaking too many third-party extension modules. My first ideas were
based on two APIs with an opt-in option somehow. At the end, I decided to fix
directly the default API, and helped maintainers of extension modules to update
their projects for incompatible C API changes.&lt;/p&gt;
&lt;p&gt;I wrote a &lt;tt class="docutils literal"&gt;pythoncapi_compat.h&lt;/tt&gt; header file which adds C API functions of
newer Python to old Python versions up to Python 2.7. I also wrote a
&lt;tt class="docutils literal"&gt;upgrade_pythoncapi.py&lt;/tt&gt; script to add Python 3.10 support to an extension
module without losing Python 2.7 support: the tool adds &lt;tt class="docutils literal"&gt;#include
&amp;quot;pythoncapi_compat.h&amp;quot;&lt;/tt&gt;. For example, it replaces &lt;tt class="docutils literal"&gt;Py_TYPE(obj) = type&lt;/tt&gt;
with &lt;tt class="docutils literal"&gt;Py_SET_SIZE(obj, type)&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;The photo: my cat attacking the Python C API.&lt;/p&gt;
&lt;div class="section" id="year-2016"&gt;
&lt;h2&gt;Year 2016&lt;/h2&gt;
&lt;p&gt;Between 2016 and 2017, Larry Hastings worked on removing the GIL in a CPython
fork called &amp;quot;The Gilectomy&amp;quot;. He pushed the first commit in April 2016: &lt;a class="reference external" href="https://github.com/larryhastings/gilectomy/commit/4a1a4ff49e34b9705608cad968f467af161dcf02"&gt;Removed
the GIL. Don't merge this!&lt;/a&gt;
(&amp;quot;Few programs work now&amp;quot;). At EuroPython 2016, he gave the talk &lt;a class="reference external" href="https://www.youtube.com/watch?v=fgWUwQVoLHo"&gt;Larry Hastings
- The Gilectomy&lt;/a&gt; where he
explains that the current parallelism bottleneck is the CPython reference
counting which doesn't scale with the number of threads.&lt;/p&gt;
&lt;p&gt;It was just another hint telling me that &amp;quot;something&amp;quot; should be done to make the
C API more abstract, move away from implementation details like reference
counting. PyPy also has performance issues with the C API for many years.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="year-2017"&gt;
&lt;h2&gt;Year 2017&lt;/h2&gt;
&lt;div class="section" id="may"&gt;
&lt;h3&gt;May&lt;/h3&gt;
&lt;p&gt;In 2017, I discussed with Eric Snow who was working on subinterpreters. He had
to modify public structures, especially the &lt;tt class="docutils literal"&gt;PyInterpreterState&lt;/tt&gt; structure.
He created &lt;tt class="docutils literal"&gt;Include/internal/&lt;/tt&gt; subdirectory to create a new &amp;quot;internal C API&amp;quot;
which should not be exported. (Later, he moved the &lt;tt class="docutils literal"&gt;PyInterpreterState&lt;/tt&gt;
structure to the internal C API in Python 3.8.)&lt;/p&gt;
&lt;p&gt;I started the discuss C API changes during the Python Language Summit
(PyCon US 2017): &lt;a class="reference external" href="https://github.com/vstinner/conf/raw/master/2017-PyconUS/summit.pdf"&gt;&amp;quot;Python performance&amp;quot; slides (PDF)&lt;/a&gt;:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Split Include in sub-directories&lt;/li&gt;
&lt;li&gt;Move towards a stable ABI by default&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See also the LWN article: &lt;a class="reference external" href="https://lwn.net/Articles/723752/#723949"&gt;Keeping Python competitive&lt;/a&gt; by Jake Edge.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="july-first-pep-draft"&gt;
&lt;h3&gt;July: first PEP draft&lt;/h3&gt;
&lt;p&gt;I proposed the first PEP draft to python-ideas:
&lt;a class="reference external" href="https://mail.python.org/archives/list/python-ideas&amp;#64;python.org/thread/6XATDGWK4VBUQPRHCRLKQECTJIPBVNJQ/"&gt;PEP: Hide implementation details in the C API&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The idea is to add an opt-in option to distutils to build an extension module
with a new C API, remove implementation details from the new C API, and maybe
later switch to the new C API by default.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="september"&gt;
&lt;h3&gt;September&lt;/h3&gt;
&lt;p&gt;I discussed my C API change ideas at the CPython core dev sprint (at Instagram,
California).  The ideas were liked by most (if not all) core developers who are
fine with a minor performance slowdown (caused by replacing macros with
function calls). I wrote &lt;a class="reference external" href="https://vstinner.github.io/new-python-c-api.html"&gt;A New C API for CPython&lt;/a&gt; blog post about these
discussions.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="november"&gt;
&lt;h3&gt;November&lt;/h3&gt;
&lt;p&gt;I proposed &lt;a class="reference external" href="https://mail.python.org/pipermail/python-dev/2017-November/150607.html"&gt;Make the stable API-ABI usable&lt;/a&gt; on
the python-dev list. The idea is to add &lt;tt class="docutils literal"&gt;PyTuple_GET_ITEM()&lt;/tt&gt; (for example) to
the limited C API but declared as a function call. Later, if enough extension
modules are compatible with the extended limited C API, make it the default.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="year-2018"&gt;
&lt;h2&gt;Year 2018&lt;/h2&gt;
&lt;p&gt;In July, I created the &lt;a class="reference external" href="https://pythoncapi.readthedocs.io/"&gt;pythoncapi website&lt;/a&gt; to collect issues of the current C
API, list things to avoid in new functions like borrowed references, and start
to design a new better C API.&lt;/p&gt;
&lt;p&gt;In September, Antonio Cuni wrote &lt;a class="reference external" href="https://morepypy.blogspot.com/2018/09/inside-cpyext-why-emulating-cpython-c.html"&gt;Inside cpyext: Why emulating CPython C API is
so Hard&lt;/a&gt;
article.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="year-2019"&gt;
&lt;h2&gt;Year 2019&lt;/h2&gt;
&lt;p&gt;In February, I sent &lt;a class="reference external" href="https://mail.python.org/archives/list/capi-sig&amp;#64;python.org/thread/WS6ATJWRUQZESGGYP3CCSVPF7OMPMNM6/"&gt;Update on CPython header files reorganization&lt;/a&gt;
to the capi-sig list.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Include/&lt;/tt&gt;: limited C API&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Include/cpython/&lt;/tt&gt;: CPython C API&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Include/internal/&lt;/tt&gt;: CPython internal C API&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In March, I modified the Python debug build to make its ABI compatible with the
release build ABI:
&lt;a class="reference external" href="https://docs.python.org/dev/whatsnew/3.8.html#debug-build-uses-the-same-abi-as-release-build"&gt;What’s New In Python 3.8: Debug build uses the same ABI as release build&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In May, I gave a lightning talk &lt;a class="reference external" href="https://github.com/vstinner/conf/blob/master/2019-Pycon/status_stable_api_abi.pdf"&gt;Status of the stable API and ABI in Python 3.8&lt;/a&gt;,
at the Language Summit (during Pycon US 2019):&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Convert macros to static inline functions&lt;/li&gt;
&lt;li&gt;Install the internal C API&lt;/li&gt;
&lt;li&gt;Debug build now ABI compatible with the release build ABI&lt;/li&gt;
&lt;li&gt;Getting rid of global variables&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;By the way, see my &lt;a class="reference external" href="https://vstinner.github.io/split-include-directory-python38.html"&gt;Split Include/ directory in Python 3.8&lt;/a&gt; article: I converted many macros in
Python 3.8.&lt;/p&gt;
&lt;p&gt;In July, the &lt;a class="reference external" href="https://hpy.readthedocs.io/"&gt;HPy project&lt;/a&gt; was created during
EuroPython at Basel. There was an informal meeting which included core
developers of PyPy (Antonio, Armin and Ronan), CPython (Victor Stinner and Mark
Shannon) and Cython (Stefan Behnel).&lt;/p&gt;
&lt;p&gt;In December, Antonio, Armin and Ronan had a small internal sprint to kick-off
the development of HPy: &lt;a class="reference external" href="https://morepypy.blogspot.com/2019/12/hpy-kick-off-sprint-report.html"&gt;HPy kick-off sprint report&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="year-2020"&gt;
&lt;h2&gt;Year 2020&lt;/h2&gt;
&lt;div class="section" id="april"&gt;
&lt;h3&gt;April&lt;/h3&gt;
&lt;p&gt;I proposed &lt;a class="reference external" href="https://mail.python.org/archives/list/python-dev&amp;#64;python.org/thread/HKM774XKU7DPJNLUTYHUB5U6VR6EQMJF/#TKHNENOXP6H34E73XGFOL2KKXSM4Z6T2"&gt;PEP: Modify the C API to hide implementation details&lt;/a&gt;
on the python-dev list. The main idea is to provide a new optimized Python
runtime which is backward incompatible on purpose, and continue to ship the
regular runtime which is fully backward compatible.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="june"&gt;
&lt;h3&gt;June&lt;/h3&gt;
&lt;p&gt;I wrote &lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0620/"&gt;PEP 620 -- Hide implementation details from the C API&lt;/a&gt; and &lt;a class="reference external" href="https://mail.python.org/archives/list/python-dev&amp;#64;python.org/thread/HKM774XKU7DPJNLUTYHUB5U6VR6EQMJF/"&gt;proposed the PEP to
python-dev&lt;/a&gt;.
This PEP is my 3rd attempt to fix the C API: I rewrote it from scratch. Python
now distributes a new &lt;tt class="docutils literal"&gt;pythoncapi_compat.h&lt;/tt&gt; header and a process is defined
to reduce the number of broken C extensions when introducing C API incompatible
changes listed in this PEP.&lt;/p&gt;
&lt;p&gt;I created the &lt;a class="reference external" href="https://github.com/pythoncapi/pythoncapi_compat"&gt;pythoncapi_compat project&lt;/a&gt;: header file providing new
C API functions to old Python versions using static inline functions.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="december"&gt;
&lt;h3&gt;December&lt;/h3&gt;
&lt;p&gt;I wrote a new &lt;tt class="docutils literal"&gt;upgrade_pythoncapi.py&lt;/tt&gt; script to add Python 3.10
support to an extension module without losing support with Python 2.7.  I sent
&lt;a class="reference external" href="https://mail.python.org/archives/list/capi-sig&amp;#64;python.org/thread/LFLXFMKMZ77UCDUFD5EQCONSAFFWJWOZ/"&gt;New script: add Python 3.10 support to your C extensions without losing Python
3.6 support&lt;/a&gt;
to the capi-sig list.&lt;/p&gt;
&lt;p&gt;The pythoncapi_compat project got its first users (bitarray, immutables,
python-zstandard)! It proves that the project is useful and needed.&lt;/p&gt;
&lt;p&gt;I collaborated with the HPy project to create a manifesto explaining how the C
API prevents to optimize CPython and makes the CPython C API inefficient on
PyPy. It is still a draft.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="cpython"></category><category term="optimization"></category><category term="cpython"></category><category term="c-api"></category></entry><entry><title>Leaks discovered by subinterpreters</title><link href="https://vstinner.github.io/subinterpreter-leaks.html" rel="alternate"></link><published>2020-12-23T14:00:00+01:00</published><updated>2020-12-23T14:00:00+01:00</updated><author><name>Victor Stinner</name></author><id>tag:vstinner.github.io,2020-12-23:/subinterpreter-leaks.html</id><summary type="html">&lt;p&gt;This article is about old reference leaks discovered or caused by the work on
isolating subinterpreters: leaks in 6 different modules (gc, _weakref, _abc,
_signal, _ast and _thread).&lt;/p&gt;
&lt;img alt="_thread GC bug" src="https://vstinner.github.io/images/thread_gc_bug.jpg" /&gt;
&lt;div class="section" id="refleaks-buildbot-failures"&gt;
&lt;h2&gt;Refleaks buildbot failures&lt;/h2&gt;
&lt;p&gt;With my work on isolating subinterpreters, old bugs about Python objects leaked
at Python exit are suddenly becoming blocker …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;This article is about old reference leaks discovered or caused by the work on
isolating subinterpreters: leaks in 6 different modules (gc, _weakref, _abc,
_signal, _ast and _thread).&lt;/p&gt;
&lt;img alt="_thread GC bug" src="https://vstinner.github.io/images/thread_gc_bug.jpg" /&gt;
&lt;div class="section" id="refleaks-buildbot-failures"&gt;
&lt;h2&gt;Refleaks buildbot failures&lt;/h2&gt;
&lt;p&gt;With my work on isolating subinterpreters, old bugs about Python objects leaked
at Python exit are suddenly becoming blocker issues on buildbots.&lt;/p&gt;
&lt;p&gt;When subinterpreters still share Python objects with the main interpreter, it
is ok-ish to leak these objects at Python exit. Right now (current master
branch), there are still more than 18 000 Python objects which are not
destroyed at Python exit:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ./python -X showrefcount -c pass
[18411 refs, 6097 blocks]
&lt;/pre&gt;
&lt;p&gt;This issue is being solved in the &lt;a class="reference external" href="https://bugs.python.org/issue1635741"&gt;bpo-1635741: Py_Finalize() doesn't clear all
Python objects at exit&lt;/a&gt; which was
opened almost 14 years ago (2007).&lt;/p&gt;
&lt;p&gt;When subinterpreters are better isolated, objects are no longer shared, and
suddenly these leaks make subinterpreters tests failing on Refleak buildbots.
For example, when an extension module is converted to the multiphase
initialization API (PEP 489) or when static types are converted to heap types,
these issues pop up.&lt;/p&gt;
&lt;p&gt;It is a blocker issue for me, since I care of having only &amp;quot;green&amp;quot; buildbots (no
test failure), otherwise more serious regressions can be easily missed.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="per-interpreter-gc-state"&gt;
&lt;h2&gt;Per-interpreter GC state&lt;/h2&gt;
&lt;p&gt;In November 2019, I made the state of the GC module per-interpreter in
&lt;a class="reference external" href="https://bugs.python.org/issue36854"&gt;bpo-36854&lt;/a&gt;
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/7247407c35330f3f6292f1d40606b7ba6afd5700"&gt;commit&lt;/a&gt;)
and test_atexit started to leak:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ./python -m test -R 3:3 test_atexit -m test.test_atexit.SubinterpreterTest.test_callbacks_leak
test_atexit leaked [3988, 3986, 3988] references, sum=11962
&lt;/pre&gt;
&lt;p&gt;I fixed the usage of the &lt;tt class="docutils literal"&gt;PyModule_AddObject()&lt;/tt&gt; function in the &lt;tt class="docutils literal"&gt;_testcapi&lt;/tt&gt;
module (&lt;a class="reference external" href="https://github.com/python/cpython/commit/310e2d25170a88ef03f6fd31efcc899fe062da2c"&gt;commit&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;I also pushed a &lt;strong&gt;workaround&lt;/strong&gt; in &lt;tt class="docutils literal"&gt;finalize_interp_clear()&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
+    /* bpo-36854: Explicitly clear the codec registry
+       and trigger a GC collection */
+    PyInterpreterState *interp = tstate-&amp;gt;interp;
+    Py_CLEAR(interp-&amp;gt;codec_search_path);
+    Py_CLEAR(interp-&amp;gt;codec_search_cache);
+    Py_CLEAR(interp-&amp;gt;codec_error_registry);
+    _PyGC_CollectNoFail();
&lt;/pre&gt;
&lt;p&gt;I dislike having to push a &amp;quot;temporary&amp;quot; workaround, but the Python finalization
is really complex and fragile. Fixing the root issues would require too much
work, whereas I wanted to repair the Refleak buildbots as soon as possible.&lt;/p&gt;
&lt;p&gt;In December 2019, the workaround was partially removed (&lt;a class="reference external" href="https://github.com/python/cpython/commit/ac0e1c2694bc199dbd073312145e3c09bee52cc4"&gt;commit&lt;/a&gt;):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
-    Py_CLEAR(interp-&amp;gt;codec_search_path);
-    Py_CLEAR(interp-&amp;gt;codec_search_cache);
-    Py_CLEAR(interp-&amp;gt;codec_error_registry);
&lt;/pre&gt;
&lt;p&gt;The year after (December 2020), the last GC collection was moved into
&lt;tt class="docutils literal"&gt;PyInterpreterState_Clear()&lt;/tt&gt;, before finalizating the GC (&lt;a class="reference external" href="https://github.com/python/cpython/commit/eba5bf2f5672bf4861c626937597b85ac0c242b9"&gt;commit&lt;/a&gt;).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="port-weakref-to-multiphase-init"&gt;
&lt;h2&gt;Port _weakref to multiphase init&lt;/h2&gt;
&lt;p&gt;In March 2020, the &lt;tt class="docutils literal"&gt;_weakref&lt;/tt&gt; module was ported to the multiphase
initialization API (PEP 489) in &lt;a class="reference external" href="https://bugs.python.org/issue40050"&gt;bpo-40050&lt;/a&gt; and test_importlib started to leak:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ./python -m test -R 3:3 test_importlib
test_importlib leaked [6303, 6299, 6303] references, sum=18905
&lt;/pre&gt;
&lt;p&gt;The analysis was quite long and complicated. The importlib imported some
extension modules twice and it has to inject frozen modules to &amp;quot;bootstrap&amp;quot; the
code.&lt;/p&gt;
&lt;p&gt;At the end, I fixed the issue by removing the now unused &lt;tt class="docutils literal"&gt;_weakref&lt;/tt&gt; import in
&lt;tt class="docutils literal"&gt;importlib._bootstrap_external&lt;/tt&gt;
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/83d46e0622d2efdf5f3bf8bf8904d0dcb55fc322"&gt;commit&lt;/a&gt;).
The fix also avoids importing an extension module twice.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="convert-abc-static-types-to-heap-types"&gt;
&lt;h2&gt;Convert _abc static types to heap types&lt;/h2&gt;
&lt;p&gt;In April 2020, the static types of the &lt;tt class="docutils literal"&gt;_abc&lt;/tt&gt; extension module were converted
to heap types in &lt;a class="reference external" href="https://bugs.python.org/issue40077"&gt;bpo-40077&lt;/a&gt;
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/53e4c91725083975598350877e2ed8e2d0194114"&gt;commit&lt;/a&gt;) and
test_threading started to leak:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ./python -m test -R 3:3 test_threading
test_threading leaked [19, 19, 19] references, sum=57
&lt;/pre&gt;
&lt;p&gt;I created &lt;a class="reference external" href="https://bugs.python.org/issue40149"&gt;bpo-40149&lt;/a&gt; to track the leak.&lt;/p&gt;
&lt;div class="section" id="objects-hold-a-reference-to-heap-types"&gt;
&lt;h3&gt;Objects hold a reference to heap types&lt;/h3&gt;
&lt;p&gt;In March 2019, the &lt;tt class="docutils literal"&gt;PyObject_Init()&lt;/tt&gt; function was modified in &lt;a class="reference external" href="https://bugs.python.org/issue35810"&gt;bpo-35810&lt;/a&gt; to keep a strong reference (&lt;tt class="docutils literal"&gt;INCREF&lt;/tt&gt;)
to the type if the type is a heap type
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/364f0b0f19cc3f0d5e63f571ec9163cf41c62958"&gt;commit&lt;/a&gt;):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
+    if (PyType_GetFlags(tp) &amp;amp; Py_TPFLAGS_HEAPTYPE) {
+        Py_INCREF(tp);
+    }
&lt;/pre&gt;
&lt;p&gt;I opened &lt;a class="reference external" href="https://bugs.python.org/issue40217"&gt;bpo-40217: The garbage collector doesn't take in account that objects
of heap allocated types hold a strong reference to their type&lt;/a&gt; to discuss the regression
(the test_threading leak).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="first-workaround-not-merged-force-a-second-garbage-collection"&gt;
&lt;h3&gt;First workaround (not merged): force a second garbage collection&lt;/h3&gt;
&lt;p&gt;While analysing test_threading regression leak, I identified a first
workaround: add a second &lt;tt class="docutils literal"&gt;_PyGC_CollectNoFail()&lt;/tt&gt; call in
&lt;tt class="docutils literal"&gt;finalize_interp_clear()&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;It was only a workaround which helped to understand the issue, it was not
merged.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="first-fix-merged-abc-data-traverse"&gt;
&lt;h3&gt;First fix (merged): abc_data_traverse()&lt;/h3&gt;
&lt;p&gt;I merged a first fix: add a traverse function to the &lt;tt class="docutils literal"&gt;_abc._abc_data&lt;/tt&gt; type
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/9cc3ebd7e04cb645ac7b2f372eaafa7464e16b9c"&gt;commit&lt;/a&gt;):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
+static int
+abc_data_traverse(_abc_data *self, visitproc visit, void *arg)
+{
+    Py_VISIT(self-&amp;gt;_abc_registry);
+    Py_VISIT(self-&amp;gt;_abc_cache);
+    Py_VISIT(self-&amp;gt;_abc_negative_cache);
+    return 0;
+}
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="second-workaround-not-merged-visit-the-type-in-abc-data-traverse"&gt;
&lt;h3&gt;Second workaround (not merged): visit the type in abc_data_traverse()&lt;/h3&gt;
&lt;p&gt;A second workaround was identified: add &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;Py_VISIT(Py_TYPE(self));&lt;/span&gt;&lt;/tt&gt; to
the new &lt;tt class="docutils literal"&gt;abc_data_traverse()&lt;/tt&gt; function.&lt;/p&gt;
&lt;p&gt;Again, it was only a workaround which helped to understand the issue, but it
was not merged.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="second-fix-merged-call-py-visit-py-type-self-automatically"&gt;
&lt;h3&gt;Second fix (merged): call Py_VISIT(Py_TYPE(self)) automatically&lt;/h3&gt;
&lt;p&gt;20 days after I opened &lt;a class="reference external" href="https://bugs.python.org/issue40217"&gt;bpo-40217&lt;/a&gt;,
&lt;strong&gt;Pablo Galindo&lt;/strong&gt; modified &lt;tt class="docutils literal"&gt;PyType_FromSpec()&lt;/tt&gt; to add a wrapper around the
traverse function of heap types to ensure that &lt;tt class="docutils literal"&gt;Py_VISIT(Py_TYPE(self))&lt;/tt&gt; is
always called (&lt;a class="reference external" href="https://github.com/python/cpython/commit/0169d3003be3d072751dd14a5c84748ab63a249f"&gt;commit&lt;/a&gt;).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="last-fix-merged-fix-every-traverse-function"&gt;
&lt;h3&gt;Last fix (merged): fix every traverse function&lt;/h3&gt;
&lt;p&gt;In May 2020, &lt;strong&gt;Pablo Galindo&lt;/strong&gt; changed his mind. He reverted his
&lt;tt class="docutils literal"&gt;PyType_FromSpec()&lt;/tt&gt; change and instead fixed traverse function of heap types
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/1cf15af9a6f28750f37b08c028ada31d38e818dd"&gt;commit&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;At the end, &lt;tt class="docutils literal"&gt;abc_data_traverse()&lt;/tt&gt; calls &lt;tt class="docutils literal"&gt;Py_VISIT(Py_TYPE(self))&lt;/tt&gt;. The
second &amp;quot;workaround&amp;quot; was the correct fix!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="convert-signal-to-multiphase-init"&gt;
&lt;h2&gt;Convert _signal to multiphase init&lt;/h2&gt;
&lt;p&gt;In September 2020, &lt;strong&gt;Mohamed Koubaa&lt;/strong&gt; ported the &lt;tt class="docutils literal"&gt;_signal&lt;/tt&gt; module to the
multiphase initialization API (PEP 489) in &lt;a class="reference external" href="https://bugs.python.org/issue1635741"&gt;bpo-1635741&lt;/a&gt; (&lt;a class="reference external" href="https://github.com/python/cpython/commit/71d1bd9569c8a497e279f2fea6fe47cd70a87ea3"&gt;commit 71d1bd95&lt;/a&gt;)
and test_interpreters started to leak:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ./python -m test -R 3:3 test_interpreters
test_interpreters leaked [237, 237, 237] references, sum=711
&lt;/pre&gt;
&lt;p&gt;I created &lt;a class="reference external" href="https://bugs.python.org/issue41713"&gt;bpo-41713&lt;/a&gt; to track the
regression. Since I failed to find a simple fix, I started by reverting the
change which caused Refleak buildbots to fail (&lt;a class="reference external" href="https://github.com/python/cpython/commit/4b8032e5a4994a7902076efa72fca1e2c85d8b7f"&gt;commit&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;I had to refactor the &lt;tt class="docutils literal"&gt;_signal&lt;/tt&gt; extension module code with multiple commits
to fix all bugs.&lt;/p&gt;
&lt;p&gt;The first fix was to remove the &lt;tt class="docutils literal"&gt;IntHandler&lt;/tt&gt; variable: there was no need to
keep it alive, it was only needed once in &lt;tt class="docutils literal"&gt;signal_module_exec()&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;The second fix is to close the Windows event at exit:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
+ #ifdef MS_WINDOWS
+     if (sigint_event != NULL) {
+         CloseHandle(sigint_event);
+         sigint_event = NULL;
+     }
+ #endif
&lt;/pre&gt;
&lt;p&gt;The last fix, the most important, is to clear the strong reference to old
Python signal handlers when &lt;tt class="docutils literal"&gt;signal_module_exec()&lt;/tt&gt; is called more than once:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
// If signal_module_exec() is called more than one, we must
// clear the strong reference to the previous function.
Py_XSETREF(Handlers[signum].func, Py_NewRef(func));
&lt;/pre&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;_signal&lt;/tt&gt; module is not well isolated for subinterpreters yet, but at
least it no longer leaks.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="per-interpreter-ast-state"&gt;
&lt;h2&gt;Per-interpreter _ast state&lt;/h2&gt;
&lt;p&gt;In September 2019, the &lt;tt class="docutils literal"&gt;_ast&lt;/tt&gt; extension module was converted to PEP 384
(stable ABI) in &lt;a class="reference external" href="https://bugs.python.org/issue38113"&gt;bpo-38113&lt;/a&gt; (&lt;a class="reference external" href="https://github.com/python/cpython/commit/ac46eb4ad6662cf6d771b20d8963658b2186c48c"&gt;commit&lt;/a&gt;):
the AST state moves into a module state.&lt;/p&gt;
&lt;p&gt;This change caused 3 different bugs including crashes (&lt;a class="reference external" href="https://bugs.python.org/issue41194"&gt;bpo-41194&lt;/a&gt;, &lt;a class="reference external" href="https://bugs.python.org/issue41261"&gt;bpo-41261&lt;/a&gt;, &lt;a class="reference external" href="https://bugs.python.org/issue41631"&gt;bpo-41631&lt;/a&gt;). The issue is complex since there are
public C APIs which require to access AST types, whereas it became possible to
have multiple &lt;tt class="docutils literal"&gt;_ast&lt;/tt&gt; extension module instances.&lt;/p&gt;
&lt;p&gt;In July 2020, I fixed the root issue in &lt;a class="reference external" href="https://bugs.python.org/issue41194"&gt;bpo-41194&lt;/a&gt; by replacing the module state with a
global state (&lt;a class="reference external" href="https://github.com/python/cpython/commit/91e1bc18bd467a13bceb62e16fbc435b33381c82"&gt;commit&lt;/a&gt;):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static astmodulestate global_ast_state;
&lt;/pre&gt;
&lt;p&gt;A global state is bad for subinterpreters. In November 2020, I made the AST
state per-interpreter in &lt;a class="reference external" href="https://bugs.python.org/issue41796"&gt;bpo-41796&lt;/a&gt;
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/5cf4782a2630629d0978bf4cf6b6340365f449b2"&gt;commit&lt;/a&gt;
and test_ast started to leak:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ./python -m test -R 3:3 test_ast
test_ast leaked [23640, 23636, 23640] references, sum=70916
&lt;/pre&gt;
&lt;p&gt;The fix is to call &lt;tt class="docutils literal"&gt;_PyAST_Fini()&lt;/tt&gt; earlier (&lt;a class="reference external" href="https://github.com/python/cpython/commit/fd957c124c44441d9c5eaf61f7af8cf266bafcb1"&gt;commit&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Python types contain a reference to themselves in in their
&lt;tt class="docutils literal"&gt;PyTypeObject.tp_mro&lt;/tt&gt; member (the MRO tuple: Method Resolution Order).
&lt;tt class="docutils literal"&gt;_PyAST_Fini()&lt;/tt&gt; must called before the last GC collection to destroy AST
types.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;_PyInterpreterState_Clear()&lt;/tt&gt; now calls &lt;tt class="docutils literal"&gt;_PyAST_Fini()&lt;/tt&gt;. It now also
calls &lt;tt class="docutils literal"&gt;_PyWarnings_Fini()&lt;/tt&gt; on subinterpeters, not only on the main
interpreter.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="thread-lock-traverse"&gt;
&lt;h2&gt;_thread lock traverse&lt;/h2&gt;
&lt;p&gt;In December 2020, while I tried to port the &lt;tt class="docutils literal"&gt;_thread&lt;/tt&gt; extesnion module to the multiphase initialization API
(PEP 489), test_threading started to leak:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ./python -m test -R 3:3 test_threading
test_threading leaked [56, 56, 56] references, sum=168
&lt;/pre&gt;
&lt;p&gt;As usual, the workaround was to force a second GC collection in &lt;tt class="docutils literal"&gt;interpreter_clear()&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
     /* Last garbage collection on this interpreter */
     _PyGC_CollectNoFail(tstate);
+    _PyGC_CollectNoFail(tstate);
     _PyGC_Fini(tstate);
&lt;/pre&gt;
&lt;p&gt;It took me two days to full understand the problem. I drew reference cycles
on paper to help me to understand the problem:&lt;/p&gt;
&lt;img alt="_thread GC bug" src="https://vstinner.github.io/images/thread_gc_bug.jpg" /&gt;
&lt;p&gt;There are two cycles:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Cycle 1:&lt;ul&gt;
&lt;li&gt;at fork function&lt;/li&gt;
&lt;li&gt;-&amp;gt; __main__ module dict&lt;/li&gt;
&lt;li&gt;-&amp;gt; at fork function&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Cycle 2:&lt;ul&gt;
&lt;li&gt;_thread lock type&lt;/li&gt;
&lt;li&gt;-&amp;gt; lock type methods&lt;/li&gt;
&lt;li&gt;-&amp;gt; _thread module dict&lt;/li&gt;
&lt;li&gt;-&amp;gt; _thread local type&lt;/li&gt;
&lt;li&gt;-&amp;gt; _thread module&lt;/li&gt;
&lt;li&gt;-&amp;gt; _thread module state&lt;/li&gt;
&lt;li&gt;-&amp;gt; _thread lock type&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Moreover, there is a link between these two reference cycles: an instance of
the lock type.&lt;/p&gt;
&lt;p&gt;I fixed the issue by adding a traverse function to the lock type and add
&lt;tt class="docutils literal"&gt;Py_TPFLAGS_HAVE_GC&lt;/tt&gt; flag to the type (&lt;a class="reference external" href="https://github.com/python/cpython/commit/6104013838e181e3c698cb07316f449a0c31ea96"&gt;commit&lt;/a&gt;):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
+static int
+lock_traverse(lockobject *self, visitproc visit, void *arg)
+{
+    Py_VISIT(Py_TYPE(self));
+    return 0;
+}
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="notes-on-weird-gc-bugs"&gt;
&lt;h2&gt;Notes on weird GC bugs&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;gc.get_referents()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;gc.get_referrers()&lt;/tt&gt; can be used to check
traverse functions.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;gc.is_tracked()&lt;/tt&gt; can be used to check if the GC tracks an object.&lt;/li&gt;
&lt;li&gt;Using the &lt;tt class="docutils literal"&gt;gdb&lt;/tt&gt; debugger on &lt;tt class="docutils literal"&gt;gc_collect_main()&lt;/tt&gt; helps to see which
objects are collected. See for example the &lt;tt class="docutils literal"&gt;finalize_garbage()&lt;/tt&gt; functions
which calls finalizers on unreachable objects.&lt;/li&gt;
&lt;li&gt;The solution is usually a missing traverse functions or a missing
&lt;tt class="docutils literal"&gt;Py_VISIT()&lt;/tt&gt; in an existing traverse function.&lt;/li&gt;
&lt;li&gt;GC bugs are hard to debug :-)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Thanks &lt;strong&gt;Pablo Galindo&lt;/strong&gt; for helping me to debug all these tricky GC bugs!&lt;/p&gt;
&lt;p&gt;Thanks to everybody who are helping to better isolate subintrepreters by
converting extension modules to the multiphase initialization API (PEP 489) and
by converting dozens of static types to heap types. We made huge progresses
last months!&lt;/p&gt;
&lt;/div&gt;
</content><category term="cpython"></category><category term="cpython"></category><category term="subinterpreters"></category></entry><entry><title>GIL bugfixes for daemon threads in Python 3.9</title><link href="https://vstinner.github.io/gil-bugfixes-daemon-threads-python39.html" rel="alternate"></link><published>2020-04-04T22:00:00+02:00</published><updated>2020-04-04T22:00:00+02:00</updated><author><name>Victor Stinner</name></author><id>tag:vstinner.github.io,2020-04-04:/gil-bugfixes-daemon-threads-python39.html</id><summary type="html">&lt;a class="reference external image-reference" href="https://twitter.com/Bouletcorp/status/1241018332112998401"&gt;&lt;img alt="`#CoronaMaison by Boulet" src="https://vstinner.github.io/images/coronamaison_boulet.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;My previous article &lt;a class="reference external" href="https://vstinner.github.io/daemon-threads-python-finalization-python32.html"&gt;Daemon threads and the Python finalization in Python 3.2 and 3.3&lt;/a&gt; introduces
issues caused by daemon threads in the Python finalization and past changes to
make them work.&lt;/p&gt;
&lt;p&gt;This article is about bugfixes of the infamous GIL (Global Interpreter Lock) in
Python 3.9, between …&lt;/p&gt;</summary><content type="html">&lt;a class="reference external image-reference" href="https://twitter.com/Bouletcorp/status/1241018332112998401"&gt;&lt;img alt="`#CoronaMaison by Boulet" src="https://vstinner.github.io/images/coronamaison_boulet.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;My previous article &lt;a class="reference external" href="https://vstinner.github.io/daemon-threads-python-finalization-python32.html"&gt;Daemon threads and the Python finalization in Python 3.2 and 3.3&lt;/a&gt; introduces
issues caused by daemon threads in the Python finalization and past changes to
make them work.&lt;/p&gt;
&lt;p&gt;This article is about bugfixes of the infamous GIL (Global Interpreter Lock) in
Python 3.9, between March 2019 and March 2020, for daemon threads during Python
finalization. Some bugs were old: up to 6 years old. Some bugs were triggered
by the on-going work on isolating subinterpreters in Python 3.9.&lt;/p&gt;
&lt;p&gt;Drawing: &lt;a class="reference external" href="https://twitter.com/Bouletcorp/status/1241018332112998401"&gt;#CoronaMaison by Boulet&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="fix-1-exit-pyeval-acquirethread-if-finalizing"&gt;
&lt;h2&gt;Fix 1: Exit PyEval_AcquireThread() if finalizing&lt;/h2&gt;
&lt;p&gt;In March 2019, &lt;strong&gt;Remy Noel&lt;/strong&gt; created &lt;a class="reference external" href="https://bugs.python.org/issue36469"&gt;bpo-36469&lt;/a&gt;: a multithreaded Python application
using 20 daemon threads hangs randomly at exit on Python 3.5:&lt;/p&gt;
&lt;blockquote&gt;
The bug happens about once every two weeks on a script that is fired more
than 10K times a day.&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Eric Snow&lt;/strong&gt; analyzed the bug and understood that it is related to daemon
threads and Python finalization. He identified that &lt;tt class="docutils literal"&gt;PyEval_AcquireLock()&lt;/tt&gt;
and &lt;tt class="docutils literal"&gt;PyEval_AcquireThread()&lt;/tt&gt; function take the GIL but don't exit the thread
if Python is finalizing.&lt;/p&gt;
&lt;p&gt;When Python is finalizing and a daemon thread takes the GIL, Python can hang
randomly.&lt;/p&gt;
&lt;p&gt;Eric created &lt;a class="reference external" href="https://bugs.python.org/issue36475"&gt;bpo-36475&lt;/a&gt; to propose to
modify &lt;tt class="docutils literal"&gt;PyEval_AcquireLock()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;PyEval_AcquireThread()&lt;/tt&gt; to also exit
the thread in this case. In April 2019, &lt;strong&gt;Joannah Nanjekye&lt;/strong&gt; fixed the issue
with &lt;a class="reference external" href="https://github.com/python/cpython/commit/f781d202a2382731b43bade845a58d28a02e9ea1"&gt;commit f781d202&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
bpo-36475: Finalize PyEval_AcquireLock() and PyEval_AcquireThread() properly (GH-12667)

PyEval_AcquireLock() and PyEval_AcquireThread() now
terminate the current thread if called while the interpreter is
finalizing, making them consistent with PyEval_RestoreThread(),
Py_END_ALLOW_THREADS, and PyGILState_Ensure().
&lt;/pre&gt;
&lt;p&gt;The fix adds &lt;tt class="docutils literal"&gt;exit_thread_if_finalizing()&lt;/tt&gt; function which exit the thread if
Python is finalizing. This function is called after each &lt;tt class="docutils literal"&gt;take_gil()&lt;/tt&gt; call.&lt;/p&gt;
&lt;p&gt;The fix is very similar to &lt;tt class="docutils literal"&gt;PyEval_RestoreThread()&lt;/tt&gt; fix made in 2013 (&lt;a class="reference external" href="https://github.com/python/cpython/commit/0d5e52d3469a310001afe50689f77ddba6d554d1"&gt;commit
0d5e52d3&lt;/a&gt;)
to fix &lt;a class="reference external" href="https://bugs.python.org/issue1856#msg60014"&gt;bpo-1856&lt;/a&gt; (Python crash
involving daemon threads during Python exit).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="fix-2-pyeval-restorethread-on-freed-tstate"&gt;
&lt;h2&gt;Fix 2: PyEval_RestoreThread() on freed tstate&lt;/h2&gt;
&lt;div class="section" id="concurrent-futures-crash-on-freebsd"&gt;
&lt;h3&gt;concurrent.futures crash on FreeBSD&lt;/h3&gt;
&lt;p&gt;In December 2019, I reported &lt;a class="reference external" href="https://bugs.python.org/issue39088"&gt;bpo-39088&lt;/a&gt;:
test_concurrent_futures &lt;strong&gt;crashed randomly&lt;/strong&gt; with a coredump on AMD64 FreeBSD
Shared 3.x buildbot. In March 2020, I succeeded to reproduce the bug on FreeBSD
and I was able to debug the coredump in gdb:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
(gdb) frame
#0  0x00000000003b518c in PyEval_RestoreThread (tstate=0x801f23790) at Python/ceval.c:387
387         _PyRuntimeState *runtime = tstate-&amp;gt;interp-&amp;gt;runtime;

(gdb) p tstate-&amp;gt;interp
$3 = (PyInterpreterState *) 0xdddddddddddddddd
&lt;/pre&gt;
&lt;p&gt;The Python thread state (&lt;tt class="docutils literal"&gt;tstate&lt;/tt&gt;) was freed. In debug mode, the &amp;quot;free()&amp;quot;
function of the Python memory allocator fills the freed memory block with
&lt;tt class="docutils literal"&gt;0xDD&lt;/tt&gt; byte pattern (&lt;tt class="docutils literal"&gt;D&lt;/tt&gt; stands for dead byte) to detect usage of freed
memory.&lt;/p&gt;
&lt;p&gt;The problem is that Python finalization already freed the memory of all
PyThreadState structures, when &lt;tt class="docutils literal"&gt;PyEval_RestoreThread(tstate)&lt;/tt&gt; is called by a
daemon thread. &lt;tt class="docutils literal"&gt;PyEval_RestoreThread()&lt;/tt&gt; dereferences &lt;tt class="docutils literal"&gt;tstate&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
_PyRuntimeState *runtime = tstate-&amp;gt;interp-&amp;gt;runtime;
&lt;/pre&gt;
&lt;p&gt;This bug is a regression caused by my change:
&lt;a class="reference external" href="https://github.com/python/cpython/commit/01b1cc12e7c6a3d6a3d27ba7c731687d57aae92a"&gt;Add PyInterpreterState.runtime field&lt;/a&gt;
of &lt;a class="reference external" href="https://bugs.python.org/issue36710"&gt;bpo-36710&lt;/a&gt;. I replaced:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
void PyEval_RestoreThread(PyThreadState *tstate) {
    _PyRuntimeState *runtime = &amp;amp;_PyRuntime;
    ...
}
&lt;/pre&gt;
&lt;p&gt;with:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
void PyEval_RestoreThread(PyThreadState *tstate) {
    _PyRuntimeState *runtime = tstate-&amp;gt;interp-&amp;gt;runtime;
    ...
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="fix-pyeval-restorethread-for-daemon-threads"&gt;
&lt;h3&gt;Fix PyEval_RestoreThread() for daemon threads&lt;/h3&gt;
&lt;p&gt;I created &lt;a class="reference external" href="https://bugs.python.org/issue39877"&gt;bpo-39877&lt;/a&gt; to investigate
this bug. I managed to reproduce the crash on Linux with a script spawning
daemon threads which sleep randomly between 0.0 and 1.0 second, and by adding
&lt;tt class="docutils literal"&gt;sleep(1);&lt;/tt&gt; call at &lt;tt class="docutils literal"&gt;Py_RunMain()&lt;/tt&gt; exit.&lt;/p&gt;
&lt;p&gt;I wrote a &lt;tt class="docutils literal"&gt;PyEval_RestoreThread()&lt;/tt&gt; fix which access to
&lt;tt class="docutils literal"&gt;_PyRuntimeState.finalizing&lt;/tt&gt; without the GIL.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Antoine Pitrou&lt;/strong&gt; asked me to convert &lt;tt class="docutils literal"&gt;_PyRuntimeState.finalizing&lt;/tt&gt; to an
atomic variable to avoid inconsistencies in case of parallel accesses. At March
7, 2020, I pushed &lt;a class="reference external" href="https://github.com/python/cpython/commit/7b3c252dc7f44d4bdc4c7c82d225ebd09c78f520"&gt;commit 7b3c252d&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
bpo-39877: _PyRuntimeState.finalizing becomes atomic (GH-18816)

Convert _PyRuntimeState.finalizing field to an atomic variable:

* Rename it to _finalizing
* Change its type to _Py_atomic_address
* Add _PyRuntimeState_GetFinalizing() and _PyRuntimeState_SetFinalizing()
  functions
* Remove _Py_CURRENTLY_FINALIZING() function: replace it with testing
  directly _PyRuntimeState_GetFinalizing() value

Convert _PyRuntimeState_GetThreadState() to static inline function.
&lt;/pre&gt;
&lt;p&gt;The day after, I pushed my fix, &lt;a class="reference external" href="https://github.com/python/cpython/commit/eb4e2ae2b8486e8ee4249218b95d94a9f0cc513e"&gt;commit eb4e2ae2&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
bpo-39877: Fix PyEval_RestoreThread() for daemon threads (GH-18811)

* exit_thread_if_finalizing() does now access directly _PyRuntime
  variable, rather than using tstate-&amp;gt;interp-&amp;gt;runtime since tstate
  can be a dangling pointer after Py_Finalize() has been called.
* exit_thread_if_finalizing() is now called *before* calling
  take_gil(). _PyRuntime.finalizing is an atomic variable,
  we don't need to hold the GIL to access it.
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;exit_thread_if_finalizing()&lt;/tt&gt; is now called &lt;strong&gt;before&lt;/strong&gt; &lt;tt class="docutils literal"&gt;take_gil()&lt;/tt&gt; to
ensure that &lt;tt class="docutils literal"&gt;take_gil()&lt;/tt&gt; cannot be called with an invalid Python thread state
(&lt;tt class="docutils literal"&gt;tstate&lt;/tt&gt;).&lt;/p&gt;
&lt;p&gt;I commented &lt;em&gt;naively&lt;/em&gt;:&lt;/p&gt;
&lt;blockquote&gt;
Ok, it should now be fixed.&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="clear-python-thread-states-earlier-my-first-failed-attempt-in-2013"&gt;
&lt;h2&gt;Clear Python thread states earlier: my first failed attempt in 2013&lt;/h2&gt;
&lt;p&gt;In 2013, I opened &lt;a class="reference external" href="https://bugs.python.org/issue19466"&gt;bpo-19466&lt;/a&gt; to clear
earlier the Python thread state of threads during Python finalization. My
intent was to display &lt;tt class="docutils literal"&gt;ResourceWarning&lt;/tt&gt; warnings of daemon threads as well.
In November 2013, I pushed &lt;a class="reference external" href="https://github.com/python/cpython/commit/45956b9a33af634a2919ade64c1dd223ab2d5235"&gt;commit 45956b9a&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Close #19466: Clear the frames of daemon threads earlier during the Python
shutdown to call objects destructors. So &amp;quot;unclosed file&amp;quot; resource warnings
are now correctly emitted for daemon threads.
&lt;/pre&gt;
&lt;p&gt;Later, I discovered a crash in the the garbage collector while trying to
reproduce a race condition in asyncio: I created &lt;a class="reference external" href="https://bugs.python.org/issue20526"&gt;bpo-20526&lt;/a&gt;. Sadly, this bug was trigger by my
previous change. I decided that it's safer to revert my change.&lt;/p&gt;
&lt;p&gt;By the way, when I looked again at &lt;a class="reference external" href="https://bugs.python.org/issue20526"&gt;bpo-20526&lt;/a&gt;, I was able to reproduce again the
garbage collector bug, likely because of recent changes. With the help of
&lt;strong&gt;Pablo Galindo Salgado&lt;/strong&gt;, Pablo and me &lt;a class="reference external" href="https://bugs.python.org/issue20526#msg364851"&gt;understood the root issue&lt;/a&gt;.  At March 24, 2020, I pushed
a fix (&lt;a class="reference external" href="https://github.com/python/cpython/commit/5804f878e779712e803be927ca8a6df389d82cdf"&gt;commit&lt;/a&gt;)
to finally fix this 6 years old bug! The fix removes the following line from
&lt;tt class="docutils literal"&gt;PyThreadState_Clear()&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Py_CLEAR(tstate-&amp;gt;frame);
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="fix-3-exit-also-take-gil-at-exit-point-if-finalizing"&gt;
&lt;h2&gt;Fix 3: Exit also take_gil() at exit point if finalizing&lt;/h2&gt;
&lt;p&gt;After fixing &lt;tt class="docutils literal"&gt;PyEval_RestoreThread()&lt;/tt&gt;, I decided to attempt again to fix
&lt;a class="reference external" href="https://bugs.python.org/issue19466"&gt;bpo-19466&lt;/a&gt; (clear earlier Python thread
states). Sadly, I discovered that my &lt;tt class="docutils literal"&gt;PyEval_RestoreThread()&lt;/tt&gt; fix
&lt;strong&gt;introduced a race condition&lt;/strong&gt;!&lt;/p&gt;
&lt;p&gt;While the main thread finalizes Python, daemon threads can be waiting for the
GIL: they block in &lt;tt class="docutils literal"&gt;take_gil()&lt;/tt&gt;. When the main thread releases the GIL during
finalization, a daemon thread take the GIL instead of exiting. Daemon threads
only check if they must exit &lt;strong&gt;before&lt;/strong&gt; trying to take the GIL.&lt;/p&gt;
&lt;p&gt;The solution is to call &lt;tt class="docutils literal"&gt;exit_thread_if_finalizing()&lt;/tt&gt; twice in
&lt;tt class="docutils literal"&gt;take_gil()&lt;/tt&gt;: before &lt;strong&gt;and&lt;/strong&gt; after taking the GIL.&lt;/p&gt;
&lt;p&gt;In March 2020, I pushed &lt;a class="reference external" href="https://github.com/python/cpython/commit/9229eeee105f19705f72e553cf066751ac47c7b7"&gt;commit 9229eeee&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
bpo-39877: take_gil() checks tstate_must_exit() twice (GH-18890)

take_gil() now also checks tstate_must_exit() after acquiring
the GIL: exit the thread if Py_Finalize() has been called.
&lt;/pre&gt;
&lt;p&gt;I commented:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I ran multiple times &lt;tt class="docutils literal"&gt;daemon_threads_exit.py&lt;/tt&gt; with &lt;tt class="docutils literal"&gt;slow_exit.patch&lt;/tt&gt;:
no crash.&lt;/p&gt;
&lt;p&gt;I also ran multiple times &lt;tt class="docutils literal"&gt;stress.py&lt;/tt&gt; + &lt;tt class="docutils literal"&gt;sleep_at_exit.patch&lt;/tt&gt; of
bpo-37135: no crash.&lt;/p&gt;
&lt;p&gt;And I tested &lt;tt class="docutils literal"&gt;asyncio_gc.py&lt;/tt&gt; of bpo-19466: no crash neither.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Python finalization now looks reliable.&lt;/strong&gt; I'm not sure if it's &amp;quot;more&amp;quot;
reliable than previously, but at least, I cannot get a crash anymore, even
after bpo-19466 has been fixed (clear Python thread states of daemon
threads earlier).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Funny fact, in June 2019, &lt;strong&gt;Eric Snow&lt;/strong&gt; added a very similar bug in &lt;a class="reference external" href="https://bugs.python.org/issue36818"&gt;bpo-36818&lt;/a&gt; with &lt;a class="reference external" href="https://github.com/python/cpython/commit/396e0a8d9dc65453cb9d53500d0a620602656cfe"&gt;commit 396e0a8d&lt;/a&gt;:
test_multiprocessing_spawn segfault on FreeBSD (&lt;a class="reference external" href="https://bugs.python.org/issue37135"&gt;bpo-37135&lt;/a&gt;). I reverted his change to fix the
issue. At this time, I didn't have the bandwidth to investigate the root cause.
I just reverted Eric's change.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="fix-4-exit-take-gil-while-waiting-for-the-gil-if-finalizing"&gt;
&lt;h2&gt;Fix 4: Exit take_gil() while waiting for the GIL if finalizing&lt;/h2&gt;
&lt;p&gt;While I was working on moving pending calls from &lt;tt class="docutils literal"&gt;_PyRuntime&lt;/tt&gt; to
&lt;tt class="docutils literal"&gt;PyInterpreterState&lt;/tt&gt;, &lt;a class="reference external" href="https://bugs.python.org/issue39984"&gt;bpo-3998&lt;/a&gt;, I had
another bug.&lt;/p&gt;
&lt;p&gt;At March 18, 2020, I pushed a &lt;tt class="docutils literal"&gt;take_gil()&lt;/tt&gt; fix to avoid accessing &lt;tt class="docutils literal"&gt;tstate&lt;/tt&gt;
if Python is finalizing, &lt;a class="reference external" href="https://github.com/python/cpython/commit/29356e03d4f8800b04f799efe7a10e3ce8b16f61"&gt;commit 29356e03&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
bpo-39877: Fix take_gil() for daemon threads (GH-19054)

bpo-39877, bpo-39984: If the thread must exit, don't access tstate to
prevent a potential crash: tstate memory has been freed.
&lt;/pre&gt;
&lt;p&gt;And while working on the inefficient signal handling in multithreaded
applications (&lt;a class="reference external" href="https://bugs.python.org/issue40010"&gt;bpo-40010&lt;/a&gt;), I discovered
that the previous fix was not enough!&lt;/p&gt;
&lt;p&gt;At March 19, 2020, I pushed a &lt;tt class="docutils literal"&gt;take_gil()&lt;/tt&gt; fix to exit while &lt;tt class="docutils literal"&gt;take_gil()&lt;/tt&gt;
is waiting for the GIL if Python is finalizing, &lt;a class="reference external" href="https://github.com/python/cpython/commit/a36adfa6bbf5e612a4d4639124502135690899b8"&gt;commit a36adfa6&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
bpo-39877: 4th take_gil() fix for daemon threads (GH-19080)

bpo-39877, bpo-40010: Add a third tstate_must_exit() check in
take_gil() to prevent using tstate which has been freed.
&lt;/pre&gt;
&lt;p&gt;I can only hope that this fix is the last one to fix all corner cases with
daemon threads in &lt;tt class="docutils literal"&gt;take_gil()&lt;/tt&gt; (&lt;a class="reference external" href="https://bugs.python.org/issue39877"&gt;bpo-39877&lt;/a&gt;)!&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="summary-of-gil-bugfixes"&gt;
&lt;h2&gt;Summary of GIL bugfixes&lt;/h2&gt;
&lt;p&gt;The GIL got 5 main bugfixes for daemon threads and Python finalization:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;May 2011, &lt;strong&gt;Antoine Pitrou&lt;/strong&gt;,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/0d5e52d3469a310001afe50689f77ddba6d554d1"&gt;commit 0d5e52d3&lt;/a&gt;:
&lt;tt class="docutils literal"&gt;take_gil()&lt;/tt&gt; exits if finalizing &lt;strong&gt;after&lt;/strong&gt; taking the GIL (1 check)&lt;/li&gt;
&lt;li&gt;April 2019, &lt;strong&gt;Joannah Nanjekye&lt;/strong&gt;,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/f781d202a2382731b43bade845a58d28a02e9ea1"&gt;commit f781d202&lt;/a&gt;:
PyEval_AcquireLock() and PyEval_AcquireThread() also exit if Python is finalizing&lt;/li&gt;
&lt;li&gt;March 8, 2020, &lt;strong&gt;Victor Stinner&lt;/strong&gt;,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/eb4e2ae2b8486e8ee4249218b95d94a9f0cc513e"&gt;commit eb4e2ae2&lt;/a&gt;:
&lt;tt class="docutils literal"&gt;take_gil()&lt;/tt&gt; exits if finalizing &lt;strong&gt;before&lt;/strong&gt; taking the GIL (1 check)&lt;/li&gt;
&lt;li&gt;March 9, 2020, &lt;strong&gt;Victor Stinner&lt;/strong&gt;,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/9229eeee105f19705f72e553cf066751ac47c7b7"&gt;commit 9229eeee&lt;/a&gt;:
&lt;tt class="docutils literal"&gt;take_gil()&lt;/tt&gt; exits if finalizing &lt;strong&gt;before and after&lt;/strong&gt; taking the GIL (2 checks)&lt;/li&gt;
&lt;li&gt;March 19, 2020, &lt;strong&gt;Victor Stinner&lt;/strong&gt;,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/a36adfa6bbf5e612a4d4639124502135690899b8"&gt;commit a36adfa6&lt;/a&gt;:
&lt;tt class="docutils literal"&gt;take_gil()&lt;/tt&gt; exits if finalizing &lt;strong&gt;before, while, and after&lt;/strong&gt; taking the GIL (3 checks)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content><category term="cpython"></category><category term="cpython"></category><category term="subinterpreters"></category></entry><entry><title>Threading shutdown race condition</title><link href="https://vstinner.github.io/threading-shutdown-race-condition.html" rel="alternate"></link><published>2020-04-03T20:00:00+02:00</published><updated>2020-04-03T20:00:00+02:00</updated><author><name>Victor Stinner</name></author><id>tag:vstinner.github.io,2020-04-03:/threading-shutdown-race-condition.html</id><summary type="html">&lt;p&gt;This article is about a race condition in threading shutdown that I fixed in
Python 3.9 in March 2019. I also forbid spawning daemon threads in
subinterpreters to fix another related bug.&lt;/p&gt;
&lt;a class="reference external image-reference" href="https://twitter.com/neeljulien/status/1240292383369150464"&gt;&lt;img alt="#CoronaMaison by Julien Neel" src="https://vstinner.github.io/images/coronamaison_jneel.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;Drawing: &lt;a class="reference external" href="https://twitter.com/neeljulien/status/1240292383369150464"&gt;#CoronaMaison by Julien Neel&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="race-condition-in-threading-shutdown"&gt;
&lt;h2&gt;Race condition in threading shutdown&lt;/h2&gt;
&lt;div class="section" id="random-test-failure-noticed-on-freebsd-buildbot"&gt;
&lt;h3&gt;Random test failure noticed on FreeBSD buildbot …&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;This article is about a race condition in threading shutdown that I fixed in
Python 3.9 in March 2019. I also forbid spawning daemon threads in
subinterpreters to fix another related bug.&lt;/p&gt;
&lt;a class="reference external image-reference" href="https://twitter.com/neeljulien/status/1240292383369150464"&gt;&lt;img alt="#CoronaMaison by Julien Neel" src="https://vstinner.github.io/images/coronamaison_jneel.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;Drawing: &lt;a class="reference external" href="https://twitter.com/neeljulien/status/1240292383369150464"&gt;#CoronaMaison by Julien Neel&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="race-condition-in-threading-shutdown"&gt;
&lt;h2&gt;Race condition in threading shutdown&lt;/h2&gt;
&lt;div class="section" id="random-test-failure-noticed-on-freebsd-buildbot"&gt;
&lt;h3&gt;Random test failure noticed on FreeBSD buildbot&lt;/h3&gt;
&lt;p&gt;In March 2019, I noticed that &lt;tt class="docutils literal"&gt;test_threading.test_threads_join_2()&lt;/tt&gt; was
killed by SIGABRT on the FreeBSD CURRENT buildbot, &lt;a class="reference external" href="https://bugs.python.org/issue36402"&gt;bpo-36402&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Fatal Python error: Py_EndInterpreter: not the last thread
&lt;/pre&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;test_threads_join_2()&lt;/tt&gt; test &lt;strong&gt;failed randomly&lt;/strong&gt; on buildbots when tests
were &lt;strong&gt;run in parallel&lt;/strong&gt;, but test_threading &lt;strong&gt;passed&lt;/strong&gt; when it was &lt;strong&gt;re-run
sequentially&lt;/strong&gt;.  Such failure was silently ignored, since the build was seen
overall as a success.&lt;/p&gt;
&lt;p&gt;The test &lt;tt class="docutils literal"&gt;test_threading.test_threads_join_2()&lt;/tt&gt; was added by in 2013 &lt;a class="reference external" href="https://github.com/python/cpython/commit/7b4769937fb612d576b6829c3b834f3dd31752f1"&gt;commit
7b476993&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In 2016, I already reported the same test failure: &lt;a class="reference external" href="https://bugs.python.org/issue27791"&gt;bpo-27791&lt;/a&gt; (same test, also on FreeBSD). And
Christian Heimes reported a similar issue: &lt;a class="reference external" href="https://bugs.python.org/issue28084"&gt;bpo-28084&lt;/a&gt;. I simply closed these issues because I
only saw the failure once in 4 months and &lt;strong&gt;I didn't have access to FreeBSD to
attempt to reproduce the crash&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="reproduce-the-race-condition"&gt;
&lt;h3&gt;Reproduce the race condition&lt;/h3&gt;
&lt;p&gt;In 2019, I had a FreeBSD VM to attempt to reproduce the bug locally.&lt;/p&gt;
&lt;p&gt;In June 2019, I found a reliable way to reproduce the bug by &lt;a class="reference external" href="https://github.com/python/cpython/pull/13889/files"&gt;adding random
sleeps to the test&lt;/a&gt;. With
this patch, I was also able to reproduce the bug on Linux. &lt;strong&gt;I am way more
comfortable to debug an issue on Linux&lt;/strong&gt; with my favorite debugging tools!&lt;/p&gt;
&lt;p&gt;I identified a race condition in the Python finalization. I also understood
that the bug was not specific to subinterpreters:&lt;/p&gt;
&lt;blockquote&gt;
The test shows the bug using subinterpreters (Py_EndInterpreter), but
&lt;strong&gt;the bug also exists in Py_Finalize()&lt;/strong&gt; which has the same race condition.&lt;/blockquote&gt;
&lt;p&gt;I wrote a patch for &lt;tt class="docutils literal"&gt;Py_Finalize()&lt;/tt&gt; to help me to reproduce the bug without
subinterpreters:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
+    if (tstate != interp-&amp;gt;tstate_head || tstate-&amp;gt;next != NULL) {
+        Py_FatalError(&amp;quot;Py_EndInterpreter: not the last thread&amp;quot;);
+    }
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="threading-shutdown-race-condition-1"&gt;
&lt;h3&gt;threading._shutdown() race condition&lt;/h3&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;threading._shutdown()&lt;/tt&gt; uses &lt;tt class="docutils literal"&gt;threading.enumerate()&lt;/tt&gt; which iterates on
&lt;tt class="docutils literal"&gt;threading._active&lt;/tt&gt; dictionary.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;threading.Thread&lt;/tt&gt; registers itself into &lt;tt class="docutils literal"&gt;threading._active&lt;/tt&gt; when the
thread starts. It unregisters itself from &lt;tt class="docutils literal"&gt;threading._active&lt;/tt&gt; when it
completes.&lt;/p&gt;
&lt;p&gt;The bug occurs when the thread is unregistered whereas the underlying native
thread is still running and &lt;strong&gt;the Python thread state is not deleted yet&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;_thread._set_sentinel()&lt;/tt&gt; creates a lock and registers a
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;tstate-&amp;gt;on_delete&lt;/span&gt;&lt;/tt&gt; callback to release this lock. It's called by
&lt;tt class="docutils literal"&gt;threading.Thread&lt;/tt&gt; when the thread starts to set
&lt;tt class="docutils literal"&gt;threading.Thread._tstate_lock&lt;/tt&gt;.  This lock is used by
&lt;tt class="docutils literal"&gt;threading.Thread.join()&lt;/tt&gt; method to wait until the thread completes.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;_thread.start_new_thread()&lt;/tt&gt; calls the C function &lt;tt class="docutils literal"&gt;t_bootstrap()&lt;/tt&gt; which
ends with:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
tstate-&amp;gt;interp-&amp;gt;num_threads--;
PyThreadState_Clear(tstate);
PyThreadState_DeleteCurrent();
PyThread_exit_thread();
&lt;/pre&gt;
&lt;p&gt;When the native thread completes, &lt;tt class="docutils literal"&gt;_PyThreadState_DeleteCurrent()&lt;/tt&gt; is called:
it calls &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;tstate-&amp;gt;on_delete()&lt;/span&gt;&lt;/tt&gt; callback which releases
&lt;tt class="docutils literal"&gt;threading.Thread._tstate_lock&lt;/tt&gt; lock.&lt;/p&gt;
&lt;p&gt;The root issue is that:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;threading._shutdown()&lt;/tt&gt; rely on &lt;tt class="docutils literal"&gt;threading._alive&lt;/tt&gt; dictionary&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_EndInterpreter()&lt;/tt&gt; rely on the interpreter linked list of Python thread
states of the interpreter (&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;interp-&amp;gt;tstate_head&lt;/span&gt;&lt;/tt&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The lock on Python thread states (&lt;tt class="docutils literal"&gt;threading.Thread._tstate_lock&lt;/tt&gt;) and
&lt;tt class="docutils literal"&gt;PyThreadState.on_delete&lt;/tt&gt; callback were added in 2013 by &lt;strong&gt;Antoine Pitrou&lt;/strong&gt;
to Python 3.4, &lt;a class="reference external" href="https://github.com/python/cpython/commit/7b4769937fb612d576b6829c3b834f3dd31752f1"&gt;commit 7b476993&lt;/a&gt;
of &lt;a class="reference external" href="https://bugs.python.org/issue18808"&gt;bpo-18808&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Issue #18808: Thread.join() now waits for the underlying thread state
to be destroyed before returning. This prevents unpredictable aborts
in Py_EndInterpreter() when some non-daemon threads are still running.
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="fix-threading-shutdown"&gt;
&lt;h3&gt;Fix threading._shutdown()&lt;/h3&gt;
&lt;p&gt;Finally in June 2019, I fixed the race condition in &lt;tt class="docutils literal"&gt;threading._shutdown()&lt;/tt&gt;
with &lt;a class="reference external" href="https://github.com/python/cpython/commit/468e5fec8a2f534f1685d59da3ca4fad425c38dd"&gt;commit 468e5fec&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
bpo-36402: Fix threading._shutdown() race condition (GH-13948)

Fix a race condition at Python shutdown when waiting for threads.  Wait
until the Python thread state of all non-daemon threads get deleted
(join all non-daemon threads), rather than just wait until Python
threads complete.
&lt;/pre&gt;
&lt;p&gt;The fix is to modify &lt;tt class="docutils literal"&gt;threading._shutdown()&lt;/tt&gt; to wait until the Python thread
state of all non-daemon threads get deleted, rather than calling the &lt;tt class="docutils literal"&gt;join()&lt;/tt&gt;
method of all non-daemon threads. The &lt;tt class="docutils literal"&gt;join()&lt;/tt&gt; does not ensure that the
Python thread state is deleted.&lt;/p&gt;
&lt;p&gt;The Python finalization calls &lt;tt class="docutils literal"&gt;threading._shutdown()&lt;/tt&gt; to wait until all
threads complete. Only non-daemon threads are awaited: daemon threads can
continue to run after &lt;tt class="docutils literal"&gt;threading._shutdown()&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;Py_EndInterpreter()&lt;/tt&gt; requires that the Python thread states of all threads
have been deleted. &lt;strong&gt;What about daemon threads?&lt;/strong&gt; More about that in the next
section ;-)&lt;/p&gt;
&lt;p&gt;Note: This change introduced a regression (memory leak) which is not fixed yet:
&lt;a class="reference external" href="https://bugs.python.org/issue37788"&gt;bpo-37788&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="forbid-daemon-threads-in-subinterpreters"&gt;
&lt;h2&gt;Forbid daemon threads in subinterpreters&lt;/h2&gt;
&lt;p&gt;In June 2019, while fixing the threading shutdown, I found a reliable way to
trigger a bug with daemon threads when a subinterpreter is finalized:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Fatal Python error: Py_EndInterpreter: not the last thread
&lt;/pre&gt;
&lt;p&gt;By design, daemon threads can run after a Python interpreter is finalized,
whereas &lt;tt class="docutils literal"&gt;Py_EndInterpreter()&lt;/tt&gt; requires that all threads completed.&lt;/p&gt;
&lt;p&gt;I reported &lt;a class="reference external" href="https://bugs.python.org/issue37266"&gt;bpo-37266&lt;/a&gt; to propose to
forbid the creation of daemon threads in subinterpreters. I fixed the issue
with &lt;a class="reference external" href="https://github.com/python/cpython/commit/066e5b1a917ec2134e8997d2cadd815724314252"&gt;commit 066e5b1a&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
bpo-37266: Daemon threads are now denied in subinterpreters (GH-14049)

In a subinterpreter, spawning a daemon thread now raises an
exception. Daemon threads were never supported in subinterpreters.
Previously, the subinterpreter finalization crashed with a Pyton
fatal error if a daemon thread was still running.
&lt;/pre&gt;
&lt;p&gt;The change adds this check to &lt;tt class="docutils literal"&gt;Thread.start()&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
if self.daemon and not _is_main_interpreter():
    raise RuntimeError(&amp;quot;daemon thread are not supported &amp;quot;
                       &amp;quot;in subinterpreters&amp;quot;)
&lt;/pre&gt;
&lt;p&gt;I commented:&lt;/p&gt;
&lt;blockquote&gt;
&lt;strong&gt;Daemon threads must die.&lt;/strong&gt; That's a first step towards their death!&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Antoine Pitrou&lt;/strong&gt; created &lt;a class="reference external" href="https://bugs.python.org/issue39812"&gt;bpo-39812: Avoid daemon threads in
concurrent.futures&lt;/a&gt; as a follow-up.&lt;/p&gt;
&lt;p&gt;In February 2020, when rebuilding Fedora Rawhide with Python 3.9, &lt;strong&gt;Miro
Hrončok&lt;/strong&gt; of my team noticed that my change &lt;a class="reference external" href="https://bugzilla.redhat.com/show_bug.cgi?id=1792062"&gt;broke the python-jep project&lt;/a&gt;. I &lt;a class="reference external" href="https://github.com/ninia/jep/issues/229"&gt;reported the bug
upstream&lt;/a&gt;. It has been fixed by
using regular threads, rather than daemon threads: &lt;a class="reference external" href="https://github.com/ninia/jep/commit/a31d461c6cacc96de68d68320eaa83e19a45d0cc"&gt;commit&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;A random failure on a FreeBSD buildbot was hiding a severe race condition in
the threading shutdown. The bug existed since 2013, but was silently ignored
since the test passed when re-run.&lt;/p&gt;
&lt;p&gt;The race condition was that that the threading shutdown didn't ensure that the
Python thread state of all non-daemon threads are deleted, whereas it is a
&lt;tt class="docutils literal"&gt;Py_EndInterpreter()&lt;/tt&gt; requirement.&lt;/p&gt;
&lt;p&gt;I fixed the threading shutdown by waiting until the Python thread state of all
non-daemon threads is deleted.&lt;/p&gt;
&lt;p&gt;I also modified &lt;tt class="docutils literal"&gt;Thread.start()&lt;/tt&gt; to forbid spawning daemon threads in Python
subinterpreters to fix a related issue.&lt;/p&gt;
&lt;/div&gt;
</content><category term="cpython"></category><category term="cpython"></category><category term="subinterpreters"></category></entry><entry><title>Daemon threads and the Python finalization in Python 3.2 and 3.3</title><link href="https://vstinner.github.io/daemon-threads-python-finalization-python32.html" rel="alternate"></link><published>2020-03-26T22:00:00+01:00</published><updated>2020-03-26T22:00:00+01:00</updated><author><name>Victor Stinner</name></author><id>tag:vstinner.github.io,2020-03-26:/daemon-threads-python-finalization-python32.html</id><summary type="html">&lt;a class="reference external image-reference" href="https://twitter.com/LuppiChan/status/1240346448606171136"&gt;&lt;img alt="#CoronaMaison by Luppi" src="https://vstinner.github.io/images/coronamaison_luppi.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;At exit, the Python finalization calls Python objects finalizers (the
&lt;tt class="docutils literal"&gt;__del__()&lt;/tt&gt; method) and deallocates memory.  The daemon threads are a special
kind of threads which continue to run during and after the Python finalization.
They are causing race conditions and tricky bugs in the Python finalization.&lt;/p&gt;
&lt;p&gt;This article covers bugs …&lt;/p&gt;</summary><content type="html">&lt;a class="reference external image-reference" href="https://twitter.com/LuppiChan/status/1240346448606171136"&gt;&lt;img alt="#CoronaMaison by Luppi" src="https://vstinner.github.io/images/coronamaison_luppi.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;At exit, the Python finalization calls Python objects finalizers (the
&lt;tt class="docutils literal"&gt;__del__()&lt;/tt&gt; method) and deallocates memory.  The daemon threads are a special
kind of threads which continue to run during and after the Python finalization.
They are causing race conditions and tricky bugs in the Python finalization.&lt;/p&gt;
&lt;p&gt;This article covers bugs fixed in the Python finalization in Python 3.2 and
Python 3.3 (2009 to 2011), and a backport in Python 2.7.8 (2014).&lt;/p&gt;
&lt;p&gt;Drawing: &lt;a class="reference external" href="https://twitter.com/LuppiChan/status/1240346448606171136"&gt;#CoronaMaison by Luppi&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="daemon-threads"&gt;
&lt;h2&gt;Daemon threads&lt;/h2&gt;
&lt;p&gt;Python has a special kind of thread: &amp;quot;daemon&amp;quot; threads. The difference with
regular threads is that Python doesn't wait until daemon threads complete at
exit, whereas it waits until all regular (&amp;quot;non-daemon&amp;quot;) threads complete.
Example:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
import threading, time
thread = threading.Thread(target=time.sleep, args=(5.0,), daemon=False)
thread.start()
&lt;/pre&gt;
&lt;p&gt;This Python program spawns a regular thread which sleeps for 5 seconds. Python
takes 5 seconds to exit:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ time python3 sleep.py

real   0m5,047s
&lt;/pre&gt;
&lt;p&gt;If &lt;tt class="docutils literal"&gt;daemon=False&lt;/tt&gt; is replaced with &lt;tt class="docutils literal"&gt;daemon=True&lt;/tt&gt; to spawn a daemon thread
instead, Python exits immediately (57 ms):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ time python3 sleep.py

real   0m0,057s
&lt;/pre&gt;
&lt;p&gt;Note: The &lt;tt class="docutils literal"&gt;Thread.join()&lt;/tt&gt; method can be called explicitly to wait until a
daemon thread completes.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="don-t-destroy-the-gil-at-exit"&gt;
&lt;h2&gt;Don't destroy the GIL at exit&lt;/h2&gt;
&lt;p&gt;In November 2009, &lt;strong&gt;Antoine Pitrou&lt;/strong&gt; implemented a new GIL (Global Interpreter
Lock) in Python 3.2: &lt;a class="reference external" href="https://github.com/python/cpython/commit/074e5ed974be65fbcfe75a4c0529dbc53f13446f"&gt;commit 074e5ed9&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In September 2010, he found a crash with daemon threads while stressing
&lt;tt class="docutils literal"&gt;test_threading&lt;/tt&gt;: &lt;a class="reference external" href="https://bugs.python.org/issue9901"&gt;bpo-9901: GIL destruction can fail&lt;/a&gt;. &lt;tt class="docutils literal"&gt;test_finalize_with_trace()&lt;/tt&gt; failed
with:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Fatal Python error: pthread_mutex_destroy(gil_mutex) failed
&lt;/pre&gt;
&lt;p&gt;He pushed a fix for this crash in Python 3.2, &lt;a class="reference external" href="https://github.com/python/cpython/commit/b0b384b7c0333bf1183cd6f90c0a3f9edaadd6b9"&gt;commit b0b384b7&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Issue #9901: Destroying the GIL in Py_Finalize() can fail if some other
threads are still running.  Instead, reinitialize the GIL on a second
call to Py_Initialize().
&lt;/pre&gt;
&lt;p&gt;The Python GIL internally uses a lock. If the lock is destroyed while a daemon
thread is waiting for it, the thread can crash. The fix is to &lt;strong&gt;no longer
destroy the GIL at exit&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="exit-the-thread-in-pyeval-restorethread"&gt;
&lt;h2&gt;Exit the thread in PyEval_RestoreThread()&lt;/h2&gt;
&lt;p&gt;The Python finalization clears and deallocates the &amp;quot;Python thread state&amp;quot; of all
threads (in &lt;tt class="docutils literal"&gt;PyInterpreterState_Delete()&lt;/tt&gt;) which calls Python object
finalizers of these threads. Calling a finalizer can drop the GIL to call a
system call. For example, closing a file drops the GIL. When the GIL is
dropped, a daemon thread is awaken to take the GIL. Since the Python thread
state was just deallocated, the daemon thread crash.&lt;/p&gt;
&lt;p&gt;This bug is a race condition. It depends on which order threads are executed,
on which order objects are finalized, on which order memory is deallocated,
etc.&lt;/p&gt;
&lt;p&gt;The crash was first reported in April 2005: &lt;a class="reference external" href="https://bugs.python.org/issue1193099"&gt;bpo-1193099: Embedded python thread
crashes&lt;/a&gt;. In January 2008, &lt;strong&gt;Gregory P.
Smith&lt;/strong&gt; reported &lt;a class="reference external" href="https://bugs.python.org/issue1856#msg60014"&gt;bpo-1856: shutdown (exit) can hang or segfault with daemon
threads running&lt;/a&gt;. He wrote a
short Python program reproducing the bug: spawn 40 daemon threads which do some
I/O operations and sleep randomly between 0 ms and 5 ms in a loop.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Adam Olsen&lt;/strong&gt; &lt;a class="reference external" href="https://bugs.python.org/issue1856#msg60059"&gt;proposed a solution&lt;/a&gt; (with a patch):&lt;/p&gt;
&lt;blockquote&gt;
I think &lt;strong&gt;non-main threads should kill themselves off&lt;/strong&gt; if they grab the
interpreter lock and the interpreter is tearing down. They're about to get
killed off anyway, when the process exits.&lt;/blockquote&gt;
&lt;p&gt;In May 2011, &lt;strong&gt;Antoine Pitrou&lt;/strong&gt; pushed a fix to Python 3.3 (6 years after the
first bug report) which implements this solution, &lt;a class="reference external" href="https://github.com/python/cpython/commit/0d5e52d3469a310001afe50689f77ddba6d554d1"&gt;commit 0d5e52d3&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Issue #1856: Avoid crashes and lockups when daemon threads run while the
interpreter is shutting down; instead, these threads are now killed when
they try to take the GIL.
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="pyeval-restorethread-fix-explanation"&gt;
&lt;h2&gt;PyEval_RestoreThread() fix explanation&lt;/h2&gt;
&lt;p&gt;The fix adds a new &lt;tt class="docutils literal"&gt;_Py_Finalizing&lt;/tt&gt; variable which is set by
&lt;tt class="docutils literal"&gt;Py_Finalize()&lt;/tt&gt; to the (Python thread state of the) thread which runs the
finalization.&lt;/p&gt;
&lt;p&gt;Simplified patch of the &lt;tt class="docutils literal"&gt;PyEval_RestoreThread()&lt;/tt&gt; fix:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;#64;&amp;#64; -440,6 +440,12 &amp;#64;&amp;#64; PyEval_RestoreThread()
         take_gil(tstate);
+        if (_Py_Finalizing &amp;amp;&amp;amp; tstate != _Py_Finalizing) {
+            drop_gil(tstate);
+            PyThread_exit_thread();
+        }
&lt;/pre&gt;
&lt;p&gt;If Python is finalizing (&lt;tt class="docutils literal"&gt;_Py_Finalizing&lt;/tt&gt; is not NULL) and
&lt;tt class="docutils literal"&gt;PyEval_RestoreThread()&lt;/tt&gt; is called by a thread which is not thread running
the finalization, the thread exits immediately (call
&lt;tt class="docutils literal"&gt;PyThread_exit_thread()&lt;/tt&gt;).&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;PyEval_RestoreThread()&lt;/tt&gt; is called when a thread takes the GIL.  Typical
example of code which drops the GIL to call a system call (close a file
descriptor, &lt;tt class="docutils literal"&gt;io.FileIO()&lt;/tt&gt; finalizer) and then takes again the GIL:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Py_BEGIN_ALLOW_THREADS
close(fd);
Py_END_ALLOW_THREADS
&lt;/pre&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;Py_BEGIN_ALLOW_THREADS&lt;/tt&gt; macro calls &lt;tt class="docutils literal"&gt;PyEval_SaveThread()&lt;/tt&gt; to drop the
GIL, and the &lt;tt class="docutils literal"&gt;Py_END_ALLOW_THREADS&lt;/tt&gt; macro calls &lt;tt class="docutils literal"&gt;PyEval_RestoreThread()&lt;/tt&gt; to
take the GIL.  Pseudo-code:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
PyEval_SaveThread();     // drop the GIL
close(fd);
PyEval_RestoreThread();  // take the GIL
&lt;/pre&gt;
&lt;p&gt;With Antoine's fix, if Python is finalizing, a thread now exits immediately
when calling &lt;tt class="docutils literal"&gt;PyEval_RestoreThread()&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="revert-take-gil-backport-to-2-7"&gt;
&lt;h2&gt;Revert take_gil() backport to 2.7&lt;/h2&gt;
&lt;p&gt;In June 2014, &lt;strong&gt;Benjamin Peterson&lt;/strong&gt; (Python 2.7 release manager) backported
Antoine's change to Python 2.7: fix included in 2.7.8.&lt;/p&gt;
&lt;p&gt;Problem: the Ceph project &lt;a class="reference external" href="https://tracker.ceph.com/issues/8797"&gt;started to crash with Python 2.7.8&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In November 2014, the change was reverted in Python 2.7.9: see
&lt;a class="reference external" href="https://bugs.python.org/issue21963"&gt;bpo-21963 discussion&lt;/a&gt; for the rationale.&lt;/p&gt;
&lt;p&gt;In 2014, I already wrote:&lt;/p&gt;
&lt;blockquote&gt;
Anyway, &lt;strong&gt;daemon threads are evil&lt;/strong&gt; :-( Expecting them to exit cleanly
automatically is not good. Last time I tried to improve code to cleanup
Python at exit in Python 3.4, I also had a regression (just before the
release of Python 3.4.0): see the &lt;a class="reference external" href="https://bugs.python.org/issue21788"&gt;issue #21788&lt;/a&gt;.&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Daemon threads caused crashes in the Python finalization, first noticed in
2005.&lt;/p&gt;
&lt;p&gt;Python 3.2 (released in February 2011) got a new GIL and also a bugfix for
daemon thread. Python 3.3 (released in September 2012) also got a bugfix for
daemon threads. The Python finalization became more reliable.&lt;/p&gt;
&lt;p&gt;Changing Python finalization is risky. A backport of a bugfix into Python 2.7.8
caused a regression which required to revert the bugfix in Python 2.7.9.&lt;/p&gt;
&lt;/div&gt;
</content><category term="cpython"></category><category term="cpython"></category><category term="subinterpreters"></category></entry><entry><title>asyncio WSASend() memory leak</title><link href="https://vstinner.github.io/asyncio-proactor-wsasend-memory-leak.html" rel="alternate"></link><published>2019-03-06T20:00:00+01:00</published><updated>2019-03-06T20:00:00+01:00</updated><author><name>Victor Stinner</name></author><id>tag:vstinner.github.io,2019-03-06:/asyncio-proactor-wsasend-memory-leak.html</id><summary type="html">&lt;a class="reference external image-reference" href="https://www.flickr.com/photos/jronaldlee/5996590138/"&gt;&lt;img alt="Leaking tap" src="https://vstinner.github.io/images/leaking_tap.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;I fixed multiple bugs in asyncio &lt;tt class="docutils literal"&gt;ProactorEventLoop&lt;/tt&gt; previously. But test_asyncio
still failed sometimes. I noticed a memory leak in &lt;tt class="docutils literal"&gt;test_asyncio&lt;/tt&gt; which will
haunt me for 1 year in 2018...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Yet another example of a test failure which looks harmless but hides a
critical bug.&lt;/strong&gt; The bug is that sending a …&lt;/p&gt;</summary><content type="html">&lt;a class="reference external image-reference" href="https://www.flickr.com/photos/jronaldlee/5996590138/"&gt;&lt;img alt="Leaking tap" src="https://vstinner.github.io/images/leaking_tap.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;I fixed multiple bugs in asyncio &lt;tt class="docutils literal"&gt;ProactorEventLoop&lt;/tt&gt; previously. But test_asyncio
still failed sometimes. I noticed a memory leak in &lt;tt class="docutils literal"&gt;test_asyncio&lt;/tt&gt; which will
haunt me for 1 year in 2018...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Yet another example of a test failure which looks harmless but hides a
critical bug.&lt;/strong&gt; The bug is that sending a network packet on Windows using
asyncio &lt;tt class="docutils literal"&gt;ProactorEventLoop&lt;/tt&gt; can leak the packet. With such bug, it is easy to
imagine a very quick increase of the memory footprint of a network server...&lt;/p&gt;
&lt;p&gt;I'm curious why nobody noticed it before me? For me, the only explanation is
that nobody was running a server using &lt;tt class="docutils literal"&gt;ProactorEventLoop&lt;/tt&gt;. Before Python
3.8, &lt;tt class="docutils literal"&gt;SelectorEventLoop&lt;/tt&gt; was the default asyncio event loop on Windows.
&lt;a class="reference external" href="https://bugs.python.org/issue34687"&gt;bpo-34687&lt;/a&gt;: Andrew Svetlov, Yury
Selivanov and me agreed to make &lt;tt class="docutils literal"&gt;ProactorEventLoop&lt;/tt&gt; the default in Python
3.8! &lt;tt class="docutils literal"&gt;Lib/asyncio/windows_events.py&lt;/tt&gt; change of my &lt;a class="reference external" href="https://github.com/python/cpython/commit/6ea29c5e90dde6c240bd8e0815614b52ac307ea1"&gt;commit 6ea29c5e&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
-DefaultEventLoopPolicy = WindowsSelectorEventLoopPolicy
+DefaultEventLoopPolicy = WindowsProactorEventLoopPolicy
&lt;/pre&gt;
&lt;p&gt;The bug wasn't a regression. It was only discovered 5 years after the code has
been written thanks to new tests.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UPDATE:&lt;/strong&gt; I updated the article to add the &amp;quot;Regression? Nope&amp;quot; section and
elaborate the Conclusion.&lt;/p&gt;
&lt;p&gt;Previous article:
&lt;a class="reference external" href="https://vstinner.github.io/asyncio-proactor-wsarecv-cancellation-data-loss.html"&gt;asyncio: WSARecv() cancellation causing data loss&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="yet-another-random-buildbot-failure"&gt;
&lt;h2&gt;Yet another random buildbot failure&lt;/h2&gt;
&lt;p&gt;One day at the end of January 2018, I noticed a new failure on the AMD64
Windows8.1 Refleaks 3.x&amp;quot; buildbot worker. I reported &lt;a class="reference external" href="https://bugs.python.org/issue32710"&gt;bpo-32710&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;AMD64 Windows8.1 Refleaks 3.x:
&lt;a class="reference external" href="http://buildbot.python.org/all/#/builders/80/builds/118"&gt;http://buildbot.python.org/all/#/builders/80/builds/118&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;test_asyncio leaked [4, 4, 3] memory blocks, sum=11&lt;/p&gt;
&lt;p&gt;I reproduced the issue. I'm running test.bisect to try to isolate this bug.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Only 15 minutes later thanks to my &lt;tt class="docutils literal"&gt;test.bisect&lt;/tt&gt; tool, I identified the
leaking test, &lt;strong&gt;test_sendfile_close_peer_in_middle_of_receiving()&lt;/strong&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
It seems to be related to sendfile():

C:\vstinner\python\master&amp;gt;python -m test -R 3:3 test_asyncio \
    -m test.test_asyncio.test_events.ProactorEventLoopTests.test_sendfile_close_peer_in_middle_of_receiving
...
test_asyncio leaked [1, 2, 1] memory blocks, sum=4
&lt;/pre&gt;
&lt;p&gt;The test is identified, so it should take a few hours, maximum, to fix the bug,
no? We will see...&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="april"&gt;
&lt;h2&gt;April&lt;/h2&gt;
&lt;p&gt;3 months later, I asked:&lt;/p&gt;
&lt;blockquote&gt;
The test is still leaking memory blocks. Any progress on investigating the
issue?&lt;/blockquote&gt;
&lt;p&gt;Nobody replied.&lt;/p&gt;
&lt;p&gt;At that time, I was busy to fix a bunch of various other bugs reported by
buildbots which were easier to fix and I was kind of exhausted by asyncio, I
didn't want to touch it.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="june"&gt;
&lt;h2&gt;June&lt;/h2&gt;
&lt;p&gt;Oh, I found again this bug while working on my &lt;a class="reference external" href="https://github.com/python/cpython/pull/7827"&gt;PR 7827&lt;/a&gt; (detect handle leaks on Windows
in regrtest).&lt;/p&gt;
&lt;p&gt;In 2018, I was very busy with fixing dozens of multiprocessing bugs (fix tests
but also fix some bugs in multiprocessing).&lt;/p&gt;
&lt;p&gt;For example, I noticed another memory leak on AMD64 Windows8.1 Refleaks
3.7, &lt;a class="reference external" href="https://bugs.python.org/issue33735#msg318425"&gt;bpo-33735&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class="reference external" href="http://buildbot.python.org/all/#/builders/132/builds/154"&gt;http://buildbot.python.org/all/#/builders/132/builds/154&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;test_multiprocessing_spawn leaked [1, 2, 1] memory blocks, sum=4&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This test_multiprocessing_spawn leak and the test_asyncio leak on Windows
Refleaks haunted me in 2018...&lt;/p&gt;
&lt;p&gt;In fact, it wasn't a real leak. After a few runs, &lt;a class="reference external" href="https://bugs.python.org/issue33735#msg320948"&gt;the test stopped to leak&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ./python -m test test_multiprocessing_spawn \
    -m test.test_multiprocessing_spawn.WithProcessesTestPool.test_imap_unordered \
    -R 1:30
...
test_multiprocessing_spawn leaked [4, 5, 1, 5, 1, 2, 0, 0, 0, ..., 0, 0, 0] memory blocks, sum=18
test_multiprocessing_spawn failed in 42 sec 470 ms
&lt;/pre&gt;
&lt;p&gt;I fixed the test with &lt;a class="reference external" href="https://github.com/python/cpython/commit/23401fb960bb94e6ea62d2999527968d53d3fc65"&gt;commit
23401fb9&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I fixed other multiprocessing bugs like &lt;a class="reference external" href="https://bugs.python.org/issue33929"&gt;bpo-33929&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;These multiprocessing bugs kept me busy.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="july-december"&gt;
&lt;h2&gt;July-December&lt;/h2&gt;
&lt;p&gt;Nothing. Nobody looked at the issue.&lt;/p&gt;
&lt;p&gt;Again, I was busy fixing various test failures reported by buildbots.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="update-in-january-2019"&gt;
&lt;h2&gt;Update in January 2019&lt;/h2&gt;
&lt;p&gt;In January 2019, after months of hard work on fixing every single buildbot
failure, I realized &lt;strong&gt;suddenly&lt;/strong&gt; that the &lt;tt class="docutils literal"&gt;test_asyncio&lt;/tt&gt; leak, &lt;a class="reference external" href="https://bugs.python.org/issue32710"&gt;bpo-32710&lt;/a&gt;, was one of the last unfixed known test
failure! So I decided to have a new look at it.&lt;/p&gt;
&lt;p&gt;Update on &lt;tt class="docutils literal"&gt;test_asyncio.test_sendfile.ProactorEventLoopTests&lt;/tt&gt;:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;test_sendfile_close_peer_in_the_middle_of_receiving()&lt;/tt&gt; leaks 1 reference per
run: this leak was the obvious bug &lt;a class="reference external" href="https://bugs.python.org/issue35682"&gt;bpo-35682&lt;/a&gt;, I already fixed it with &lt;a class="reference external" href="https://github.com/python/cpython/commit/80fda712c83f5dd9560d42bf2aa65a72b18b7759"&gt;commit
80fda712&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;test_sendfile_fallback_close_peer_in_the_middle_of_receiving()&lt;/tt&gt; leaks 1
reference per run: &lt;strong&gt;I don't understand why&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note: I had to copy/paste these test names a lot of times. Pleeease, for my
comfort, use shorter test names! :-) (I had to copy/paste them, I don't think
that a regular human is able to type these very long names!)&lt;/p&gt;
&lt;p&gt;I spent a lot of time to investigate
&lt;tt class="docutils literal"&gt;test_sendfile_fallback_close_peer_in_the_middle_of_receiving()&lt;/tt&gt; leak and I don't
understand the issue.&lt;/p&gt;
&lt;p&gt;The main loop is &lt;tt class="docutils literal"&gt;BaseEventLoop._sendfile_fallback()&lt;/tt&gt;. For
the specific case of this test, the loop can be simplified to:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
proto = _SendfileFallbackProtocol(transp)
try:
    while True:
        data = b'x' * (1024 * 64)
        await proto.drain()
        transp.write(data)
finally:
    await proto.restore()
&lt;/pre&gt;
&lt;p&gt;The server closes the connection after it gets 1024 bytes. The client socket
gets a &lt;tt class="docutils literal"&gt;ConnectionAbortedError&lt;/tt&gt; exception in
&lt;tt class="docutils literal"&gt;_ProactorBaseWritePipeTransport._loop_writing()&lt;/tt&gt; which calls &lt;tt class="docutils literal"&gt;_fatal_error()&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
except OSError as exc:
    self._fatal_error(exc, 'Fatal write error on pipe transport')
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;_fatal_error()&lt;/tt&gt; calls &lt;tt class="docutils literal"&gt;_force_close()&lt;/tt&gt; which sets &lt;tt class="docutils literal"&gt;_closing&lt;/tt&gt; to
&lt;tt class="docutils literal"&gt;True&lt;/tt&gt;, and calls &lt;tt class="docutils literal"&gt;protocol.connection_lost()&lt;/tt&gt;. In the meanwhile,
&lt;tt class="docutils literal"&gt;drain()&lt;/tt&gt; raises &lt;tt class="docutils literal"&gt;ConnectionError&lt;/tt&gt; because &lt;tt class="docutils literal"&gt;is_closing()&lt;/tt&gt; is true:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
async def drain(self):
    if self._transport.is_closing():
        raise ConnectionError(&amp;quot;Connection closed by peer&amp;quot;)
    ...
&lt;/pre&gt;
&lt;p&gt;Said differently: &lt;strong&gt;everything works as expected&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="regression-caused-by-my-previous-proactor-fix"&gt;
&lt;h2&gt;Regression caused by my previous proactor fix?&lt;/h2&gt;
&lt;p&gt;I suspected my own &lt;a class="reference external" href="https://github.com/python/cpython/commit/79790bc35fe722a49977b52647f9b5fe1deda2b7"&gt;commit 79790bc3&lt;/a&gt;
pushed 7 months ago to fix a race condition in WSARecv() causing data loss
(that's my previous article: &lt;a class="reference external" href="https://vstinner.github.io/asyncio-proactor-wsarecv-cancellation-data-loss.html"&gt;asyncio: WSARecv() cancellation causing data loss&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Hint: nah, it's unrelated. Moreover, this change has been pushed in May,
whereas I reported &lt;a class="reference external" href="https://bugs.python.org/issue32710"&gt;bpo-32710 leak&lt;/a&gt; in
January.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="short-script-reproducing-the-leak"&gt;
&lt;h2&gt;Short script reproducing the leak&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Identifying a leak of a single reference is really hard&lt;/strong&gt; since the test uses
hundreds of Python objects! My blocker issue was to repeat the test enough
times to trigger the leak N times rather than getting a leak of exactly a
single Python reference. The problem was that the test failed when ran more
than once.&lt;/p&gt;
&lt;p&gt;All my previous attempts to identify the bug failed:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Use &lt;tt class="docutils literal"&gt;gc.get_referrers()&lt;/tt&gt; to track references between Python objects.&lt;/li&gt;
&lt;li&gt;Use &lt;tt class="docutils literal"&gt;tracemalloc&lt;/tt&gt; to track memory usage: the leak is too small, it's lost
in the results &amp;quot;noise&amp;quot;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I decided to do what I should have done first: &lt;strong&gt;remove as much code as
possible&lt;/strong&gt; to reduce the code that I have to audit. I removed most Python
imports, I inlined manually function calls, I removed a lot of code which was
unused in the test, etc.&lt;/p&gt;
&lt;p&gt;After a few hours, I managed to reduce the giant pile of code used by the test
into a very short script of only 159 lines of Python code: &lt;a class="reference external" href="https://bugs.python.org/file48030/test_aiosend.py"&gt;test_aiosend.py&lt;/a&gt;. The script doesn't call
the asyncio &lt;tt class="docutils literal"&gt;sendfile()&lt;/tt&gt; implementation, but uses its own copy of the code,
simplified to do exactly what the test needs:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
async def sendfile(transp):
    proto = _SendfileFallbackProtocol(transp)
    try:
        data = b'x' * (1024 * 24)
        while True:
            await proto.drain()
            transp.write(data)
    finally:
        await proto.restore()
&lt;/pre&gt;
&lt;p&gt;with a local copy of the code of &lt;tt class="docutils literal"&gt;_SendfileFallbackProtocol&lt;/tt&gt; class.&lt;/p&gt;
&lt;p&gt;Having all code involved in the bug in a single file is way more efficient to
follow the control flow and understands what happens.&lt;/p&gt;
&lt;p&gt;The original code is waaaaay more complex, scattered across multiple Python
files in &lt;tt class="docutils literal"&gt;Lib/asyncio&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;Lib/test/test_asyncio/&lt;/tt&gt; directories.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="root-bug-identified-wsasend"&gt;
&lt;h2&gt;Root bug identified: WSASend()&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;It took me 1 year, a few sleepless nights, multiple attempts to understand
the leak, but I eventually found it!&lt;/strong&gt; WSASend() doesn't release the memory if
it fails immediately. I expected something way more complex, but it's that
simple...&lt;/p&gt;
&lt;p&gt;Using the &lt;tt class="docutils literal"&gt;test_aiosend.py&lt;/tt&gt; script that I created, I was finally able to
repeat the test in a loop. Thanks to that, it became obvious using
&lt;tt class="docutils literal"&gt;tracemalloc&lt;/tt&gt; that the leaked memory was the memory passed to &lt;tt class="docutils literal"&gt;WSASend()&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;I pushed &lt;a class="reference external" href="https://github.com/python/cpython/commit/a234e148394c2c7419372ab65b773d53a57f3625"&gt;commit a234e148&lt;/a&gt;
to fix &lt;tt class="docutils literal"&gt;WSASend()&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit a234e148394c2c7419372ab65b773d53a57f3625
Author: Victor Stinner &amp;lt;vstinner&amp;#64;redhat.com&amp;gt;
Date:   Tue Jan 8 14:23:09 2019 +0100

    bpo-32710: Fix leak in Overlapped_WSASend() (GH-11469)

    Fix a memory leak in asyncio in the ProactorEventLoop when ReadFile()
    or WSASend() overlapped operation fail immediately: release the
    internal buffer.
&lt;/pre&gt;
&lt;p&gt;I was very disappointed by the simplicity of the fix, &lt;strong&gt;it only adds a single
line&lt;/strong&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
diff --git a/Modules/overlapped.c b/Modules/overlapped.c
index 69875a7f37da..bbaa4fb3008f 100644
--- a/Modules/overlapped.c
+++ b/Modules/overlapped.c
&amp;#64;&amp;#64; -1011,6 +1012,7 &amp;#64;&amp;#64; Overlapped_WSASend(OverlappedObject *self, PyObject *args)
         case ERROR_IO_PENDING:
             Py_RETURN_NONE;
         default:
+            PyBuffer_Release(&amp;amp;self-&amp;gt;user_buffer);
             self-&amp;gt;type = TYPE_NOT_STARTED;
             return SetFromWindowsErr(err);
     }
&lt;/pre&gt;
&lt;p&gt;So what? One year to add a single line? That's unfair!&lt;/p&gt;
&lt;p&gt;My commit contains a very similar fix for &lt;tt class="docutils literal"&gt;do_ReadFile()&lt;/tt&gt; used by
&lt;tt class="docutils literal"&gt;Overlapped_ReadFile()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;Overlapped_ReadFileInto()&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="fixing-more-memory-leaks"&gt;
&lt;h2&gt;Fixing more memory leaks&lt;/h2&gt;
&lt;p&gt;By the way, the &lt;tt class="docutils literal"&gt;_overlapped.Overlapped&lt;/tt&gt; type has no traverse function: it may
help the garbage collector to add one. Asyncio is famous for building reference
cycles by design in &lt;tt class="docutils literal"&gt;Future.set_exception()&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;I wrote &lt;a class="reference external" href="https://github.com/python/cpython/pull/11489"&gt;PR 11489&lt;/a&gt; to implement
&lt;tt class="docutils literal"&gt;tp_traverse&lt;/tt&gt; for the &lt;tt class="docutils literal"&gt;_overlapped.Overlapped&lt;/tt&gt; type. &lt;a class="reference external" href="https://github.com/python/cpython/pull/11489#pullrequestreview-191093765"&gt;Serhiy Storchaka
added&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
I suspect that there are leaks when self-&amp;gt;type is set to TYPE_NOT_STARTED.&lt;/blockquote&gt;
&lt;p&gt;And he was right! I modified my PR to fix all memory leaks. After my PR has
been reviewed, I merged it, &lt;a class="reference external" href="https://github.com/python/cpython/commit/5485085b324a45307c1ff4ec7d85b5998d7d5e0d"&gt;commit 5485085b&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 5485085b324a45307c1ff4ec7d85b5998d7d5e0d
Author: Victor Stinner &amp;lt;vstinner&amp;#64;redhat.com&amp;gt;
Date:   Fri Jan 11 14:35:14 2019 +0100

    bpo-32710: Fix _overlapped.Overlapped memory leaks (GH-11489)

    Fix memory leaks in asyncio ProactorEventLoop on overlapped operation
    failures.

    Changes:

    * Implement the tp_traverse slot in the _overlapped.Overlapped type
      to help to break reference cycles and identify referrers in the
      garbage collector.
    * Always clear overlapped on failure: not only set type to
      TYPE_NOT_STARTED, but release also resources.
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="regression-nope"&gt;
&lt;h2&gt;Regression? Nope&lt;/h2&gt;
&lt;p&gt;Was the memory leak a regression? Nope. The bug existed since the creation of
the &lt;tt class="docutils literal"&gt;overlapped.c&lt;/tt&gt; file in the &amp;quot;Tulip&amp;quot; project in 2013, &lt;a class="reference external" href="https://github.com/python/asyncio/commit/27c403531670f52cad8388aaa2a13a658f753fd5"&gt;commit 27c40353&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 27c403531670f52cad8388aaa2a13a658f753fd5
Author: Richard Oudkerk &amp;lt;shibturn&amp;#64;gmail.com&amp;gt;
Date:   Mon Jan 21 20:34:38 2013 +0000

    New experimental iocp branch.
&lt;/pre&gt;
&lt;p&gt;Tulip was the old name of the asyncio project, when it was still an external
project on &lt;tt class="docutils literal"&gt;code.google.com&lt;/tt&gt;. In the meanwhile, &lt;tt class="docutils literal"&gt;code.google.com&lt;/tt&gt; has been
closed and the project moved to &lt;a class="reference external" href="https://github.com/python/asyncio/"&gt;https://github.com/python/asyncio/&lt;/a&gt; (now
read-only).&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/python/asyncio/blob/27c403531670f52cad8388aaa2a13a658f753fd5/overlapped.c#L632-L658"&gt;Extract of the original Overlapped_WSASend() implementation&lt;/a&gt;,
I added a comment to show the location of the bug:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
if (!PyArg_Parse(bufobj, &amp;quot;y*&amp;quot;, &amp;amp;self-&amp;gt;write_buffer))
    return NULL;

#if SIZEOF_SIZE_T &amp;gt; SIZEOF_LONG
if (self-&amp;gt;write_buffer.len &amp;gt; (Py_ssize_t)PY_ULONG_MAX) {
    PyBuffer_Release(&amp;amp;self-&amp;gt;write_buffer);
    PyErr_SetString(PyExc_ValueError, &amp;quot;buffer to large&amp;quot;);
    return NULL;
}
#endif
...
self-&amp;gt;error = err = (ret &amp;lt; 0 ? WSAGetLastError() : ERROR_SUCCESS);
switch (err) {
    case ERROR_SUCCESS:
    case ERROR_MORE_DATA:
    case ERROR_IO_PENDING:
        /********* !!! BUG HERE, BUFFER NOT RELEASED !!! ***********/
        Py_RETURN_NONE;
    ...
}
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;I fixed the memory leak 6 years after the code has been written!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;So... why was this bug only discovered in 2018? Multiple very asyncio old bugs
were discovered only recently thanks to more realistic and more advanced
&lt;strong&gt;functional tests&lt;/strong&gt;. First tests of asyncio were mostly tiny unit tests
mocking most part of the code. It made sense in the early days of asyncio, when
the code was not mature.&lt;/p&gt;
&lt;p&gt;By the way, the &lt;a class="reference external" href="https://github.com/python/cpython/blob/1f58f4fa6a0e3c60cee8df4a35c8dcf3903acde8/Lib/test/test_asyncio/test_sendfile.py#L446-L457"&gt;code of the test&lt;/a&gt;
which helped to discovered the bug is:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
def test_sendfile_close_peer_in_the_middle_of_receiving(self):
    srv_proto, cli_proto = self.prepare_sendfile(close_after=1024)
    with self.assertRaises(ConnectionError):
        self.run_loop(
            self.loop.sendfile(cli_proto.transport, self.file))
    self.run_loop(srv_proto.done)

    self.assertTrue(1024 &amp;lt;= srv_proto.nbytes &amp;lt; len(self.DATA),
                    srv_proto.nbytes)
    self.assertTrue(1024 &amp;lt;= self.file.tell() &amp;lt; len(self.DATA),
                    self.file.tell())
    self.assertTrue(cli_proto.transport.is_closing())
&lt;/pre&gt;
&lt;p&gt;Note: The test name has been made even longer in the meanwhile (add &amp;quot;the&amp;quot;) :-)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;For such complex bugs, &lt;strong&gt;a reliable debugging method is to remove as much code as
possible&lt;/strong&gt; to reduce the number of lines of code that should be read.
&lt;tt class="docutils literal"&gt;tracemalloc&lt;/tt&gt; remains efficient to identify a memory leak when a test can be
run in a loop to make the leak more obvious (I was blocked at the beginning
because the test failed when run a second time in a loop).&lt;/p&gt;
&lt;p&gt;Lessons learned? You should try to &lt;strong&gt;investigate every single failure of your
CI&lt;/strong&gt;.  It is important to have a test suite with functional tests. &amp;quot;Mock tests&amp;quot;
are fine to quickly write reliable tests, but there are not enough: functional
tests make the difference.&lt;/p&gt;
&lt;p&gt;Thanks &lt;strong&gt;Richard Oudkerk&lt;/strong&gt; for your great code to use Windows native APIs in
&lt;strong&gt;asyncio&lt;/strong&gt; and &lt;strong&gt;multiprocessing&lt;/strong&gt;! I like &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Input/output_completion_port"&gt;Windows IOCP&lt;/a&gt;, even if the
asyncio implementation is quite complex :-)&lt;/p&gt;
&lt;p&gt;Ok, &lt;tt class="docutils literal"&gt;_overlapped.Overlapped&lt;/tt&gt; should now have a few less memory leaks :-)&lt;/p&gt;
&lt;/div&gt;
</content><category term="cpython"></category><category term="asyncio"></category></entry><entry><title>asyncio: WSARecv() cancellation causing data loss</title><link href="https://vstinner.github.io/asyncio-proactor-wsarecv-cancellation-data-loss.html" rel="alternate"></link><published>2019-01-31T15:20:00+01:00</published><updated>2019-01-31T15:20:00+01:00</updated><author><name>Victor Stinner</name></author><id>tag:vstinner.github.io,2019-01-31:/asyncio-proactor-wsarecv-cancellation-data-loss.html</id><summary type="html">&lt;a class="reference external image-reference" href="https://www.flickr.com/photos/joybot/6026542856/"&gt;&lt;img alt="Unlocked lock" src="https://vstinner.github.io/images/lock.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;In December 2017, &lt;strong&gt;Yury Selivanov&lt;/strong&gt; pushed the long awaited &lt;tt class="docutils literal"&gt;start_tls()&lt;/tt&gt;
function.&lt;/p&gt;
&lt;p&gt;A newly added test failed on Windows. Later, the test started to fail
randomly on Linux as well. In fact, it was a well hidden race condition in the
asynchronous handshake of &lt;tt class="docutils literal"&gt;SSLProtocol&lt;/tt&gt; which will take 5 months of …&lt;/p&gt;</summary><content type="html">&lt;a class="reference external image-reference" href="https://www.flickr.com/photos/joybot/6026542856/"&gt;&lt;img alt="Unlocked lock" src="https://vstinner.github.io/images/lock.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;In December 2017, &lt;strong&gt;Yury Selivanov&lt;/strong&gt; pushed the long awaited &lt;tt class="docutils literal"&gt;start_tls()&lt;/tt&gt;
function.&lt;/p&gt;
&lt;p&gt;A newly added test failed on Windows. Later, the test started to fail
randomly on Linux as well. In fact, it was a well hidden race condition in the
asynchronous handshake of &lt;tt class="docutils literal"&gt;SSLProtocol&lt;/tt&gt; which will take 5 months of work to
be identified and fixed. The bug wasn't a recent regression, but only spotted
thanks to newly added tests.&lt;/p&gt;
&lt;p&gt;Even after this bug has been fixed, the same test still failed randomly on
Windows! Once I found how to reproduce the bug, I understood that it's a &lt;strong&gt;very
scary bug&lt;/strong&gt;: &lt;tt class="docutils literal"&gt;WSARecv()&lt;/tt&gt; cancellation randomly caused &lt;strong&gt;data loss&lt;/strong&gt;! Again,
it was a very well hidden bug which likely existing since the early days of the
&lt;tt class="docutils literal"&gt;ProactorEventLoop&lt;/tt&gt; implementation.&lt;/p&gt;
&lt;p&gt;Previous article: &lt;a class="reference external" href="https://vstinner.github.io/asyncio-proactor-connect-pipe-race-condition.html"&gt;Asyncio: Proactor ConnectPipe() Race Condition&lt;/a&gt;.
Next article: &lt;a class="reference external" href="https://vstinner.github.io/asyncio-proactor-wsasend-memory-leak.html"&gt;asyncio: WSASend() memory leak&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="new-start-tls-function"&gt;
&lt;h2&gt;New start_tls() function&lt;/h2&gt;
&lt;p&gt;The &amp;quot;starttls&amp;quot; feature have been requested since creation of asyncio. At
October 24, 2013, &lt;strong&gt;Guido van Rossum&lt;/strong&gt; created &lt;a class="reference external" href="https://github.com/python/asyncio/issues/79"&gt;asyncio issue #79&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;strong&gt;Glyph [Lefkowitz]&lt;/strong&gt; and &lt;strong&gt;Antoine [Pitrou]&lt;/strong&gt; really want a API to upgrade an
existing Transport/Protocol pair to SSL/TLS, without having to create a new
protocol.&lt;/blockquote&gt;
&lt;p&gt;At March 23, 2015, &lt;strong&gt;Giovanni Cannata&lt;/strong&gt; created &lt;a class="reference external" href="https://bugs.python.org/issue23749"&gt;bpo-23749&lt;/a&gt; which is basically the same feature
request. I &lt;a class="reference external" href="https://bugs.python.org/issue23749#msg239022"&gt;replied&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
asyncio got a new SSL implementation which makes possible to implement
STARTTLS. Are you interested to implement it?&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Elizabeth Myers&lt;/strong&gt;, &lt;strong&gt;Antoine Pitrou&lt;/strong&gt;, &lt;strong&gt;Guido van Rossum&lt;/strong&gt; and
&lt;strong&gt;Yury Selivanov&lt;/strong&gt; designed the feature. Yury &lt;a class="reference external" href="https://bugs.python.org/issue23749#msg253495"&gt;wrote a prototype&lt;/a&gt; in 2015 for PostgreSQL.  In
2017, &lt;strong&gt;Barry Warsaw&lt;/strong&gt; &lt;a class="reference external" href="https://bugs.python.org/issue23749#msg293912"&gt;wrote his own implementation for SMTP&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;At the end of 2017, &lt;strong&gt;four year&lt;/strong&gt; after Guido van Rossum created the feature
request, &lt;strong&gt;Yury Selivanov&lt;/strong&gt; implemented the feature and pushed the &lt;a class="reference external" href="https://github.com/python/cpython/commit/f111b3dcb414093a4efb9d74b69925e535ddc470"&gt;commit
f111b3dc&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit f111b3dcb414093a4efb9d74b69925e535ddc470
Author: Yury Selivanov &amp;lt;yury&amp;#64;magic.io&amp;gt;
Date:   Sat Dec 30 00:35:36 2017 -0500

    bpo-23749: Implement loop.start_tls() (#5039)
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="sslprotocol-race-condition"&gt;
&lt;h2&gt;SSLProtocol Race Condition&lt;/h2&gt;
&lt;div class="section" id="test-fails-on-appveyor-windows-temporary-fix"&gt;
&lt;h3&gt;Test fails on AppVeyor (Windows): temporary fix&lt;/h3&gt;
&lt;p&gt;At December 30, 2017, just after Yury pushed his implementation of
&lt;tt class="docutils literal"&gt;start_tls()&lt;/tt&gt; (the same day), &lt;strong&gt;Antoine Pitrou&lt;/strong&gt; reported &lt;a class="reference external" href="https://bugs.python.org/issue32458"&gt;bpo-32458&lt;/a&gt;: it seems test_asyncio fails
sporadically on AppVeyor:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ERROR: test_start_tls_server_1 (test.test_asyncio.test_sslproto.ProactorStartTLS)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &amp;quot;C:\projects\cpython\lib\test\test_asyncio\test_sslproto.py&amp;quot;, line 284, in test_start_tls_server_1
    asyncio.wait_for(main(), loop=self.loop, timeout=10))
  File &amp;quot;C:\projects\cpython\lib\asyncio\base_events.py&amp;quot;, line 440, in run_until_complete
    return future.result()
  File &amp;quot;C:\projects\cpython\lib\asyncio\tasks.py&amp;quot;, line 398, in wait_for
    raise futures.TimeoutError()
concurrent.futures._base.TimeoutError
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Yury Selivanov&lt;/strong&gt; &lt;a class="reference external" href="https://bugs.python.org/issue32458#msg309254"&gt;wrote&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
I'm leaving on a two-weeks vacation today.  To avoid risking breaking the workflow, I'll mask this tests on AppVeyor.  I'll investigate this when I get back.&lt;/blockquote&gt;
&lt;p&gt;and skipped the test as a &lt;strong&gt;temporary fix&lt;/strong&gt;, &lt;a class="reference external" href="https://github.com/python/cpython/commit/0c36bed1c46d07ef91d3e02e69e974e4f3ecd31a"&gt;commit 0c36bed1&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 0c36bed1c46d07ef91d3e02e69e974e4f3ecd31a
Author: Yury Selivanov &amp;lt;yury&amp;#64;magic.io&amp;gt;
Date:   Sat Dec 30 15:40:20 2017 -0500

    bpo-32458: Temporarily mask start-tls proactor test on Windows (#5054)
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="bug-reproduced-on-linux"&gt;
&lt;h3&gt;Bug reproduced on Linux&lt;/h3&gt;
&lt;p&gt;At May 23, 2018, five month after the bug have been reported, &lt;a class="reference external" href="https://bugs.python.org/issue32458#msg317468"&gt;I wrote&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
test_start_tls_server_1() just failed on my Linux. It likely depends on the system load.&lt;/blockquote&gt;
&lt;p&gt;Christian Heimes &lt;a class="reference external" href="https://bugs.python.org/issue32458#msg317760"&gt;added&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
[On Linux,] It's failing reproducible with OpenSSL 1.1.1 and TLS 1.3
enabled. I haven't seen it failing with TLS 1.2 yet.&lt;/blockquote&gt;
&lt;p&gt;At May 28, 2018, I found a reliable way to &lt;a class="reference external" href="https://bugs.python.org/issue32458#msg317833"&gt;reproduce the issue on Linux&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Open 3 terminals and run these commands in parallel:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;./python &lt;span class="pre"&gt;-m&lt;/span&gt; test test_asyncio &lt;span class="pre"&gt;-m&lt;/span&gt; test_start_tls_server_1 &lt;span class="pre"&gt;-F&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;./python &lt;span class="pre"&gt;-m&lt;/span&gt; test &lt;span class="pre"&gt;-j16&lt;/span&gt; &lt;span class="pre"&gt;-r&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;./python &lt;span class="pre"&gt;-m&lt;/span&gt; test &lt;span class="pre"&gt;-j16&lt;/span&gt; &lt;span class="pre"&gt;-r&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;It's a &lt;strong&gt;race condition&lt;/strong&gt; which doesn't depend on the OS, but on the system
load.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="root-issue-identified"&gt;
&lt;h3&gt;Root issue identified&lt;/h3&gt;
&lt;p&gt;Once I found how to reproduce the bug, I was able to investigate it. I created
&lt;a class="reference external" href="https://bugs.python.org/issue33674"&gt;bpo-33674&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I found a race condition in &lt;tt class="docutils literal"&gt;SSLProtocol&lt;/tt&gt; of &lt;tt class="docutils literal"&gt;asyncio/sslproto.py&lt;/tt&gt;.
Sometimes, &lt;tt class="docutils literal"&gt;_sslpipe.feed_ssldata()&lt;/tt&gt; is called before
&lt;tt class="docutils literal"&gt;_sslpipe.shutdown()&lt;/tt&gt;.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;SSLProtocol.connection_made()&lt;/tt&gt; -&amp;gt; &lt;tt class="docutils literal"&gt;SSLProtocol._start_handshake()&lt;/tt&gt;: &lt;tt class="docutils literal"&gt;self._loop.call_soon(self._process_write_backlog)&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;SSLProtoco.data_received()&lt;/tt&gt;: direct call to &lt;tt class="docutils literal"&gt;self._sslpipe.feed_ssldata(data)&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;Later, &lt;tt class="docutils literal"&gt;self._process_write_backlog()&lt;/tt&gt; calls &lt;tt class="docutils literal"&gt;self._sslpipe.do_handshake()&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The first &lt;strong&gt;write&lt;/strong&gt; is &lt;strong&gt;delayed&lt;/strong&gt; by &lt;tt class="docutils literal"&gt;call_soon()&lt;/tt&gt;, whereas the first
&lt;strong&gt;read&lt;/strong&gt; is a &lt;strong&gt;direct call&lt;/strong&gt; to the SSL pipe.&lt;/p&gt;
&lt;p&gt;Workaround:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
diff --git a/Lib/asyncio/sslproto.py b/Lib/asyncio/sslproto.py
index 2bfa45dd15..4a5dbb38a1 100644
--- a/Lib/asyncio/sslproto.py
+++ b/Lib/asyncio/sslproto.py
&amp;#64;&amp;#64; -592,7 +592,7 &amp;#64;&amp;#64; class SSLProtocol(protocols.Protocol):
         # (b'', 1) is a special value in _process_write_backlog() to do
         # the SSL handshake
         self._write_backlog.append((b'', 1))
-        self._loop.call_soon(self._process_write_backlog)
+        self._process_write_backlog()
         self._handshake_timeout_handle = \
             self._loop.call_later(self._ssl_handshake_timeout,
                                   self._check_handshake_timeout)
&lt;/pre&gt;
&lt;p&gt;Yury Selivanov wrote:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;The fix is correct and the bug is now obvious&lt;/strong&gt;: &lt;tt class="docutils literal"&gt;data_received()&lt;/tt&gt; occurs
pretty much any time after &lt;tt class="docutils literal"&gt;connection_made()&lt;/tt&gt; call; if &lt;tt class="docutils literal"&gt;call_soon()&lt;/tt&gt; is
used in &lt;tt class="docutils literal"&gt;connection_made()&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;data_received()&lt;/tt&gt; may find the protocol in
an incorrect state.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Kudos Victor for debugging this.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I pushed &lt;a class="reference external" href="https://github.com/python/cpython/commit/be00a5583a2cb696335c527b921d1868266a42c6"&gt;commit be00a558&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit be00a5583a2cb696335c527b921d1868266a42c6
Author: Victor Stinner &amp;lt;vstinner&amp;#64;redhat.com&amp;gt;
Date:   Tue May 29 01:33:35 2018 +0200

    bpo-33674: asyncio: Fix SSLProtocol race (GH-7175)

    Fix a race condition in SSLProtocol.connection_made() of
    asyncio.sslproto: start immediately the handshake instead of using
    call_soon(). Previously, data_received() could be called before the
    handshake started, causing the handshake to hang or fail.
&lt;/pre&gt;
&lt;p&gt;... the change is basically a single line change:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
- self._loop.call_soon(self._process_write_backlog)
+ self._process_write_backlog()
&lt;/pre&gt;
&lt;p&gt;I closed &lt;a class="reference external" href="https://bugs.python.org/issue32458"&gt;bpo-32458&lt;/a&gt; and &lt;strong&gt;Yury
Selivanov&lt;/strong&gt; closed &lt;a class="reference external" href="https://bugs.python.org/issue33674"&gt;bpo-33674&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="not-a-regression"&gt;
&lt;h3&gt;Not a regression&lt;/h3&gt;
&lt;p&gt;The SSLProtocol race condition wasn't new: it existed since January 2015,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/231b404cb026649d4b7172e75ac394ef558efe60"&gt;commit 231b404c&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 231b404cb026649d4b7172e75ac394ef558efe60
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Wed Jan 14 00:19:09 2015 +0100

    Issue #22560: New SSL implementation based on ssl.MemoryBIO

    The new SSL implementation is based on the new ssl.MemoryBIO which is only
    available on Python 3.5. On Python 3.4 and older, the legacy SSL implementation
    (using SSL_write, SSL_read, etc.) is used. The proactor event loop only
    supports the new implementation.

    The new asyncio.sslproto module adds _SSLPipe, SSLProtocol and
    _SSLProtocolTransport classes. _SSLPipe allows to &amp;quot;wrap&amp;quot; or &amp;quot;unwrap&amp;quot; a socket
    (switch between cleartext and SSL/TLS).

    Patch written by Antoine Pitrou. sslproto.py is based on gruvi/ssl.py of the
    gruvi project written by Geert Jansen.

    This change adds SSL support to ProactorEventLoop on Python 3.5 and newer!

    It becomes also possible to implement STARTTTLS: switch a cleartext socket to
    SSL.
&lt;/pre&gt;
&lt;p&gt;This is the new cool asynchronous SSL implementation written by &lt;strong&gt;Antoine
Pitrou&lt;/strong&gt; and &lt;strong&gt;Geert Jansen&lt;/strong&gt;. It took &lt;strong&gt;3 years&lt;/strong&gt; and &lt;strong&gt;new functional tests&lt;/strong&gt;
to discover the race condition.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="wsarecv-cancellation-causing-data-loss"&gt;
&lt;h2&gt;WSARecv() cancellation causing data loss&lt;/h2&gt;
&lt;div class="section" id="yet-another-very-boring-buildbot-test-failure"&gt;
&lt;h3&gt;Yet another very boring buildbot test failure&lt;/h3&gt;
&lt;p&gt;At May 30, 2018, the day after I fixed SSLProtocol race condition, I created
&lt;a class="reference external" href="https://bugs.python.org/issue33694"&gt;bpo-33694&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;test_asyncio.test_start_tls_server_1() got multiple fixes recently (see
&lt;a class="reference external" href="https://bugs.python.org/issue32458"&gt;bpo-32458&lt;/a&gt; and &lt;a class="reference external" href="https://bugs.python.org/issue33674"&gt;bpo-33674&lt;/a&gt;)... but it still fails on Python on x86
Windows7 3.x at revision bb9474f1fb2fc7c7ed9f826b78262d6a12b5f9e8 which
contains all these fixes.&lt;/p&gt;
&lt;p&gt;The test fails even when test_asyncio is re-run alone (not when other tests run
in parallel).&lt;/p&gt;
&lt;p&gt;Example of failure:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ERROR: test_start_tls_server_1 (test.test_asyncio.test_sslproto.ProactorStartTLSTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &amp;quot;...\lib\test\test_asyncio\test_sslproto.py&amp;quot;, line 467, in test_start_tls_server_1
    self.loop.run_until_complete(run_main())
  File &amp;quot;...\lib\asyncio\base_events.py&amp;quot;, line 566, in run_until_complete
    raise RuntimeError('Event loop stopped before Future completed.')
RuntimeError: Event loop stopped before Future completed.
&lt;/pre&gt;
&lt;p&gt;The test fails also on x86 Windows7 3.7. Moreover, 3.7 got an additional failure:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ERROR: test_pipe_handle (test.test_asyncio.test_windows_utils.PipeTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &amp;quot;...\lib\test\test_asyncio\test_windows_utils.py&amp;quot;, line 73, in test_pipe_handle
    raise RuntimeError('expected ERROR_INVALID_HANDLE')
RuntimeError: expected ERROR_INVALID_HANDLE
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="unable-to-reproduce-the-bug"&gt;
&lt;h3&gt;Unable to reproduce the bug&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Yury Selivanov&lt;/strong&gt; &lt;a class="reference external" href="https://bugs.python.org/issue33694#msg318193"&gt;failed to reproduce the issue&lt;/a&gt; in Windows 7 VM (on macOS) using:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;run &lt;tt class="docutils literal"&gt;test_asyncio&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;run &lt;tt class="docutils literal"&gt;test_asyncio.test_sslproto&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;run &lt;tt class="docutils literal"&gt;test_asyncio.test_sslproto &lt;span class="pre"&gt;-m&lt;/span&gt; test_start_tls_server_1&lt;/tt&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Andrew Svetlov&lt;/strong&gt; &lt;a class="reference external" href="https://bugs.python.org/issue33694#msg318194"&gt;added&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
I used &lt;tt class="docutils literal"&gt;SNDBUF&lt;/tt&gt; to enforce send buffer overloading. It is not required by
sendfile tests but I thought that better to have non-mocked way to test such
situations. We can remove the socket buffers size manipulation at all
without any problem.&lt;/blockquote&gt;
&lt;p&gt;But Yury Selivanov &lt;a class="reference external" href="https://bugs.python.org/issue33694#msg318195"&gt;replied&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
When I tried to do that I think &lt;strong&gt;I was having more failures&lt;/strong&gt; with that
test. But really up to you.&lt;/blockquote&gt;
&lt;p&gt;Next days, I reported more and more similar failures on Windows buildbots and
AppVeyor (our Windows CI).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="root-issue-identified-pause-reading"&gt;
&lt;h3&gt;Root issue identified: pause_reading()&lt;/h3&gt;
&lt;p&gt;Since this bug became more and more frequent, I decided to work on it. Yury and
Andrew failed to reproduce it.&lt;/p&gt;
&lt;p&gt;At June 7, 2018, I managed to &lt;strong&gt;reproduce the bug on Linux&lt;/strong&gt; by &lt;a class="reference external" href="https://bugs.python.org/issue33694#msg318869"&gt;inserting a
sleep at the right place&lt;/a&gt;...
I understood one hour later that my patch is wrong: &amp;quot;it introduces a bug in
the test&amp;quot;.&lt;/p&gt;
&lt;p&gt;On the other hand, I found the root cause: calling &lt;tt class="docutils literal"&gt;pause_reading()&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;resume_reading()&lt;/tt&gt; on the transport is not safe. Sometimes, we loose data.
See the &lt;strong&gt;ugly hack&lt;/strong&gt; described in the TODO comment below:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
class _ProactorReadPipeTransport(_ProactorBasePipeTransport,
                                 transports.ReadTransport):
    &amp;quot;&amp;quot;&amp;quot;Transport for read pipes.&amp;quot;&amp;quot;&amp;quot;
    (...)
    def pause_reading(self):
        if self._closing or self._paused:
            return
        self._paused = True

        if self._read_fut is not None and not self._read_fut.done():
            # TODO: This is an ugly hack to cancel the current read future
            # *and* avoid potential race conditions, as read cancellation
            # goes through `future.cancel()` and `loop.call_soon()`.
            # We then use this special attribute in the reader callback to
            # exit *immediately* without doing any cleanup/rescheduling.
            self._read_fut.__asyncio_cancelled_on_pause__ = True

            self._read_fut.cancel()
            self._read_fut = None
            self._reschedule_on_resume = True

        if self._loop.get_debug():
            logger.debug(&amp;quot;%r pauses reading&amp;quot;, self)
&lt;/pre&gt;
&lt;p&gt;If you remove the &amp;quot;ugly hack&amp;quot;, the test no longer hangs...&lt;/p&gt;
&lt;p&gt;Extract of &lt;tt class="docutils literal"&gt;_ProactorReadPipeTransport.set_transport()&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
if self.is_reading():
    # reset reading callback / buffers / self._read_fut
    self.pause_reading()
    self.resume_reading()
&lt;/pre&gt;
&lt;p&gt;This method &lt;strong&gt;cancels the pending overlapped&lt;/strong&gt; &lt;tt class="docutils literal"&gt;WSARecv()&lt;/tt&gt;, and then creates
a new overlapped &lt;tt class="docutils literal"&gt;WSARecv()&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Even after &lt;tt class="docutils literal"&gt;CancelIoEx(old overlapped)&lt;/tt&gt;, the IOCP loop still gets an event
for the completion of the cancelled overlapped &lt;tt class="docutils literal"&gt;WSARecv()&lt;/tt&gt;. Problem: &lt;strong&gt;since
the Python future is cancelled, the event is ignored and so 176 bytes of data
are lost&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;I'm surprised that an overlapped &lt;tt class="docutils literal"&gt;WSARecv()&lt;/tt&gt; &lt;strong&gt;cancelled&lt;/strong&gt; by
&lt;tt class="docutils literal"&gt;CancelIoEx()&lt;/tt&gt; still returns data when IOCP polls for events.&lt;/p&gt;
&lt;p&gt;Something else. The bug occurs when &lt;tt class="docutils literal"&gt;CancelIoEx()&lt;/tt&gt; (on the current overlapped
&lt;tt class="docutils literal"&gt;WSARecv()&lt;/tt&gt;) fails internally with &lt;tt class="docutils literal"&gt;ERROR_NOT_FOUND&lt;/tt&gt;. According to
overlapped.c, it means:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
/* CancelIoEx returns ERROR_NOT_FOUND if the I/O completed in-between */
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;HasOverlappedIoCompleted()&lt;/tt&gt; returns 0 in that case.&lt;/p&gt;
&lt;p&gt;The problem is that currently, &lt;tt class="docutils literal"&gt;Overlapped.cancel()&lt;/tt&gt; also returns &lt;tt class="docutils literal"&gt;None&lt;/tt&gt; in
that case, and later the asyncio IOCP loop ignores the completion event and so
&lt;strong&gt;drops incoming received data&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="release-blocker-bug"&gt;
&lt;h3&gt;Release blocker bug?&lt;/h3&gt;
&lt;p&gt;Yury, Andrew, Ned: I set the priority to release blocker because I'm scared by
what I saw. The START TLS has a race condition in its ProactorEventLoop
implementation. But the bug doesn't see to be specific to START TLS, but rather
to &lt;tt class="docutils literal"&gt;transport.set_transport()&lt;/tt&gt;, and even more generally to
&lt;tt class="docutils literal"&gt;transport.pause_reading()&lt;/tt&gt; / &lt;tt class="docutils literal"&gt;transport.resume_reading()&lt;/tt&gt;. The bug is quite
severe: we loose data and it's really hard to know why (I spent a few hours to
add many many print and try to reproduce on a very tiny reliable unit test). As
an asyncio user, I expect that transports are 100% reliable, and I would first
look into my code (like looking into &lt;tt class="docutils literal"&gt;start_tls()&lt;/tt&gt; implementation in my case).&lt;/p&gt;
&lt;p&gt;If the bug was very specific to &lt;tt class="docutils literal"&gt;start_tls()&lt;/tt&gt;, I would suggest to &amp;quot;just&amp;quot;
&amp;quot;disable&amp;quot; start_tls() on ProactorEventLoop (sorry, Windows!). But since the
data loss seems to concern basically any application using
&lt;tt class="docutils literal"&gt;ProactorEventLoop&lt;/tt&gt;, I don't see any simple workaround.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;My hope is that a fix can be written shortly&lt;/strong&gt; to not block the 3.7.0 final
release for too long :-(&lt;/p&gt;
&lt;p&gt;Yury, Andrew: Can you please just confirm that it's a regression and that a
release blocker is justified?&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="functional-test-reproducing-the-bug"&gt;
&lt;h3&gt;Functional test reproducing the bug&lt;/h3&gt;
&lt;p&gt;I wrote &lt;a class="reference external" href="https://bugs.python.org/file47632/race.py"&gt;race.py script&lt;/a&gt;: simple
echo client and server sending packets in both directions.  Pause/resume
reading the client transport every 100 ms to trigger the bug.&lt;/p&gt;
&lt;p&gt;Using &lt;tt class="docutils literal"&gt;ProactorEventLoop&lt;/tt&gt; and 2000 packets of 16 KiB, I easily reproduce the
bug.&lt;/p&gt;
&lt;p&gt;So again, it's nothing related to &lt;tt class="docutils literal"&gt;start_tls()&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;start_tls()&lt;/tt&gt; was just one
way to spot the bug.&lt;/p&gt;
&lt;p&gt;The bug is in Proactor transport: the cancellation of overlapped &lt;tt class="docutils literal"&gt;WSARecv()&lt;/tt&gt;
sometime drops packets. The bug occurs when &lt;tt class="docutils literal"&gt;CancelIoEx()&lt;/tt&gt; fails with
&lt;tt class="docutils literal"&gt;ERROR_NOT_FOUND&lt;/tt&gt; which means that the I/O (&lt;tt class="docutils literal"&gt;WSARecv()&lt;/tt&gt;) completed.&lt;/p&gt;
&lt;p&gt;One solution would be to not cancel &lt;tt class="docutils literal"&gt;WSARecv()&lt;/tt&gt; on pause_reading(): wait
until the current &lt;tt class="docutils literal"&gt;WSARecv()&lt;/tt&gt; completes, store data somewhere but don't pass
it to &lt;tt class="docutils literal"&gt;protocol.data_received()&lt;/tt&gt;, and don't schedule a new &lt;tt class="docutils literal"&gt;WSARecv()&lt;/tt&gt;.
Once reading is resumed: call &lt;tt class="docutils literal"&gt;protocol.data_received()&lt;/tt&gt; and schedule a new
&lt;tt class="docutils literal"&gt;WSARecv()&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;That would be a workaround. I don't know how to really fix &lt;tt class="docutils literal"&gt;WSARecv()&lt;/tt&gt;
cancellation without loosing data. A good start would be to modify
&lt;tt class="docutils literal"&gt;Overlapped.cancel()&lt;/tt&gt; to return a boolean to notice if the overlapped I/O
completed even if we just cancelled it. Currently, the corner case
(&lt;tt class="docutils literal"&gt;CancelIoEx()&lt;/tt&gt; fails with &lt;tt class="docutils literal"&gt;ERROR_NOT_FOUND&lt;/tt&gt;) is silently ignored, and then
the IOCP loop silently ignores the event of completed I/O...&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="fix-the-bug-no-longer-cancel-wsarecv"&gt;
&lt;h3&gt;Fix the bug: no longer cancel WSARecv()&lt;/h3&gt;
&lt;p&gt;At June 8, 2018, I pushed &lt;a class="reference external" href="https://github.com/python/cpython/commit/79790bc35fe722a49977b52647f9b5fe1deda2b7"&gt;commit 79790bc3&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 79790bc35fe722a49977b52647f9b5fe1deda2b7
Author: Victor Stinner &amp;lt;vstinner&amp;#64;redhat.com&amp;gt;
Date:   Fri Jun 8 00:25:52 2018 +0200

    bpo-33694: Fix race condition in asyncio proactor (GH-7498)

    The cancellation of an overlapped WSARecv() has a race condition
    which causes data loss because of the current implementation of
    proactor in asyncio.

    No longer cancel overlapped WSARecv() in _ProactorReadPipeTransport
    to work around the race condition.

    Remove the optimized recv_into() implementation to get simple
    implementation of pause_reading() using the single _pending_data
    attribute.

    Move _feed_data_to_bufferred_proto() to protocols.py.

    Remove set_protocol() method which became useless.
&lt;/pre&gt;
&lt;p&gt;I fixed the root issue (in Python 3.7 and future Python 3.8).&lt;/p&gt;
&lt;p&gt;I used my &lt;tt class="docutils literal"&gt;race.py&lt;/tt&gt; script to validate that the issue is fixed for real.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;I fixed one race condition in the asynchronous handshake of &lt;tt class="docutils literal"&gt;SSLProtocol&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;I found and fixed a data loss bug caused by &lt;tt class="docutils literal"&gt;WSARecv()&lt;/tt&gt; cancellation.&lt;/p&gt;
&lt;p&gt;Lessons learnt from these two bugs:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;You should &lt;strong&gt;write an extensive test suite&lt;/strong&gt; for your code.&lt;/li&gt;
&lt;li&gt;You should &lt;strong&gt;keep an eye on your continuous integration (CI)&lt;/strong&gt;: any tiny test
failure can hide a very severe bug.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content><category term="cpython"></category><category term="asyncio"></category></entry><entry><title>Asyncio: Proactor ConnectPipe() Race Condition</title><link href="https://vstinner.github.io/asyncio-proactor-connect-pipe-race-condition.html" rel="alternate"></link><published>2019-01-30T18:00:00+01:00</published><updated>2019-01-30T18:00:00+01:00</updated><author><name>Victor Stinner</name></author><id>tag:vstinner.github.io,2019-01-30:/asyncio-proactor-connect-pipe-race-condition.html</id><summary type="html">&lt;a class="reference external image-reference" href="https://www.flickr.com/photos/phrawr/7612947262/"&gt;&lt;img alt="Pipes" src="https://vstinner.github.io/images/pipes.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;Between December 2014 and January 2015, once I succeeded to fix the root issue
of the random asyncio crashes on Windows (&lt;a class="reference external" href="https://vstinner.github.io/asyncio-proactor-cancellation-from-hell.html"&gt;Proactor Cancellation From Hell&lt;/a&gt;), I fixed more race conditions
and bugs in &lt;tt class="docutils literal"&gt;ProactorEventLoop&lt;/tt&gt;:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;ConnectPipe()&lt;/tt&gt; Race Condition&lt;/li&gt;
&lt;li&gt;Race Condition in &lt;tt class="docutils literal"&gt;BaseSubprocessTransport._try_finish()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;Close the transport on failure: ResourceWarning&lt;/li&gt;
&lt;li&gt;Cleanup code …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;a class="reference external image-reference" href="https://www.flickr.com/photos/phrawr/7612947262/"&gt;&lt;img alt="Pipes" src="https://vstinner.github.io/images/pipes.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;Between December 2014 and January 2015, once I succeeded to fix the root issue
of the random asyncio crashes on Windows (&lt;a class="reference external" href="https://vstinner.github.io/asyncio-proactor-cancellation-from-hell.html"&gt;Proactor Cancellation From Hell&lt;/a&gt;), I fixed more race conditions
and bugs in &lt;tt class="docutils literal"&gt;ProactorEventLoop&lt;/tt&gt;:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;ConnectPipe()&lt;/tt&gt; Race Condition&lt;/li&gt;
&lt;li&gt;Race Condition in &lt;tt class="docutils literal"&gt;BaseSubprocessTransport._try_finish()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;Close the transport on failure: ResourceWarning&lt;/li&gt;
&lt;li&gt;Cleanup code handling pipes&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Previous article: &lt;a class="reference external" href="https://vstinner.github.io/asyncio-proactor-cancellation-from-hell.html"&gt;Proactor Cancellation From Hell&lt;/a&gt;. Next article:
&lt;a class="reference external" href="https://vstinner.github.io/asyncio-proactor-wsarecv-cancellation-data-loss.html"&gt;asyncio: WSARecv() cancellation causing data loss&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="connectpipe-race-condition"&gt;
&lt;h2&gt;ConnectPipe() Race Condition&lt;/h2&gt;
&lt;p&gt;Once I succeeded to fix the root issue of the random asyncio crashes on Windows
(&lt;a class="reference external" href="https://vstinner.github.io/asyncio-proactor-cancellation-from-hell.html"&gt;Proactor Cancellation From Hell&lt;/a&gt;), I started to look at the
ConnectPipe special case: &lt;a class="reference external" href="https://github.com/python/asyncio/issues/204"&gt;asyncio issue #204: Investigate
IocpProactor.accept_pipe() special case (don't register overlapped)&lt;/a&gt; (issue created at 25 Aug
2014).&lt;/p&gt;
&lt;p&gt;At January 21, 2015, I opened &lt;a class="reference external" href="https://bugs.python.org/issue23293"&gt;bpo-23293: race condition related to
IocpProactor.connect_pipe()&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;While fixing &lt;a class="reference external" href="https://bugs.python.org/issue23095"&gt;bpo-23095 (race condition when cancelling a _WaitHandleFuture)&lt;/a&gt;, I saw that
&lt;tt class="docutils literal"&gt;IocpProactor.connect_pipe()&lt;/tt&gt; causes &amp;quot;GetQueuedCompletionStatus() returned an
unexpected event&amp;quot; messages to be logged, but also to hang the test suite.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;IocpProactor._register()&lt;/tt&gt; contains the comment:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# Even if GetOverlappedResult() was called, we have to wait for the
# notification of the completion in GetQueuedCompletionStatus().
# Register the overlapped operation to keep a reference to the
# OVERLAPPED object, otherwise the memory is freed and Windows may
# read uninitialized memory.
#
# For an unknown reason, ConnectNamedPipe() behaves differently:
# the completion is not notified by GetOverlappedResult() if we
# already called GetOverlappedResult(). For this specific case, we
# don't expect notification (register is set to False).
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;IocpProactor.close()&lt;/tt&gt; contains this comment:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# The operation was started with connect_pipe() which
# queues a task to Windows' thread pool.  This cannot
# be cancelled, so just forget it.
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;IocpProactor.connect_pipe()&lt;/tt&gt; is implemented with &lt;tt class="docutils literal"&gt;QueueUserWorkItem()&lt;/tt&gt;
which &lt;strong&gt;starts a thread that cannot be interrupted&lt;/strong&gt;. Because of that, this
function requires special cases in &lt;tt class="docutils literal"&gt;_register()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;close()&lt;/tt&gt; methods of
&lt;tt class="docutils literal"&gt;IocpProactor&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;I proposed a solution to reimplement &lt;tt class="docutils literal"&gt;IocpProactor.connect_pipe()&lt;/tt&gt; &lt;strong&gt;without
a thread&lt;/strong&gt;: &lt;a class="reference external" href="https://code.google.com/p/tulip/issues/detail?id=197"&gt;asyncio issue #197: Rewrite IocpProactor.connect_pipe() with
non-blocking calls to avoid non interruptible QueueUserWorkItem()&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;At January 22, 2015, I pushed &lt;a class="reference external" href="https://github.com/python/cpython/commit/7ffa2c5fdda8a9cc254edf67c4458b15db1252fa"&gt;commit 7ffa2c5f&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 7ffa2c5fdda8a9cc254edf67c4458b15db1252fa
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Thu Jan 22 22:55:08 2015 +0100

    Issue #23293, asyncio: Rewrite IocpProactor.connect_pipe()
&lt;/pre&gt;
&lt;p&gt;The change adds &lt;tt class="docutils literal"&gt;_overlapped.ConnectPipe()&lt;/tt&gt; which tries to connect to the
pipe for asynchronous I/O (overlapped): &lt;strong&gt;call CreateFile() in a loop until
it doesn't fail with ERROR_PIPE_BUSY&lt;/strong&gt;. Use an increasing delay between 1 ms
and 100 ms.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="race-condition-in-basesubprocesstransport-try-finish"&gt;
&lt;h2&gt;Race Condition in BaseSubprocessTransport._try_finish()&lt;/h2&gt;
&lt;p&gt;If the process exited before the &lt;tt class="docutils literal"&gt;_post_init()&lt;/tt&gt; method was called, scheduling
the call to &lt;tt class="docutils literal"&gt;_call_connection_lost()&lt;/tt&gt; with &lt;tt class="docutils literal"&gt;call_soon()&lt;/tt&gt; is wrong:
&lt;tt class="docutils literal"&gt;connection_made()&lt;/tt&gt; must be called before &lt;tt class="docutils literal"&gt;connection_lost()&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Reuse the &lt;tt class="docutils literal"&gt;BaseSubprocessTransport._call()&lt;/tt&gt; method to schedule the call to
&lt;tt class="docutils literal"&gt;_call_connection_lost()&lt;/tt&gt; to ensure that &lt;tt class="docutils literal"&gt;connection_made()&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;connection_lost()&lt;/tt&gt; are called in the correct order.&lt;/p&gt;
&lt;p&gt;At Dec 18, 2014, I pushed &lt;a class="reference external" href="https://github.com/python/cpython/commit/1b9763d0a9c62c13dc2a06770032e5906b610c96"&gt;commit 1b9763d0&lt;/a&gt;.
The explanation is long, but the change is basically a single line change,
extract:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
- self._loop.call_soon(self._call_connection_lost, None)
+ self._call(self._call_connection_lost, None)
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Ordering properly callbacks in asyncio is challenging!&lt;/strong&gt; The order matters
for the semantics of asyncio: it is part of the design of the &lt;a class="reference external" href="https://www.python.org/dev/peps/pep-3156/"&gt;PEP 3156 --
Asynchronous IO Support Rebooted: the &amp;quot;asyncio&amp;quot; Module&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="close-the-transport-on-failure-resourcewarning"&gt;
&lt;h2&gt;Close the transport on failure: ResourceWarning&lt;/h2&gt;
&lt;p&gt;At January 15, 2015, I pushed &lt;a class="reference external" href="https://github.com/python/cpython/commit/4bf22e033e975f61c33752db5a3764dc0f7d0b03"&gt;commit 4bf22e03&lt;/a&gt;,
extract:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
-  yield from transp._post_init()
+  try:
+      yield from transp._post_init()
+  except:
+      transp.close()
+      raise
&lt;/pre&gt;
&lt;p&gt;Later, I will spend a lot of time (push many more changes) to ensure that
resources are properly released (especially close transports on failure,
similar to this change).&lt;/p&gt;
&lt;p&gt;I will add many &lt;strong&gt;ResourceWarnings&lt;/strong&gt; warnings in destructors when a transport,
subprocess or event loop is not closed explicitly.&lt;/p&gt;
&lt;p&gt;For example, notice the &lt;tt class="docutils literal"&gt;ResourceWarnings&lt;/tt&gt; in the current destructor of
&lt;tt class="docutils literal"&gt;_SelectorTransport&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
class _SelectorTransport(transports._FlowControlMixin,
                         transports.Transport):

    def __del__(self, _warn=warnings.warn):
        if self._sock is not None:
            _warn(f&amp;quot;unclosed transport {self!r}&amp;quot;, ResourceWarning, source=self)
            self._sock.close()
&lt;/pre&gt;
&lt;p&gt;I even enhanced Python 3.6 to be able to provide the &lt;strong&gt;traceback where the
leaked resource has been allocated&lt;/strong&gt; thanks to my &lt;tt class="docutils literal"&gt;tracemalloc&lt;/tt&gt; module.
Example with &lt;tt class="docutils literal"&gt;filebug.py&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
def func():
    f = open(__file__)
    f = None

func()
&lt;/pre&gt;
&lt;p&gt;Output with Python 3.6:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ python3 -Wd -X tracemalloc=5 filebug.py
filebug.py:3: ResourceWarning: unclosed file &amp;lt;_io.TextIOWrapper name='filebug.py' mode='r' encoding='UTF-8'&amp;gt;
  f = None
Object allocated at (most recent call first):
  File &amp;quot;filebug.py&amp;quot;, lineno 2
    f = open(__file__)
  File &amp;quot;filebug.py&amp;quot;, lineno 5
    func()
&lt;/pre&gt;
&lt;p&gt;The line where the warning is emitted is usually useless to understand the bug,
whereas the traceback is very useful to identify the leaked resource.&lt;/p&gt;
&lt;p&gt;See &lt;a class="reference external" href="https://pythondev.readthedocs.io/debug_tools.html#resourcewarning"&gt;my ResourceWarning documentation&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="cleanup-code-handling-pipes"&gt;
&lt;h2&gt;Cleanup code handling pipes&lt;/h2&gt;
&lt;p&gt;Thanks to the new implementation of &lt;tt class="docutils literal"&gt;connect_pipe()&lt;/tt&gt;, I was able to push
changes to simplify the code and remove various hacks in code handling pipes.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/python/cpython/commit/2b77c5467f376257ae22cbfbcb3a0e5e6349e92d"&gt;commit 2b77c546&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 2b77c5467f376257ae22cbfbcb3a0e5e6349e92d
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Thu Jan 22 23:50:03 2015 +0100

    asyncio, Tulip issue 204: Fix IocpProactor.accept_pipe()

    Overlapped.ConnectNamedPipe() now returns a boolean: True if the pipe is
    connected (if ConnectNamedPipe() failed with ERROR_PIPE_CONNECTED), False if
    the connection is in progress.

    This change removes multiple hacks in IocpProactor.
&lt;/pre&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/python/cpython/commit/3d2256f671b7ed5c769dd34b27ae597cbc69047c"&gt;commit 3d2256f6&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 3d2256f671b7ed5c769dd34b27ae597cbc69047c
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Mon Jan 26 11:02:59 2015 +0100

    Issue #23293, asyncio: Cleanup IocpProactor.close()

    The special case for connect_pipe() is not more needed. connect_pipe() doesn't
    use overlapped operations anymore.
&lt;/pre&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/python/cpython/commit/a19b7b3fcafe52b98245e14466ffc4d6750ca4f1"&gt;commit a19b7b3f&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit a19b7b3fcafe52b98245e14466ffc4d6750ca4f1
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Mon Jan 26 15:03:20 2015 +0100

    asyncio: Fix ProactorEventLoop.start_serving_pipe()

    If a client connected before the server was closed: drop the client (close the
    pipe) and exit.
&lt;/pre&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/python/cpython/commit/e0fd157ba0cc92e435e7520b4ff641ca68d72244"&gt;commit e0fd157b&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit e0fd157ba0cc92e435e7520b4ff641ca68d72244
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Mon Jan 26 15:04:03 2015 +0100

    Issue #23293, asyncio: Rewrite IocpProactor.connect_pipe() as a coroutine

    Use a coroutine with asyncio.sleep() instead of call_later() to ensure that the
    schedule call is cancelled.

    Add also a unit test cancelling connect_pipe().
&lt;/pre&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/python/cpython/commit/41063d2a59a24e257cd9ce62137e36c862e3ab1e"&gt;commit 41063d2a&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 41063d2a59a24e257cd9ce62137e36c862e3ab1e
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Mon Jan 26 22:30:49 2015 +0100

    asyncio, Tulip issue 204: Fix IocpProactor.recv()

    If ReadFile() fails with ERROR_BROKEN_PIPE, the operation is not pending: don't
    register the overlapped.

    I don't know if WSARecv() can fail with ERROR_BROKEN_PIPE. Since
    Overlapped.WSARecv() already handled ERROR_BROKEN_PIPE, let me guess that it
    has the same behaviour than ReadFile().
&lt;/pre&gt;
&lt;/div&gt;
</content><category term="cpython"></category><category term="asyncio"></category></entry><entry><title>Asyncio: Proactor Cancellation From Hell</title><link href="https://vstinner.github.io/asyncio-proactor-cancellation-from-hell.html" rel="alternate"></link><published>2019-01-28T20:20:00+01:00</published><updated>2019-01-28T20:20:00+01:00</updated><author><name>Victor Stinner</name></author><id>tag:vstinner.github.io,2019-01-28:/asyncio-proactor-cancellation-from-hell.html</id><summary type="html">&lt;img alt="South Park Hell" src="https://vstinner.github.io/images/south_park_hell.jpg" /&gt;
&lt;p&gt;Between 2014 and 2015, I was working on the new shiny &lt;tt class="docutils literal"&gt;asyncio&lt;/tt&gt; module
(module added to Python 3.4 released in March 2014). I helped to stabilize the
Windows implementation because... well, nobody else was paying attention to it,
and I was worried that test_asyncio &lt;strong&gt;randomly crashed&lt;/strong&gt; on Windows.&lt;/p&gt;
&lt;p&gt;One …&lt;/p&gt;</summary><content type="html">&lt;img alt="South Park Hell" src="https://vstinner.github.io/images/south_park_hell.jpg" /&gt;
&lt;p&gt;Between 2014 and 2015, I was working on the new shiny &lt;tt class="docutils literal"&gt;asyncio&lt;/tt&gt; module
(module added to Python 3.4 released in March 2014). I helped to stabilize the
Windows implementation because... well, nobody else was paying attention to it,
and I was worried that test_asyncio &lt;strong&gt;randomly crashed&lt;/strong&gt; on Windows.&lt;/p&gt;
&lt;p&gt;One bug really annoyed me, I started to fix it in July 2014, but I only
succeeded to &lt;strong&gt;fix the root issue&lt;/strong&gt; in January 2015: &lt;strong&gt;six months later&lt;/strong&gt;!&lt;/p&gt;
&lt;p&gt;It was really difficult to find documentation on IOCP and asynchronous
programming on Windows. &lt;strong&gt;I had to ask for help to someone who had access to
the Windows source code&lt;/strong&gt; to understand the bug...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spoiler:&lt;/strong&gt; cancelling an overlapped &lt;tt class="docutils literal"&gt;RegisterWaitForSingleObject()&lt;/tt&gt; with
&lt;tt class="docutils literal"&gt;UnregisterWait()&lt;/tt&gt; is asynchronous. The asynchronous part is not well
documented and it took me months of debug to understand it. Moreover, the bug
was well hidden for various reasons that we will see below.&lt;/p&gt;
&lt;p&gt;Next article: &lt;a class="reference external" href="https://vstinner.github.io/asyncio-proactor-connect-pipe-race-condition.html"&gt;Asyncio: Proactor ConnectPipe() Race Condition&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="fix-cancel-when-called-twice"&gt;
&lt;h2&gt;Fix cancel() when called twice&lt;/h2&gt;
&lt;p&gt;July 2014, &lt;a class="reference external" href="https://github.com/python/asyncio/issues/195"&gt;asyncio issue #195&lt;/a&gt;: while working on a
&lt;tt class="docutils literal"&gt;SIGINT&lt;/tt&gt; signal handler for the &lt;tt class="docutils literal"&gt;ProactorEventLoop&lt;/tt&gt; on Windows (&lt;a class="reference external" href="https://github.com/python/asyncio/issues/195"&gt;asyncio
issue #191&lt;/a&gt;), I hit a bug on
Windows: &lt;tt class="docutils literal"&gt;_WaitHandleFuture.cancel()&lt;/tt&gt; crash if the wait event was already
unregistered by &lt;tt class="docutils literal"&gt;finish_wait_for_handle()&lt;/tt&gt;. The bug was that
&lt;tt class="docutils literal"&gt;UnregisterWait()&lt;/tt&gt; was called twice.&lt;/p&gt;
&lt;p&gt;I pushed &lt;a class="reference external" href="https://github.com/python/cpython/commit/fea6a100dc51012cb0187374ad31de330ebc0035"&gt;commit fea6a100&lt;/a&gt;
to fix this crash:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit fea6a100dc51012cb0187374ad31de330ebc0035
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Fri Jul 25 00:54:53 2014 +0200

    Improve stability of the proactor event loop, especially operations on
    overlapped objects (...)
&lt;/pre&gt;
&lt;p&gt;Main changes:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Fix a crash: &lt;strong&gt;don't call UnregisterWait() twice if a _WaitHandleFuture
is cancelled twice&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Fix another crash: &lt;tt class="docutils literal"&gt;_OverlappedFuture.cancel()&lt;/tt&gt; doesn't cancel the
overlapped anymore if it is already cancelled or completed. Log also an error
if the cancellation failed.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;IocpProactor.close()&lt;/tt&gt; now cancels futures rather than cancelling directly
underlaying overlapped objects.&lt;/li&gt;
&lt;li&gt;Add a destructor to the &lt;tt class="docutils literal"&gt;IocpProactor&lt;/tt&gt; class which closes it&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="clear-reference-from-overlappedfuture-to-overlapped"&gt;
&lt;h2&gt;Clear reference from _OverlappedFuture to overlapped&lt;/h2&gt;
&lt;p&gt;July 2014, I created &lt;a class="reference external" href="https://github.com/python/asyncio/issues/196"&gt;asyncio issue #196&lt;/a&gt;:
&lt;tt class="docutils literal"&gt;_OverlappedFuture.set_result()&lt;/tt&gt; should clear the its reference to the
overlapped object.&lt;/p&gt;
&lt;p&gt;It is important to explicitly clear references to Python objects as soon as
possible to release resources. Otherwise, an object can remain alive
longer than expected.&lt;/p&gt;
&lt;p&gt;I noticed that _OverlappedFuture kept a reference to the undelying overlapped
object even after the asynchronous operation completed. I started to work on a
fix but I had many issues to fix completely this bug... it is just the
beginning of a long journey.&lt;/p&gt;
&lt;div class="section" id="clear-the-reference-on-cancellation-and-error"&gt;
&lt;h3&gt;Clear the reference on cancellation and error&lt;/h3&gt;
&lt;p&gt;I pushed a first fix: &lt;a class="reference external" href="https://github.com/python/cpython/commit/18a28dc5c28ae9a953f537486780159ddb768702"&gt;commit 18a28dc5&lt;/a&gt;
clears the reference to the overlapped in &lt;tt class="docutils literal"&gt;cancel()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;set_exception()&lt;/tt&gt;
methods of &lt;tt class="docutils literal"&gt;_OverlappedFuture&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 18a28dc5c28ae9a953f537486780159ddb768702
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Fri Jul 25 13:05:20 2014 +0200

    * _OverlappedFuture.cancel() now clears its reference to the overlapped object.
      Make also the _OverlappedFuture.ov attribute private.
    * _OverlappedFuture.set_exception() now cancels the overlapped operation.
    * (...)
&lt;/pre&gt;
&lt;p&gt;I started by this change because it didn't make the tests less stable.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="clear-the-reference-in-poll"&gt;
&lt;h3&gt;Clear the reference in poll()&lt;/h3&gt;
&lt;p&gt;Clearing the reference to the overlapped in &lt;tt class="docutils literal"&gt;cancel()&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;set_exception()&lt;/tt&gt; &lt;strong&gt;works well&lt;/strong&gt;. But when I try to do the same on success (in
&lt;tt class="docutils literal"&gt;set_result()&lt;/tt&gt;), &lt;strong&gt;I get random errors&lt;/strong&gt;. Example:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
C:\haypo\tulip&amp;gt;\python33\python.exe runtests.py test_pipe
...
Exception RuntimeError: '&amp;lt;_overlapped.Overlapped object at 0x00000000035E7660&amp;gt; s
till has pending operation at deallocation, the process may crash' ignored
...
Fatal read error on pipe transport
protocol: &amp;lt;asyncio.streams.StreamReaderProtocol object at 0x00000000035EE668&amp;gt;
transport: &amp;lt;_ProactorDuplexPipeTransport fd=348&amp;gt;
Traceback (most recent call last):
  File &amp;quot;C:\haypo\tulip\asyncio\proactor_events.py&amp;quot;, line 159, in _loop_reading
    data = fut.result()  # deliver data later in &amp;quot;finally&amp;quot; clause
  File &amp;quot;C:\haypo\tulip\asyncio\futures.py&amp;quot;, line 271, in result
    raise self._exception
  File &amp;quot;C:\haypo\tulip\asyncio\windows_events.py&amp;quot;, line 488, in _poll
    value = callback(transferred, key, ov)
  File &amp;quot;C:\haypo\tulip\asyncio\windows_events.py&amp;quot;, line 279, in finish_recv
    return ov.getresult()
OSError: [WinError 996] Overlapped I/O event is not in a signaled state
...
&lt;/pre&gt;
&lt;p&gt;It seems that the problem only occurs in the fast-path of
&lt;tt class="docutils literal"&gt;IocpProactor._register()&lt;/tt&gt;, when the overlapped is not added to &lt;tt class="docutils literal"&gt;_cache&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Clearing the reference in &lt;tt class="docutils literal"&gt;_poll()&lt;/tt&gt;, when &lt;tt class="docutils literal"&gt;GetQueuedCompletionStatus()&lt;/tt&gt; read
the status, &lt;strong&gt;works&lt;/strong&gt;! I pushed a second fix, &lt;a class="reference external" href="https://github.com/python/cpython/commit/65dd69a3da16257bd86b92900e5ec5a8dd26f1d9"&gt;commit 65dd69a3&lt;/a&gt;
changes &lt;tt class="docutils literal"&gt;_poll()&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 65dd69a3da16257bd86b92900e5ec5a8dd26f1d9
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Fri Jul 25 22:36:05 2014 +0200

    IocpProactor._poll() clears the reference to the overlapped operation
    when the operation is done. (...)
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="ignore-false-alarms"&gt;
&lt;h3&gt;Ignore false alarms&lt;/h3&gt;
&lt;p&gt;I tried to add the overlapped into &lt;tt class="docutils literal"&gt;_cache&lt;/tt&gt; but &lt;strong&gt;then the event loop started
to hang or to fail with new errors&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;I analyzed an overlapped &lt;tt class="docutils literal"&gt;WSARecv()&lt;/tt&gt; which has been cancelled. Just after
calling &lt;tt class="docutils literal"&gt;CancelIoEx()&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;HasOverlappedIoCompleted()&lt;/tt&gt; returns 0.&lt;/p&gt;
&lt;p&gt;Even after &lt;tt class="docutils literal"&gt;GetQueuedCompletionStatus()&lt;/tt&gt; read the status,
&lt;tt class="docutils literal"&gt;HasOverlappedIoCompleted()&lt;/tt&gt; still returns 0.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;After hours of debug, I eventually found the main issue!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Sometimes &lt;tt class="docutils literal"&gt;GetQueuedCompletionStatus()&lt;/tt&gt; returns an overlapped operation which
has not completed yet. I modified &lt;tt class="docutils literal"&gt;IocpProactor._poll()&lt;/tt&gt; to ignore the false
alarm, &lt;a class="reference external" href="https://github.com/python/cpython/commit/51e44ea66aefb4229e506263acf40d35596d279c"&gt;commit 51e44ea6&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 51e44ea66aefb4229e506263acf40d35596d279c
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Sat Jul 26 00:58:34 2014 +0200

    _OverlappedFuture.set_result() now clears its reference to the
    overlapped object.

    IocpProactor._poll() now also ignores false alarms:
    GetQueuedCompletionStatus() returns the overlapped but it is still
    pending.
&lt;/pre&gt;
&lt;p&gt;The fix adds this comment:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# FIXME: why do we get false alarms?
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="keep-a-reference-of-overlapped"&gt;
&lt;h3&gt;Keep a reference of overlapped&lt;/h3&gt;
&lt;p&gt;To stabilize the code, I modified &lt;tt class="docutils literal"&gt;ProactorIocp&lt;/tt&gt; to keep a reference to the
overlapped object (it already kept a reference previously but not in all cases).
&lt;strong&gt;Otherwise the memory may be reused and GetQueuedCompletionStatus() may use
random bytes and behaves badly&lt;/strong&gt;. I pushed &lt;a class="reference external" href="https://github.com/python/cpython/commit/42d3bdeed6e34117b787d61a471563a0dba6a894"&gt;commit 42d3bdee&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 42d3bdeed6e34117b787d61a471563a0dba6a894
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Mon Jul 28 00:18:43 2014 +0200

    ProactorIocp._register() now registers the overlapped
    in the _cache dictionary, even if we already got the result. We need to keep a
    reference to the overlapped object, otherwise the memory may be reused and
    GetQueuedCompletionStatus() may use random bytes and behaves badly.

    There is still a hack for ConnectNamedPipe(): the overlapped object is not
    registered into _cache if the overlapped object completed directly.

    Log also an error in debug mode in ProactorIocp._loop() if we get an unexpected
    event.

    Add a protection in ProactorIocp.close() to avoid blocking, even if it should
    not happen. I still don't understand exactly why some the completion of some
    overlapped objects are not notified.
&lt;/pre&gt;
&lt;p&gt;The change adds a long comment:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# Even if GetOverlappedResult() was called, we have to wait for the
# notification of the completion in GetQueuedCompletionStatus().
# Register the overlapped operation to keep a reference to the
# OVERLAPPED object, otherwise the memory is freed and Windows may
# read uninitialized memory.
#
# For an unknown reason, ConnectNamedPipe() behaves differently:
# the completion is not notified by GetOverlappedResult() if we
# already called GetOverlappedResult(). For this specific case, we
# don't expect notification (register is set to False).
&lt;/pre&gt;
&lt;p&gt;I pushed another change to attempt to stabilize the code, &lt;a class="reference external" href="https://github.com/python/cpython/commit/313a9809043ed2ed1ad25282af7169e08cdc92a3"&gt;commit 313a9809&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 313a9809043ed2ed1ad25282af7169e08cdc92a3
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Tue Jul 29 12:58:23 2014 +0200

    * _WaitHandleFuture.cancel() now notify IocpProactor through the overlapped
      object that the wait was cancelled.
    * Optimize IocpProactor.wait_for_handle() gets the result if the wait is
      signaled immediatly.
    (...)
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="asyncio-issue-196-closed"&gt;
&lt;h3&gt;asyncio issue #196 closed&lt;/h3&gt;
&lt;p&gt;The initial issue &amp;quot;_OverlappedFuture.set_result() should clear its reference to
the overlapped object&amp;quot; has been fixed, so &lt;strong&gt;I closed this issue&lt;/strong&gt;. I didn't
know at this point that all bugs were not fixed yet...&lt;/p&gt;
&lt;p&gt;I also opened the new &lt;a class="reference external" href="https://github.com/python/asyncio/issues/204"&gt;asyncio issue #204&lt;/a&gt; to investigate
&lt;tt class="docutils literal"&gt;accept_pipe()&lt;/tt&gt; special case. We will analyze this funny bug in another article.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="bpo-23095-race-condition-when-cancelling-a-waithandlefuture"&gt;
&lt;h2&gt;bpo-23095: race condition when cancelling a _WaitHandleFuture&lt;/h2&gt;
&lt;p&gt;At December 21, 2014, five months after a long serie of changes to stabilize
asyncio...  &lt;strong&gt;asyncio was still crashing randomly on Windows&lt;/strong&gt;! I created
&lt;a class="reference external" href="https://bugs.python.org/issue23095"&gt;bpo-23095: race condition when cancelling a _WaitHandleFuture&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;On Windows using the IOCP (proactor) event loop, I noticed race conditions when
running the test suite of Trollius (my old deprecated asyncio port to Python
2). For example, sometimes the return code of a process was &lt;tt class="docutils literal"&gt;None&lt;/tt&gt;, whereas
this case &lt;strong&gt;must never happen&lt;/strong&gt;. It looks like the &lt;tt class="docutils literal"&gt;wait_for_handle()&lt;/tt&gt; method
doesn't behave properly.&lt;/p&gt;
&lt;p&gt;When I run the test suite of asyncio in debug mode (PYTHONASYNCIODEBUG=1),
sometimes I see the message &amp;quot;GetQueuedCompletionStatus() returned an unexpected
event&amp;quot; which &lt;strong&gt;should never occur neither&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;I added debug traces. I saw that the &lt;tt class="docutils literal"&gt;IocpProactor.wait_for_handle()&lt;/tt&gt; calls
later &lt;tt class="docutils literal"&gt;PostQueuedCompletionStatus()&lt;/tt&gt; through its internal C callback
(&lt;tt class="docutils literal"&gt;PostToQueueCallback&lt;/tt&gt;). It looks like &lt;strong&gt;sometimes the callback is called
whereas the wait was cancelled/acked&lt;/strong&gt; by &lt;tt class="docutils literal"&gt;UnregisterWait()&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;... I didn't understand the logic between &lt;tt class="docutils literal"&gt;RegisterWaitForSingleObject()&lt;/tt&gt;,
&lt;tt class="docutils literal"&gt;UnregisterWait()&lt;/tt&gt; and the callback ....&lt;/p&gt;
&lt;p&gt;It looks like sometimes the overlapped object created in Python
(&lt;tt class="docutils literal"&gt;ov = _overlapped.Overlapped(NULL)&lt;/tt&gt;) is destroyed, before
&lt;tt class="docutils literal"&gt;PostToQueueCallback()&lt;/tt&gt; is called. In the unit tests, &lt;strong&gt;it doesn't crash
because a different overlapped object is created and it gets the same memory
address&lt;/strong&gt; (the memory allocator reuses a just freed memory block).&lt;/p&gt;
&lt;p&gt;The implementation of &lt;tt class="docutils literal"&gt;wait_for_handle()&lt;/tt&gt; had an optimization: it polls
immediatly the wait to check if it already completed. I tried to remove it, but
I got some different issues. If I understood correctly, &lt;strong&gt;this optimization
hides other bugs and reduce the probability of getting the race condition&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;wait_for_handle()&lt;/tt&gt; is used to wait for the completion of a subprocess, so by
all unit tests running subprocesses, but also in &lt;tt class="docutils literal"&gt;test_wait_for_handle()&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;test_wait_for_handle_cancel()&lt;/tt&gt; tests. I suspect that running
&lt;tt class="docutils literal"&gt;test_wait_for_handle()&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;test_wait_for_handle_cancel()&lt;/tt&gt; triggers the
bug.&lt;/p&gt;
&lt;p&gt;Removing &lt;tt class="docutils literal"&gt;_winapi.CloseHandle(self._iocp)&lt;/tt&gt; in &lt;tt class="docutils literal"&gt;IocpProactor.close()&lt;/tt&gt;
works around the bug. The bug looks to be an expected call to
&lt;tt class="docutils literal"&gt;PostToQueueCallback()&lt;/tt&gt; which calls &lt;tt class="docutils literal"&gt;PostQueuedCompletionStatus()&lt;/tt&gt; on an
IOCP. Not closing the IOCP means using a different IOCP for each test, so the
unexpected call to &lt;tt class="docutils literal"&gt;PostQueuedCompletionStatus()&lt;/tt&gt; has no effect on following
tests.&lt;/p&gt;
&lt;p&gt;I rewrote some parts of the IOCP code in asyncio. Maybe I introduced this issue
during the refactoring. Maybe &lt;strong&gt;it already existed before but nobody noticed
it, asyncio had fewer unit tests before&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="fixing-the-root-issue-overlapped-cancellation-from-hell"&gt;
&lt;h2&gt;Fixing the root issue: Overlapped Cancellation From Hell&lt;/h2&gt;
&lt;p&gt;I looked into Twisted implemented of proactor, but it didn't support
subprocesses.&lt;/p&gt;
&lt;p&gt;I looked at libuv: it supported processes but not cancelling a wait on a
process handle...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I had to ask for help to someone who had access to the Windows source code&lt;/strong&gt;
to understand the bug...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;After six months of intense debugging, I eventually identified the root
issue&lt;/strong&gt; (I pushed the first fix at July 25, 2014). I pushed the &lt;a class="reference external" href="https://github.com/python/cpython/commit/d0a28dee78d099fcadc71147cba4affb6efa0c97"&gt;commit
d0a28dee&lt;/a&gt;
(&lt;a class="reference external" href="https://bugs.python.org/issue23095"&gt;bpo-23095&lt;/a&gt;):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit d0a28dee78d099fcadc71147cba4affb6efa0c97
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Wed Jan 21 23:39:51 2015 +0100

    Issue #23095, asyncio: Rewrite _WaitHandleFuture.cancel()
&lt;/pre&gt;
&lt;p&gt;This change fixes a race conditon related to &lt;tt class="docutils literal"&gt;_WaitHandleFuture.cancel()&lt;/tt&gt;
leading to a Python crash or &amp;quot;GetQueuedCompletionStatus() returned an
unexpected event&amp;quot; logs. Previously, &lt;strong&gt;it was possible that the cancelled wait
completes whereas the overlapped object was already destroyed&lt;/strong&gt;. Sometimes, a
different overlapped was allocated at the same address, emitting a log about
unexpected completition (but no crash).&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;_WaitHandleFuture.cancel()&lt;/tt&gt; now &lt;strong&gt;waits until the handle wait is cancelled&lt;/strong&gt;
(until the cancellation completes) before clearing its reference to the
overlapped object. To wait until the cancellation completes,
&lt;tt class="docutils literal"&gt;UnregisterWaitEx()&lt;/tt&gt; is used with an event (instead of using
&lt;tt class="docutils literal"&gt;UnregisterWait()&lt;/tt&gt;).&lt;/p&gt;
&lt;p&gt;To wait for this event, a new &lt;tt class="docutils literal"&gt;_WaitCancelFuture&lt;/tt&gt; class was added. It's a
simplified version of &lt;tt class="docutils literal"&gt;_WaitCancelFuture&lt;/tt&gt;. For example, its &lt;tt class="docutils literal"&gt;cancel()&lt;/tt&gt;
method calls &lt;tt class="docutils literal"&gt;UnregisterWait()&lt;/tt&gt;, not &lt;tt class="docutils literal"&gt;UnregisterWaitEx()&lt;/tt&gt;.
&lt;tt class="docutils literal"&gt;_WaitCancelFuture&lt;/tt&gt; should not be cancelled.&lt;/p&gt;
&lt;p&gt;The overlapped object is &lt;strong&gt;kept alive&lt;/strong&gt; in &lt;tt class="docutils literal"&gt;_WaitHandleFuture&lt;/tt&gt; &lt;strong&gt;until the
wait is unregistered&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Later, I pushed a few more changes to fix corner cases.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/python/cpython/commit/1ca9392c7083972c1953c02e6f2cca54934ce0a6"&gt;commit 1ca9392c&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 1ca9392c7083972c1953c02e6f2cca54934ce0a6
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Thu Jan 22 00:17:54 2015 +0100

    Issue #23095, asyncio: IocpProactor.close() must not cancel pending
    _WaitCancelFuture futures
&lt;/pre&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/python/cpython/commit/752aba7f999b08c833979464a36840de8be0baf0"&gt;commit 752aba7f&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 752aba7f999b08c833979464a36840de8be0baf0
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Thu Jan 22 22:47:13 2015 +0100

    asyncio: IocpProactor.close() doesn't cancel anymore futures which are already
    cancelled
&lt;/pre&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/python/cpython/commit/24dfa3c1d6b21e731bd167a13153968bba8fa5ce"&gt;commit 24dfa3c1&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 24dfa3c1d6b21e731bd167a13153968bba8fa5ce
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Mon Jan 26 22:30:28 2015 +0100

    Issue #23095, asyncio: Fix _WaitHandleFuture.cancel()

    If UnregisterWaitEx() fais with ERROR_IO_PENDING, it doesn't mean that the wait
    is unregistered yet. We still have to wait until the wait is cancelled.
&lt;/pre&gt;
&lt;p&gt;I think that &lt;em&gt;this&lt;/em&gt; issue can now be closed: &lt;tt class="docutils literal"&gt;UnregisterWaitEx()&lt;/tt&gt; really do
what we need in asyncio.&lt;/p&gt;
&lt;p&gt;I don't like the complexity of the IocpProactor._unregister() method and of the
_WaitCancelFuture class, but it looks that it's how we are supposed to wait
until a wait for a handle is cancelled...&lt;/p&gt;
&lt;p&gt;Windows IOCP API is much more complex that what I expected. It's probably
because some parts (especially &lt;tt class="docutils literal"&gt;RegisterWaitForSingleObject()&lt;/tt&gt;) are
implemented with threads in user land, not in the kernel.&lt;/p&gt;
&lt;p&gt;In short, I'm very happy that have fixed this very complex but also very
annoying IOCP bug in asyncio.&lt;/p&gt;
&lt;p&gt;I got a nice comment from &lt;a class="reference external" href="https://bugs.python.org/issue23095#msg234453"&gt;Guido van Rossum&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;strong&gt;Congrats with the fix, and thanks for your perseverance!&lt;/strong&gt;&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="summary-of-the-race-condition"&gt;
&lt;h2&gt;Summary of the race condition&lt;/h2&gt;
&lt;p&gt;Events of the crashing unit test:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;The loop (ProactorEventLoop) spawns a subprocess.&lt;/li&gt;
&lt;li&gt;The loop creates a _WaitHandleFuture object which creates an overlapped to
wait until the process completes (call &lt;tt class="docutils literal"&gt;RegisterWaitForSingleObject()&lt;/tt&gt;):
&lt;strong&gt;allocate&lt;/strong&gt; memory for the overlapped.&lt;/li&gt;
&lt;li&gt;The wait future is cancelled (call &lt;tt class="docutils literal"&gt;UnregisterWait()&lt;/tt&gt;).&lt;/li&gt;
&lt;li&gt;The overlapped is destroyed: &lt;strong&gt;free&lt;/strong&gt; overlapped memory.&lt;/li&gt;
&lt;li&gt;The overlapped completes: &lt;strong&gt;write&lt;/strong&gt; into the overlapped memory.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The main issue is the order of the two last events.&lt;/p&gt;
&lt;p&gt;Sometimes, the overlapped completed before the memory was freed: everything is
fine.&lt;/p&gt;
&lt;p&gt;Sometimes, the overlapped completed after the memory was freed: Python crashed
(segmentation fault).&lt;/p&gt;
&lt;p&gt;Sometimes, another _WaitHandleFuture was created in the meanwhile and created a
second overlapped which was allocated at the same memory address than the freed
memory of the previous overlapped. In this case, when the first overlapped
completes, Python didn't crash but logged an unexpected completion message.&lt;/p&gt;
&lt;p&gt;Sometimes, the write was done in freed memory: the write didn't crash Python,
but caused bugs which didn't make sense.&lt;/p&gt;
&lt;p&gt;There were even more cases causing even more surprising behaviors.&lt;/p&gt;
&lt;p&gt;Summary of the fix:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;(... similar steps for the beginning ...)&lt;/li&gt;
&lt;li&gt;The wait future is cancelled: &lt;strong&gt;create an event&lt;/strong&gt; to wait until the
cancellation completes (call &lt;tt class="docutils literal"&gt;UnregisterWaitEx()&lt;/tt&gt;).&lt;/li&gt;
&lt;li&gt;Wait for the event.&lt;/li&gt;
&lt;li&gt;The event is signalled which means that the cancellation completed: &lt;strong&gt;write&lt;/strong&gt;
into the overlapped memory.&lt;/li&gt;
&lt;li&gt;The overlapped is destroyed: &lt;strong&gt;free&lt;/strong&gt; overlapped memory.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content><category term="cpython"></category><category term="asyncio"></category></entry><entry><title>Locale Bugfixes in Python 3</title><link href="https://vstinner.github.io/locale-bugfixes-python3.html" rel="alternate"></link><published>2019-01-09T00:30:00+01:00</published><updated>2019-01-09T00:30:00+01:00</updated><author><name>Victor Stinner</name></author><id>tag:vstinner.github.io,2019-01-09:/locale-bugfixes-python3.html</id><summary type="html">&lt;a class="reference external image-reference" href="https://www.flickr.com/photos/svensson/40467591/"&gt;&lt;img alt="Unicode Mixed Bag" src="https://vstinner.github.io/images/unicode_bag.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;This article describes a few locales bugs that I fixed in Python 3 between 2012
(Python 3.3) and 2018 (Python 3.7):&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Support non-ASCII decimal point and thousands separator&lt;/li&gt;
&lt;li&gt;Crash with non-ASCII decimal point&lt;/li&gt;
&lt;li&gt;LC_NUMERIC encoding different than LC_CTYPE encoding&lt;/li&gt;
&lt;li&gt;LC_MONETARY encoding different than LC_CTYPE encoding&lt;/li&gt;
&lt;li&gt;Tests non-ASCII locales …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;a class="reference external image-reference" href="https://www.flickr.com/photos/svensson/40467591/"&gt;&lt;img alt="Unicode Mixed Bag" src="https://vstinner.github.io/images/unicode_bag.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;This article describes a few locales bugs that I fixed in Python 3 between 2012
(Python 3.3) and 2018 (Python 3.7):&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Support non-ASCII decimal point and thousands separator&lt;/li&gt;
&lt;li&gt;Crash with non-ASCII decimal point&lt;/li&gt;
&lt;li&gt;LC_NUMERIC encoding different than LC_CTYPE encoding&lt;/li&gt;
&lt;li&gt;LC_MONETARY encoding different than LC_CTYPE encoding&lt;/li&gt;
&lt;li&gt;Tests non-ASCII locales&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See also my previous locale bugfixes: &lt;a class="reference external" href="https://vstinner.github.io/python3-locales-encodings.html"&gt;Python 3, locales and encodings&lt;/a&gt;&lt;/p&gt;
&lt;div class="section" id="introduction"&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Each language and each country has different ways to represent dates, monetary
values, numbers, etc. Unix has &amp;quot;locales&amp;quot; to configure applications for a
specific language and a specific country. For example, there are &lt;tt class="docutils literal"&gt;fr_BE&lt;/tt&gt; for
Belgium (french) and &lt;tt class="docutils literal"&gt;fr_FR&lt;/tt&gt; for France (french).&lt;/p&gt;
&lt;p&gt;In practice, each locale uses its own encoding and problems arise when an
application uses a different encoding than the locale. There are LC_NUMERIC
locale for numbers, LC_MONETARY locale for monetary and LC_CTYPE for the
encoding. Not only it's possible to configure an application to use LC_NUMERIC
with a different encoding than LC_CTYPE, but some users use such configuration!&lt;/p&gt;
&lt;p&gt;In an application which only uses bytes for text, as Python 2 does mostly, it's
mostly fine: in the worst case, users see &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Mojibake"&gt;mojibake&lt;/a&gt;, but the application doesn't
&amp;quot;crash&amp;quot; (exit and/or data loss). On the other side, &lt;strong&gt;Python 3 is designed to
use Unicode for text and fail with hard Unicode errors if it fails to decode
bytes and fails to encode text&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="support-non-ascii-decimal-point-and-thousands-separator"&gt;
&lt;h2&gt;Support non-ASCII decimal point and thousands separator&lt;/h2&gt;
&lt;p&gt;The Unicode type has been reimplemented in Python 3.3 to use &amp;quot;compact string&amp;quot;:
&lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0393/"&gt;PEP 393 &amp;quot;Flexible String Representation&amp;quot;&lt;/a&gt;. The new implementation is more
complex and the format() function has been limited to ASCII for the decimal
point and thousands separator (format a number using the &amp;quot;n&amp;quot; type).&lt;/p&gt;
&lt;p&gt;In January 2012, Stefan Krah noticed the regression (compared to Python 3.2)
and reported &lt;a class="reference external" href="https://bugs.python.org/issue13706"&gt;bpo-13706&lt;/a&gt;. I fixed the
code to support non-ASCII in format (&lt;a class="reference external" href="https://github.com/python/cpython/commit/a4ac600d6f9c5b74b97b99888b7cf3a7973cadc8"&gt;commit a4ac600d&lt;/a&gt;).
But when I did more tests, I noticed that the &amp;quot;n&amp;quot; type doesn't decode properly
the decimal point and thousands seprator which come from the &lt;tt class="docutils literal"&gt;localeconv()&lt;/tt&gt;
function which uses byte strings.&lt;/p&gt;
&lt;p&gt;I fixed &lt;tt class="docutils literal"&gt;format(int, &amp;quot;n&amp;quot;)&lt;/tt&gt; with &lt;a class="reference external" href="https://github.com/python/cpython/commit/41a863cb81608c779d60b49e7be8a115816734fc"&gt;commit 41a863cb&lt;/a&gt;,
decode decimal point and the thousands separator (&lt;tt class="docutils literal"&gt;localeconv()&lt;/tt&gt; fields) from
the locale encoding, rather than latin1, using &lt;tt class="docutils literal"&gt;PyUnicode_DecodeLocale()&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 41a863cb81608c779d60b49e7be8a115816734fc
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;haypocalc.com&amp;gt;
Date:   Fri Feb 24 00:37:51 2012 +0100

    Issue #13706: Fix format(int, &amp;quot;n&amp;quot;) for locale with non-ASCII thousands separator

     * Decode thousands separator and decimal point using PyUnicode_DecodeLocale()
       (from the locale encoding), instead of decoding them implicitly from latin1
     * Remove _PyUnicode_InsertThousandsGroupingLocale(), it was not used
     * Change _PyUnicode_InsertThousandsGrouping() API to return the maximum
       character if unicode is NULL
     * (...)
&lt;/pre&gt;
&lt;p&gt;Note: I decided to not fix Python 3.2:&lt;/p&gt;
&lt;blockquote&gt;
Hum, &lt;strong&gt;it is not trivial to redo the work on Python 3.2&lt;/strong&gt;. I prefer to leave
the code unchanged to not introduce a regression, and I wait until a Python
3.2 user complains (the bug exists since Python 3.0 and nobody complained).&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="crash-with-non-ascii-decimal-point"&gt;
&lt;h2&gt;Crash with non-ASCII decimal point&lt;/h2&gt;
&lt;p&gt;Six years later, in June 2018, I noticed that Python does crash when running
tests on locales:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ./python
Python 3.8.0a0 (heads/master-dirty:bcd3a1a18d, Jun 23 2018, 10:31:03)
[GCC 8.1.1 20180502 (Red Hat 8.1.1-1)] on linux
&amp;gt;&amp;gt;&amp;gt; import locale
&amp;gt;&amp;gt;&amp;gt; locale.str(2.5)
'2.5'
&amp;gt;&amp;gt;&amp;gt; '{:n}'.format(2.5)
'2.5'

&amp;gt;&amp;gt;&amp;gt; locale.setlocale(locale.LC_ALL, '')
'fr_FR.UTF-8'
&amp;gt;&amp;gt;&amp;gt; locale.str(2.5)
'2,5'
&amp;gt;&amp;gt;&amp;gt; '{:n}'.format(2.5)
python: Objects/unicodeobject.c:474: _PyUnicode_CheckConsistency: Assertion `maxchar &amp;lt; 128' failed.
Aborted (core dumped)
&lt;/pre&gt;
&lt;p&gt;I reported the issue as &lt;a class="reference external" href="https://bugs.python.org/issue33954"&gt;bpo-33954&lt;/a&gt;. The
bug only occurrs for decimal point larger than U+00FF (code point greater than
255). It was a bug in my &lt;a class="reference external" href="https://bugs.python.org/issue13706"&gt;bpo-13706&lt;/a&gt;
fix: &lt;a class="reference external" href="https://github.com/python/cpython/commit/a4ac600d6f9c5b74b97b99888b7cf3a7973cadc8"&gt;commit a4ac600d&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I pushed a second fix to properly support all cases, &lt;a class="reference external" href="https://github.com/python/cpython/commit/59423e3ddd736387cef8f7632c71954c1859bed0"&gt;commit 59423e3d&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 59423e3ddd736387cef8f7632c71954c1859bed0
Author: Victor Stinner &amp;lt;vstinner&amp;#64;redhat.com&amp;gt;
Date:   Mon Nov 26 13:40:01 2018 +0100

    bpo-33954: Fix _PyUnicode_InsertThousandsGrouping() (GH-10623)

    Fix str.format(), float.__format__() and complex.__format__() methods
    for non-ASCII decimal point when using the &amp;quot;n&amp;quot; formatter.

    Changes:

    * Rewrite _PyUnicode_InsertThousandsGrouping(): it now requires
      a _PyUnicodeWriter object for the buffer and a Python str object
      for digits.
    * Rename FILL() macro to unicode_fill(), convert it to static inline function,
      add &amp;quot;assert(0 &amp;lt;= start);&amp;quot; and rework its code.
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="lc-numeric-encoding-different-than-lc-ctype-encoding"&gt;
&lt;h2&gt;LC_NUMERIC encoding different than LC_CTYPE encoding&lt;/h2&gt;
&lt;p&gt;In August 2017, Petr Viktorin identified a bug in Koji (server building Fedora
packages): &lt;a class="reference external" href="https://bugzilla.redhat.com/show_bug.cgi?id=1484497"&gt;UnicodeDecodeError in localeconv() makes test_float fail in Koji&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&amp;quot;This is tripped by Python's test suite, namely
test_float.GeneralFloatCases.test_float_with_comma&amp;quot;&lt;/blockquote&gt;
&lt;p&gt;He wrote a short reproducer script:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
import locale
locale.setlocale(locale.LC_ALL, 'C.UTF-8')
locale.setlocale(locale.LC_NUMERIC, 'fr_FR.ISO8859-1')
print(locale.localeconv())
&lt;/pre&gt;
&lt;p&gt;Two months later, Charalampos Stratakis reported the bug upstream: &lt;a class="reference external" href="https://bugs.python.org/issue31900"&gt;bpo-31900&lt;/a&gt;.  The problem arises when &lt;strong&gt;the
LC_NUMERIC locale uses a different encoding than the LC_CTYPE encoding&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The bug was already known:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;2015-12-05: Serhiy Storchaka reported &lt;a class="reference external" href="https://bugs.python.org/issue25812"&gt;bpo-25812&lt;/a&gt; with uk_UA locale&lt;/li&gt;
&lt;li&gt;2016-11-03: Guillaume Pasquet reported &lt;a class="reference external" href="https://bugs.python.org/issue28604"&gt;bpo-28604&lt;/a&gt; with en_GB locale&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Moreover, &lt;strong&gt;the bug was known since 2009&lt;/strong&gt;, Stefan Krah reported a very similar
bug: &lt;a class="reference external" href="https://bugs.python.org/issue7442"&gt;bpo-7442&lt;/a&gt;. I was even involved in
this issue in 2013, but then I forgot about it (as usual, I am working on too
many issues in parallel :-)).&lt;/p&gt;
&lt;p&gt;In 2010, PostgreSQL &lt;a class="reference external" href="https://www.postgresql.org/message-id/20100422015552.4B7E07541D0&amp;#64;cvs.postgresql.org"&gt;had the same issue&lt;/a&gt;
and &lt;a class="reference external" href="https://anoncvs.postgresql.org/cvsweb.cgi/pgsql/src/backend/utils/adt/pg_locale.c?r1=1.53&amp;amp;r2=1.54"&gt;fixed the bug by changing temporarily the LC_CTYPE locale to the
LC_NUMERIC locale&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In January 2018, I came back to this 9 years old bug. I was fixing bugs in the
implementation of my &lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0540/"&gt;PEP 540 &amp;quot;Add a new UTF-8 Mode&amp;quot;&lt;/a&gt;. I pushed a large change to fix
locale encodings in &lt;a class="reference external" href="https://bugs.python.org/issue29240"&gt;bpo-29240&lt;/a&gt;, &lt;a class="reference external" href="https://github.com/python/cpython/commit/7ed7aead9503102d2ed316175f198104e0cd674c"&gt;commit
7ed7aead&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 7ed7aead9503102d2ed316175f198104e0cd674c
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Mon Jan 15 10:45:49 2018 +0100

    bpo-29240: Fix locale encodings in UTF-8 Mode (#5170)

    Modify locale.localeconv(), time.tzname, os.strerror() and other
    functions to ignore the UTF-8 Mode: always use the current locale
    encoding.

    Changes: (...)
&lt;/pre&gt;
&lt;p&gt;Stefan Krah asked:&lt;/p&gt;
&lt;blockquote&gt;
I have the exact same questions as Marc-Andre.  This is one of the reasons
why I blocked the _decimal change.  I don't fully understand the role of the
new glibc, since #7442 has existed for ages -- and &lt;strong&gt;it is a open question
whether it is a bug or not&lt;/strong&gt;.&lt;/blockquote&gt;
&lt;p&gt;I replied:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Past 10 years, I repeated to every single user I met that &amp;quot;Python 3 is
right, your system setup is wrong&amp;quot;. But that's a waste of time. People
continue to associate Python3 and Unicode to annoying bugs, because they
don't understand how locales work.&lt;/p&gt;
&lt;p&gt;Instead of having to repeat to each user that &amp;quot;hum, maybe your config is
wrong&amp;quot;, &lt;strong&gt;I prefer to support this non convential setup and work as expected
(&amp;quot;it just works&amp;quot;)&lt;/strong&gt;. With my latest implementation, setlocale() is only done
when LC_CTYPE and LC_NUMERIC are different, which is the corner case which
&amp;quot;shouldn't occur in practice&amp;quot;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Marc-Andre Lemburg added:&lt;/p&gt;
&lt;blockquote&gt;
Sounds like a good compromise :-)&lt;/blockquote&gt;
&lt;p&gt;After doing more tests on FreeBSD, Linux and macOS, I pushed &lt;a class="reference external" href="https://github.com/python/cpython/commit/cb064fc2321ce8673fe365e9ef60445a27657f54"&gt;commit cb064fc2&lt;/a&gt;
to fix &lt;a class="reference external" href="https://bugs.python.org/issue31900"&gt;bpo-31900&lt;/a&gt; by changing
temporarily the LC_CTYPE locale to the LC_NUMERIC locale:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit cb064fc2321ce8673fe365e9ef60445a27657f54
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Mon Jan 15 15:58:02 2018 +0100

    bpo-31900: Fix localeconv() encoding for LC_NUMERIC (#4174)

    * Add _Py_GetLocaleconvNumeric() function: decode decimal_point and
      thousands_sep fields of localeconv() from the LC_NUMERIC encoding,
      rather than decoding from the LC_CTYPE encoding.
    * Modify locale.localeconv() and &amp;quot;n&amp;quot; formatter of str.format() (for
      int, float and complex to use _Py_GetLocaleconvNumeric()
      internally.
&lt;/pre&gt;
&lt;p&gt;I dislike my own fix because changing temporarily the LC_CTYPE locale impacts
all threads, not only the current thread. But we failed to find another
solution. &lt;strong&gt;The LC_CTYPE locale is only changed if the LC_NUMERIC locale is
different than the LC_CTYPE locale and if the decimal point or the thousands
separator is non-ASCII.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Note: I proposed a change to fix the same bug in the &lt;tt class="docutils literal"&gt;decimal&lt;/tt&gt; module: &lt;a class="reference external" href="https://github.com/python/cpython/pull/5191"&gt;PR
#5191&lt;/a&gt;, but I abandonned my
patch.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="lc-monetary-encoding-different-than-lc-ctype-encoding"&gt;
&lt;h2&gt;LC_MONETARY encoding different than LC_CTYPE encoding&lt;/h2&gt;
&lt;p&gt;Fixing &lt;a class="reference external" href="https://bugs.python.org/issue31900"&gt;bpo-31900&lt;/a&gt; drained all my
energy, but sadly... there was a similar bug with LC_MONETARY!&lt;/p&gt;
&lt;p&gt;At 2016-11-03, Guillaume Pasquet reported &lt;a class="reference external" href="https://bugs.python.org/issue28604"&gt;bpo-28604: Exception raised by
python3.5 when using en_GB locale&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The fix is similar to the LC_NUMERIC fix: change temporarily the LC_CTYPE
locale to the LC_MONETARY locale, &lt;a class="reference external" href="https://github.com/python/cpython/commit/02e6bf7f2025cddcbde6432f6b6396198ab313f4"&gt;commit 02e6bf7f&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 02e6bf7f2025cddcbde6432f6b6396198ab313f4
Author: Victor Stinner &amp;lt;vstinner&amp;#64;redhat.com&amp;gt;
Date:   Tue Nov 20 16:20:16 2018 +0100

    bpo-28604: Fix localeconv() for different LC_MONETARY (GH-10606)

    locale.localeconv() now sets temporarily the LC_CTYPE locale to the
    LC_MONETARY locale if the two locales are different and monetary
    strings are non-ASCII. This temporary change affects other threads.

    Changes:

    * locale.localeconv() can now set LC_CTYPE to LC_MONETARY to decode
      monetary fields.
    * (...)
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="tests-non-ascii-locales"&gt;
&lt;h2&gt;Tests non-ASCII locales&lt;/h2&gt;
&lt;p&gt;To test my bugfixes, I used manual tests. The first issue was to identify
locales with problematic characters: non-ASCII decimal point or thousands
separator for example. I wrote my own &amp;quot;test suite&amp;quot; for Windows, Linux, macOS
and FreeBSD on my website: &lt;a class="reference external" href="https://vstinner.readthedocs.io/unicode.html#test-non-ascii-characters-with-locales"&gt;Test non-ASCII characters with locales&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Example with localeconv() on Fedora 27:&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="15%" /&gt;
&lt;col width="8%" /&gt;
&lt;col width="16%" /&gt;
&lt;col width="25%" /&gt;
&lt;col width="36%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;LC_ALL locale&lt;/th&gt;
&lt;th class="head"&gt;Encoding&lt;/th&gt;
&lt;th class="head"&gt;Field&lt;/th&gt;
&lt;th class="head"&gt;Bytes&lt;/th&gt;
&lt;th class="head"&gt;Text&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;es_MX.utf8&lt;/td&gt;
&lt;td&gt;UTF-8&lt;/td&gt;
&lt;td&gt;thousands_sep&lt;/td&gt;
&lt;td&gt;&lt;tt class="docutils literal"&gt;0xE2 0x80 0x89&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;U+2009&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;fr_FR.UTF-8&lt;/td&gt;
&lt;td&gt;UTF-8&lt;/td&gt;
&lt;td&gt;currency_symbol&lt;/td&gt;
&lt;td&gt;&lt;tt class="docutils literal"&gt;0xE2 0x82 0xAC&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;U+20AC (€)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ps_AF.utf8&lt;/td&gt;
&lt;td&gt;UTF-8&lt;/td&gt;
&lt;td&gt;thousands_sep&lt;/td&gt;
&lt;td&gt;&lt;tt class="docutils literal"&gt;0xD9 0xAC&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;U+066C (٬)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;uk_UA.koi8u&lt;/td&gt;
&lt;td&gt;KOI8-U&lt;/td&gt;
&lt;td&gt;currency_symbol&lt;/td&gt;
&lt;td&gt;&lt;tt class="docutils literal"&gt;0xC7 0xD2 0xCE 0x2E&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;U+0433 U+0440 U+043d U+002E (грн.)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;uk_UA.koi8u&lt;/td&gt;
&lt;td&gt;KOI8-U&lt;/td&gt;
&lt;td&gt;thousands_sep&lt;/td&gt;
&lt;td&gt;&lt;tt class="docutils literal"&gt;0x9A&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;U+00A0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Manual tests became more and more complex, since there are so many cases: each
operating system use different locale names and the result depends on the libc
version. After months of manual tests, I wrote my small personal &lt;strong&gt;portable&lt;/strong&gt;
locale test suite: &lt;a class="reference external" href="https://github.com/vstinner/misc/blob/master/python/test_all_locales.py"&gt;test_all_locales.py&lt;/a&gt;.
It supports:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;FreeBSD 11&lt;/li&gt;
&lt;li&gt;macOS&lt;/li&gt;
&lt;li&gt;Fedora (Linux)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
def test_zh_TW_Big5(self):
    loc = &amp;quot;zh_TW.Big5&amp;quot; if BSD else &amp;quot;zh_TW.big5&amp;quot;
    if FREEBSD:
        currency_symbol = u'\uff2e\uff34\uff04'
        decimal_point = u'\uff0e'
        thousands_sep = u'\uff0c'
        date_str = u'\u661f\u671f\u56db 2\u6708'
    else:
        currency_symbol = u'NT$'
        decimal_point = u'.'
        thousands_sep = u','
        if MACOS:
            date_str =  u'\u9031\u56db 2\u6708'
        else:
            date_str = u'\u9031\u56db \u4e8c\u6708'

    self.set_locale(loc, &amp;quot;Big5&amp;quot;)

    lc = locale.localeconv()
    self.assertLocaleEqual(lc['currency_symbol'], currency_symbol)
    self.assertLocaleEqual(lc['decimal_point'], decimal_point)
    self.assertLocaleEqual(lc['thousands_sep'], thousands_sep)

    self.assertLocaleEqual(time.strftime('%A %B', FEBRUARY), date_str)
&lt;/pre&gt;
&lt;p&gt;The best would be to integrate directly these tests into the Python test suite,
but it's not portable nor future-proof, since most constants are hardcoded and
depends on the operating sytem and the libc version.&lt;/p&gt;
&lt;/div&gt;
</content><category term="cpython"></category><category term="unicode"></category><category term="locales"></category></entry><entry><title>Python 3, locales and encodings</title><link href="https://vstinner.github.io/python3-locales-encodings.html" rel="alternate"></link><published>2018-09-06T16:00:00+02:00</published><updated>2018-09-06T16:00:00+02:00</updated><author><name>Victor Stinner</name></author><id>tag:vstinner.github.io,2018-09-06:/python3-locales-encodings.html</id><summary type="html">&lt;img alt="I □ Unicode" src="https://vstinner.github.io/images/i-square-unicode.jpg" /&gt;
&lt;p&gt;Recently, I worked on a change which looked simple: move the code to initialize
the &lt;tt class="docutils literal"&gt;sys.stdout&lt;/tt&gt; encoding before &lt;tt class="docutils literal"&gt;Py_Initialize()&lt;/tt&gt;. While I was on it,
I also decided to move the code which selects the Python &amp;quot;filesystem encoding&amp;quot;.
I didn't expect that I would spend 2 weeks on these issues …&lt;/p&gt;</summary><content type="html">&lt;img alt="I □ Unicode" src="https://vstinner.github.io/images/i-square-unicode.jpg" /&gt;
&lt;p&gt;Recently, I worked on a change which looked simple: move the code to initialize
the &lt;tt class="docutils literal"&gt;sys.stdout&lt;/tt&gt; encoding before &lt;tt class="docutils literal"&gt;Py_Initialize()&lt;/tt&gt;. While I was on it,
I also decided to move the code which selects the Python &amp;quot;filesystem encoding&amp;quot;.
I didn't expect that I would spend 2 weeks on these issues... This article
tells me about my recent journey in locales and encodings on AIX, HP-UX,
Windows, Linux, macOS, Solaris and FreeBSD.&lt;/p&gt;
&lt;p&gt;Table of Contents:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Lying HP-UX&lt;/li&gt;
&lt;li&gt;Standard streams and filesystem encodings&lt;/li&gt;
&lt;li&gt;POSIX locale on FreeBSD&lt;/li&gt;
&lt;li&gt;C locale on Windows&lt;/li&gt;
&lt;li&gt;Back to stdio encoding&lt;/li&gt;
&lt;li&gt;Back to filesystem encoding&lt;/li&gt;
&lt;li&gt;Use surrogatepass on Windows&lt;/li&gt;
&lt;li&gt;Filesystem encoding documentation&lt;/li&gt;
&lt;li&gt;Final FreeBSD 10 issue&lt;/li&gt;
&lt;li&gt;Configuration of locales and encodings&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="lying-hp-ux"&gt;
&lt;h2&gt;Lying HP-UX&lt;/h2&gt;
&lt;p&gt;At 2018-08-14, Michael Osipov reported &lt;a class="reference external" href="https://bugs.python.org/issue34403"&gt;bpo-34403&lt;/a&gt;:
&amp;quot;test_utf8_mode.test_cmd_line() fails on HP-UX due to false assumptions&amp;quot;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
======================================================================
FAIL: test_cmd_line (test.test_utf8_mode.UTF8ModeTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  (...)
AssertionError: &amp;quot;['h\\xc3\\xa9\\xe2\\x82\\xac']&amp;quot; != &amp;quot;['h\\udcc3\\udca9\\udce2\\udc82\\udcac']&amp;quot;
- ['h\xc3\xa9\xe2\x82\xac']
+ ['h\udcc3\udca9\udce2\udc82\udcac']
 : roman8:['h\xc3\xa9\xe2\x82\xac']
&lt;/pre&gt;
&lt;p&gt;Interesting, HP-UX uses &amp;quot;roman8&amp;quot; as its locale encoding. What is this &amp;quot;new&amp;quot;
encoding? Wikipedia: &lt;a class="reference external" href="https://en.wikipedia.org/wiki/HP_Roman#Roman-8"&gt;HP Roman-8&lt;/a&gt;. Oh, that's even older than
the common ISO 8859 encodings like Latin1!&lt;/p&gt;
&lt;p&gt;Michael Felt was working on a similar test_utf8_mode failure on AIX, so they
tried to debug the issue together, but failed to understand the issue. Osipov
proposed to give up and just skip the test on HP-UX...&lt;/p&gt;
&lt;p&gt;I showed up and proposed a fix for the unit test: &lt;a class="reference external" href="https://github.com/python/cpython/pull/8967/files"&gt;PR 8967&lt;/a&gt;. The test was hardcoding
the expected locale encoding. I modified the test to query the locale encoding
at runtime instead.&lt;/p&gt;
&lt;p&gt;Bad surprise, the test still fails, oh. &lt;a class="reference external" href="https://bugs.python.org/issue34403#msg324219"&gt;I commented&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
Hum, it looks like a bug in the C library of HP-UX.&lt;/blockquote&gt;
&lt;p&gt;I wrote a C program calling mbstowcs() to check what is the actual encoding
used by the C library: &lt;a class="reference external" href="https://bugs.python.org/file47767/c_locale.c"&gt;c_locale.c&lt;/a&gt;. &lt;a class="reference external" href="https://bugs.python.org/issue34403#msg324225"&gt;Result&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
Well, it confirms what I expected: &lt;tt class="docutils literal"&gt;nl_langinfo(CODESET)&lt;/tt&gt; announces
&lt;tt class="docutils literal"&gt;&amp;quot;roman8&amp;quot;&lt;/tt&gt;, but &lt;tt class="docutils literal"&gt;mbstowcs()&lt;/tt&gt; uses Latin1 encoding in practice.&lt;/blockquote&gt;
&lt;p&gt;So I wrote a workaround similar to the one used on FreeBSD and Solaris: check
if the libc is announcing an encoding different than the real encoding, and if
it's the case: force the usage of the ASCII encoding in Python. See
my &lt;a class="reference external" href="https://github.com/python/cpython/commit/d500e5307aec9c5d535f66d567fadb9c587a9a36"&gt;commit d500e530&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Author: Victor Stinner &amp;lt;vstinner&amp;#64;redhat.com&amp;gt;
Date:   Tue Aug 28 17:27:36 2018 +0200

    bpo-34403: On HP-UX, force ASCII for C locale (GH-8969)

    On HP-UX with C or POSIX locale, sys.getfilesystemencoding() now returns
    &amp;quot;ascii&amp;quot; instead of &amp;quot;roman8&amp;quot; (when the UTF-8 Mode is disabled and the C locale
    is not coerced).

    nl_langinfo(CODESET) announces &amp;quot;roman8&amp;quot; whereas it uses the Latin1
    encoding in practice.
&lt;/pre&gt;
&lt;p&gt;Extract of the heuristic code:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
if (strcmp(encoding, &amp;quot;roman8&amp;quot;) == 0) {
    unsigned char ch = (unsigned char)0xA7;
    wchar_t wch;
    size_t res = mbstowcs(&amp;amp;wch, (char*)&amp;amp;ch, 1);
    if (res != (size_t)-1 &amp;amp;&amp;amp; wch == L'\xA7') {
        /* On HP-UX withe C locale or the POSIX locale,
           nl_langinfo(CODESET) announces &amp;quot;roman8&amp;quot;,
           whereas mbstowcs() uses Latin1 encoding in practice.
           Force ASCII in this case.  Roman8 decodes 0xA7
           to U+00CF. Latin1 decodes 0xA7 to U+00A7. */
        return 1;
    }
}
&lt;/pre&gt;
&lt;p&gt;Python 3.8 will handle better Unicode support on HP-UX. The test_utf8_mode
failure was just a hint for a real underlying bug!&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="standard-streams-and-filesystem-encodings"&gt;
&lt;h2&gt;Standard streams and filesystem encodings&lt;/h2&gt;
&lt;p&gt;While reworking the Python initialization, I tried to move &lt;strong&gt;all&lt;/strong&gt;
configuration parameters to a new &lt;tt class="docutils literal"&gt;_PyCoreConfig&lt;/tt&gt; structure. But I know that
I missed at least the standard streams encoding (ex: &lt;tt class="docutils literal"&gt;sys.stdout.encoding&lt;/tt&gt;).
My first attempt failed to move the code, it broke many tests. I created
&lt;a class="reference external" href="https://bugs.python.org/issue34485"&gt;bpo-34485&lt;/a&gt;: &amp;quot;_PyCoreConfig: add
stdio_encoding and stdio_errors&amp;quot;.&lt;/p&gt;
&lt;p&gt;While I was working on stdio encoding, I also recalled that the Python
filesystem encoding is also initialized &amp;quot;late&amp;quot;. I also created &lt;a class="reference external" href="https://bugs.python.org/issue34523"&gt;bpo-34523&lt;/a&gt;: &amp;quot;Choose the filesystem encoding before
Python initialization (add _PyCoreConfig.filesystem_encoding)&amp;quot; to move this
code as well.&lt;/p&gt;
&lt;p&gt;I quickly had an implementation, but it didn't go as well as expected...&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="posix-locale-on-freebsd"&gt;
&lt;h2&gt;POSIX locale on FreeBSD&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="https://bugs.python.org/issue34485"&gt;bpo-34485&lt;/a&gt;: For me, the &amp;quot;C&amp;quot; and &amp;quot;POSIX&amp;quot;
locales were the same locale: C is an alias to POSIX, or the opposite, it
didn't really matter for me. But Python handles them differently in some corner
cases. For example, Nick Coghlan's PEP 538 (C locale coercion) is only enabled
if the LC_CTYPE locale is equal to &amp;quot;C&amp;quot;, not if it's equal to &amp;quot;POSIX&amp;quot;.&lt;/p&gt;
&lt;p&gt;In Python 3.5, I changed stdin and stdout error handlers from strict to
surrogateescape if the LC_CTYPE locale is &amp;quot;C&amp;quot;: &lt;a class="reference external" href="https://bugs.python.org/issue19977"&gt;bpo-19977&lt;/a&gt;. But when I tested my
stdio and filesystem changes on Linux, FreeBSD and Windows, I noticed that
I forgot to handle the &amp;quot;POSIX&amp;quot; locale. On FreeBSD, &lt;tt class="docutils literal"&gt;LC_ALL=POSIX&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;LC_ALL=C&lt;/tt&gt;
behave differently:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;With &lt;tt class="docutils literal"&gt;LC_ALL=POSIX&lt;/tt&gt; environment, &lt;tt class="docutils literal"&gt;setlocale(LC_CTYPE, &amp;quot;&amp;quot;)&lt;/tt&gt; returns &lt;tt class="docutils literal"&gt;&amp;quot;POSIX&amp;quot;&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;With &lt;tt class="docutils literal"&gt;LC_ALL=C&lt;/tt&gt; environment, &lt;tt class="docutils literal"&gt;setlocale(LC_CTYPE, &amp;quot;&amp;quot;)&lt;/tt&gt; returns &lt;tt class="docutils literal"&gt;&amp;quot;C&amp;quot;&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I fixed that to also use the &amp;quot;surrogateescape&amp;quot; error handler for the POSIX
locale on FreeBSD. &lt;a class="reference external" href="https://github.com/python/cpython/commit/315877dc361d554bec34b4b62c270479ad36a1be"&gt;Commit 315877dc&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Author: Victor Stinner &amp;lt;vstinner&amp;#64;redhat.com&amp;gt;
Date:   Wed Aug 29 09:58:12 2018 +0200

    bpo-34485: stdout uses surrogateescape on POSIX locale (GH-8986)

    Standard streams like sys.stdout now use the &amp;quot;surrogateescape&amp;quot; error
    handler, instead of &amp;quot;strict&amp;quot;, on the POSIX locale (when the C locale is not
    coerced and the UTF-8 Mode is disabled).

    Add tests on sys.stdout.errors with LC_ALL=POSIX.
&lt;/pre&gt;
&lt;p&gt;The most important change is just one line:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
-        if (strcmp(ctype_loc, &amp;quot;C&amp;quot;) == 0) {
+        if (strcmp(ctype_loc, &amp;quot;C&amp;quot;) == 0 || strcmp(ctype_loc, &amp;quot;POSIX&amp;quot;) == 0) {
             return &amp;quot;surrogateescape&amp;quot;;
         }
&lt;/pre&gt;
&lt;p&gt;&lt;a class="reference external" href="https://bugs.python.org/issue34527"&gt;bpo-34527&lt;/a&gt;: Since I was testing
various configurations, I also noticed that my UTF-8 Mode (PEP 540) had the
same bug. Python 3.7 enables it if the LC_CTYPE locale is equal to &amp;quot;C&amp;quot;,
but not if it's equal to &amp;quot;POSIX&amp;quot;. I also changed that (&lt;a class="reference external" href="https://github.com/python/cpython/commit/5cb258950ce9b69b1f65646431c464c0c17b1510"&gt;commit 5cb25895&lt;/a&gt;).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="c-locale-on-windows"&gt;
&lt;h2&gt;C locale on Windows&lt;/h2&gt;
&lt;p&gt;While testing my changes on Windows, I noticed that Python starts with the
LC_CTYPE locale equal to &amp;quot;C&amp;quot;, whereas &lt;tt class="docutils literal"&gt;locale.setlocale(locale.LC_CTYPE, &amp;quot;&amp;quot;)&lt;/tt&gt;
changes the LC_CTYPE locale to something like &lt;tt class="docutils literal"&gt;English_United States.1252&lt;/tt&gt;
(English with the code page 1252). Example with Python 3.6:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
C:\&amp;gt; python
Python 3.6.4 (v3.6.4:d48eceb, Dec 19 2017, 06:54:40) [MSC v.1900 64 bit (AMD64)] on win32
&amp;gt;&amp;gt;&amp;gt; import locale
&amp;gt;&amp;gt;&amp;gt; locale.setlocale(locale.LC_CTYPE, None)
'C'
&amp;gt;&amp;gt;&amp;gt; locale.setlocale(locale.LC_CTYPE, &amp;quot;&amp;quot;)
'English_United States.1252'
&amp;gt;&amp;gt;&amp;gt; locale.setlocale(locale.LC_CTYPE, None)
'English_United States.1252'
&lt;/pre&gt;
&lt;p&gt;On UNIX, Python 2 starts with the default C locale, whereas Python 3 always
sets the LC_CTYPE locale to my preference. Example on Fedora 28 with
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LANG=fr_FR.UTF-8&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ python2 -c 'import locale; print(locale.setlocale(locale.LC_CTYPE, None))'
C
$ python3 -c 'import locale; print(locale.setlocale(locale.LC_CTYPE, None))'
fr_FR.UTF-8
&lt;/pre&gt;
&lt;p&gt;I modified Windows to behave as UNIX, &lt;a class="reference external" href="https://github.com/python/cpython/commit/177d921c8c03d30daa32994362023f777624b10d"&gt;commit 177d921c&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Author: Victor Stinner &amp;lt;vstinner&amp;#64;redhat.com&amp;gt;
Date:   Wed Aug 29 11:25:15 2018 +0200

    bpo-34485, Windows: LC_CTYPE set to user preference (GH-8988)

    On Windows, the LC_CTYPE is now set to the user preferred locale at
    startup: _Py_SetLocaleFromEnv(LC_CTYPE) is now called during the
    Python initialization. Previously, the LC_CTYPE locale was &amp;quot;C&amp;quot; at
    startup, but changed when calling setlocale(LC_CTYPE, &amp;quot;&amp;quot;) or
    setlocale(LC_ALL, &amp;quot;&amp;quot;).

    pymain_read_conf() now also calls _Py_SetLocaleFromEnv(LC_CTYPE) to
    behave as _Py_InitializeCore(). Moreover, it doesn't save/restore the
    LC_ALL anymore.

    On Windows, standard streams like sys.stdout now always use
    surrogateescape error handler by default (ignore the locale).
&lt;/pre&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
C:\&amp;gt; python3.6 -c &amp;quot;import locale; print(locale.setlocale(locale.LC_CTYPE, None))&amp;quot;
C
C:\&amp;gt; python3.8 -c &amp;quot;import locale; print(locale.setlocale(locale.LC_CTYPE, None))&amp;quot;
English_United States.1252
&lt;/pre&gt;
&lt;p&gt;On Windows, Python 3.8 now starts with the LC_CTYPE locale set to my
preference, as it was already previously done on UNIX.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="back-to-stdio-encoding"&gt;
&lt;h2&gt;Back to stdio encoding&lt;/h2&gt;
&lt;p&gt;After all previous changes and fixes, I was able to push my &lt;a class="reference external" href="https://github.com/python/cpython/commit/dfe0dc74536dfb6f331131d9b2b49557675bb6b7"&gt;commit dfe0dc74&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Author: Victor Stinner &amp;lt;vstinner&amp;#64;redhat.com&amp;gt;
Date:   Wed Aug 29 11:47:29 2018 +0200

    bpo-34485: Add _PyCoreConfig.stdio_encoding (GH-8881)

    * Add stdio_encoding and stdio_errors fields to _PyCoreConfig.
    * Add unit tests on stdio_encoding and stdio_errors.
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="back-to-filesystem-encoding"&gt;
&lt;h2&gt;Back to filesystem encoding&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/python/cpython/commit/b2457efc78b74a1d6d1b77d11a939e886b8a4e2c"&gt;Commit b2457efc&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Author: Victor Stinner &amp;lt;vstinner&amp;#64;redhat.com&amp;gt;
Date:   Wed Aug 29 13:25:36 2018 +0200

    bpo-34523: Add _PyCoreConfig.filesystem_encoding (GH-8963)

    _PyCoreConfig_Read() is now responsible to choose the filesystem
    encoding and error handler. Using Py_Main(), the encoding is now
    chosen even before calling Py_Initialize().

    _PyCoreConfig.filesystem_encoding is now the reference, instead of
    Py_FileSystemDefaultEncoding, for the Python filesystem encoding.

    Changes:

    * Add filesystem_encoding and filesystem_errors to _PyCoreConfig
    * _PyCoreConfig_Read() now reads the locale encoding for the file
      system encoding.
    * PyUnicode_EncodeFSDefault() and PyUnicode_DecodeFSDefaultAndSize()
      now use the interpreter configuration rather than
      Py_FileSystemDefaultEncoding and Py_FileSystemDefaultEncodeErrors
      global configuration variables.
    * Add _Py_SetFileSystemEncoding() and _Py_ClearFileSystemEncoding()
      private functions to only modify Py_FileSystemDefaultEncoding and
      Py_FileSystemDefaultEncodeErrors in coreconfig.c.
    * _Py_CoerceLegacyLocale() now takes an int rather than
      _PyCoreConfig for the warning.
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="use-surrogatepass-on-windows"&gt;
&lt;h2&gt;Use surrogatepass on Windows&lt;/h2&gt;
&lt;p&gt;While working on the filesystem encoding change, I had a bug in
_freeze_importlib.exe which failed at startup:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ValueError: only 'strict' and 'surrogateescape' error handlers are supported, not 'surrogatepass'
&lt;/pre&gt;
&lt;p&gt;I used the following workaround in &lt;tt class="docutils literal"&gt;_freeze_importlib.c&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#ifdef MS_WINDOWS
    /* bpo-34523: initfsencoding() is not called if _install_importlib=0,
       so interp-&amp;gt;fscodec_initialized value remains 0.
       PyUnicode_EncodeFSDefault() doesn't support the &amp;quot;surrogatepass&amp;quot; error
       handler in such case, whereas it's the default error handler on Windows.
       Force the &amp;quot;strict&amp;quot; error handler to work around this bootstrap issue. */
    config.filesystem_errors = &amp;quot;strict&amp;quot;;
#endif
&lt;/pre&gt;
&lt;p&gt;But I wasn't fully happy with the workaround. When running more manual tests, I
found that the &lt;tt class="docutils literal"&gt;PYTHONLEGACYWINDOWSFSENCODING&lt;/tt&gt; environment variable wasn't
handled properly. I pushed a first fix,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/c5989cd87659acbfd4d19dc00dbe99c3a0fc9bd2"&gt;commit c5989cd8&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Author: Victor Stinner &amp;lt;vstinner&amp;#64;redhat.com&amp;gt;
Date:   Wed Aug 29 19:32:47 2018 +0200

    bpo-34523: Py_DecodeLocale() use UTF-8 on Windows (GH-8998)

    Py_DecodeLocale() and Py_EncodeLocale() now use the UTF-8 encoding on
    Windows if Py_LegacyWindowsFSEncodingFlag is zero.

    pymain_read_conf() now sets Py_LegacyWindowsFSEncodingFlag in its
    loop, but restore its value at exit.
&lt;/pre&gt;
&lt;p&gt;My intent was to be able to use the &lt;tt class="docutils literal"&gt;surrogatepass&lt;/tt&gt; error handler. If
&lt;tt class="docutils literal"&gt;Py_DecodeLocale()&lt;/tt&gt; is hardcoded to use UTF-8 on Windows, we should get
access to the &lt;tt class="docutils literal"&gt;surrogatepass&lt;/tt&gt; error handler. Previously, &lt;tt class="docutils literal"&gt;mbstowcs()&lt;/tt&gt;
function was used and this function only support &lt;tt class="docutils literal"&gt;strict&lt;/tt&gt; or
&lt;tt class="docutils literal"&gt;surrogateescape&lt;/tt&gt; error handlers.&lt;/p&gt;
&lt;p&gt;I pushed a second big change to add support for the &lt;tt class="docutils literal"&gt;surrogatepass&lt;/tt&gt; error
handler in locale codecs, &lt;a class="reference external" href="https://github.com/python/cpython/commit/3d4226a832cabc630402589cc671cc4035d504e5"&gt;commit 3d4226a8&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Author: Victor Stinner &amp;lt;vstinner&amp;#64;redhat.com&amp;gt;
Date:   Wed Aug 29 22:21:32 2018 +0200

    bpo-34523: Support surrogatepass in locale codecs (GH-8995)

    Add support for the &amp;quot;surrogatepass&amp;quot; error handler in
    PyUnicode_DecodeFSDefault() and PyUnicode_EncodeFSDefault()
    for the UTF-8 encoding.

    Changes:

    * _Py_DecodeUTF8Ex() and _Py_EncodeUTF8Ex() now support the
      surrogatepass error handler (_Py_ERROR_SURROGATEPASS).
    * _Py_DecodeLocaleEx() and _Py_EncodeLocaleEx() now use
      the _Py_error_handler enum instead of &amp;quot;int surrogateescape&amp;quot; to pass
      the error handler. These functions now return -3 if the error
      handler is unknown.
    * Add unit tests on _Py_DecodeLocaleEx() and _Py_EncodeLocaleEx()
      in test_codecs.
    * Rename get_error_handler() to _Py_GetErrorHandler() and expose it
      as a private function.
    * _freeze_importlib doesn't need config.filesystem_errors=&amp;quot;strict&amp;quot;
      workaround anymore.
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;PyUnicode_DecodeFSDefault()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;PyUnicode_EncodeFSDefault()&lt;/tt&gt; functions
use &lt;tt class="docutils literal"&gt;Py_DecodeLocale()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;Py_EncodeLocale()&lt;/tt&gt; before the Python codec of
the filesystem encoding is loaded. With this big change, &lt;tt class="docutils literal"&gt;Py_DecodeLocale()&lt;/tt&gt;
and &lt;tt class="docutils literal"&gt;Py_EncodeLocale()&lt;/tt&gt; now really behave as the Python codec.&lt;/p&gt;
&lt;p&gt;Previously, Python started with the &lt;tt class="docutils literal"&gt;surrogateescape&lt;/tt&gt; error handler, and
switched to the &lt;tt class="docutils literal"&gt;surrogatepass&lt;/tt&gt; error handler once the Python codec was
loaded.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="filesystem-encoding-documentation"&gt;
&lt;h2&gt;Filesystem encoding documentation&lt;/h2&gt;
&lt;p&gt;One &amp;quot;last&amp;quot; change, I documented how Python selects the filesystem encoding,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/de427556746aa41a8b5198924ce423021bc0c718"&gt;commit de427556&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Author: Victor Stinner &amp;lt;vstinner&amp;#64;redhat.com&amp;gt;
Date:   Wed Aug 29 23:26:55 2018 +0200

    bpo-34523: Py_FileSystemDefaultEncoding NULL by default (GH-9003)

    * Py_FileSystemDefaultEncoding and Py_FileSystemDefaultEncodeErrors
      default value is now NULL: initfsencoding() set them
      during Python initialization.
    * Document how Python chooses the filesystem encoding and error
      handler.
    * Add an assertion to _PyCoreConfig_Read().
&lt;/pre&gt;
&lt;p&gt;Documentation:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
/* Python filesystem encoding and error handler:
   sys.getfilesystemencoding() and sys.getfilesystemencodeerrors().

   Default encoding and error handler:

   * if Py_SetStandardStreamEncoding() has been called: they have the
     highest priority;
   * PYTHONIOENCODING environment variable;
   * The UTF-8 Mode uses UTF-8/surrogateescape;
   * locale encoding: ANSI code page on Windows, UTF-8 on Android,
     LC_CTYPE locale encoding on other platforms;
   * On Windows, &amp;quot;surrogateescape&amp;quot; error handler;
   * &amp;quot;surrogateescape&amp;quot; error handler if the LC_CTYPE locale is &amp;quot;C&amp;quot; or &amp;quot;POSIX&amp;quot;;
   * &amp;quot;surrogateescape&amp;quot; error handler if the LC_CTYPE locale has been coerced
     (PEP 538);
   * &amp;quot;strict&amp;quot; error handler.

   Supported error handlers: &amp;quot;strict&amp;quot;, &amp;quot;surrogateescape&amp;quot; and
   &amp;quot;surrogatepass&amp;quot;. The surrogatepass error handler is only supported
   if Py_DecodeLocale() and Py_EncodeLocale() use directly the UTF-8 codec;
   it's only used on Windows.

   initfsencoding() updates the encoding to the Python codec name.
   For example, &amp;quot;ANSI_X3.4-1968&amp;quot; is replaced with &amp;quot;ascii&amp;quot;.

   On Windows, sys._enablelegacywindowsfsencoding() sets the
   encoding/errors to mbcs/replace at runtime.


   See Py_FileSystemDefaultEncoding and Py_FileSystemDefaultEncodeErrors.
   */
char *filesystem_encoding;
char *filesystem_errors;
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="final-freebsd-10-issue"&gt;
&lt;h2&gt;Final FreeBSD 10 issue&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="https://bugs.python.org/issue34544"&gt;bpo-34544&lt;/a&gt;: The stdio and filesystem
encodings are now properly selected before Py_Initialize(), the LC_CTYPE locale
should be properly initialized, the &amp;quot;POSIX&amp;quot; locale is now properly handled, but
the FreeBSD 10 buildbot still complained about my recent changes... Many
&lt;tt class="docutils literal"&gt;test_c_locale_coerce&lt;/tt&gt; tests started to fail with:&lt;/p&gt;
&lt;blockquote&gt;
Fatal Python error: get_locale_encoding: failed to get the locale encoding: nl_langinfo(CODESET) failed&lt;/blockquote&gt;
&lt;p&gt;Sadly, I wasn't able to reproduce the issue on my FreeBSD 11 VM. I also got
access to the FreeBSD CURRENT buildbot, but I also failed to reproduce the bug
there. I was supposed to get access to the FreeBSD 10 buildbot, but there was a
DNS issue.&lt;/p&gt;
&lt;p&gt;I had to &lt;em&gt;guess&lt;/em&gt; the origin of the bug and I attempted a fix, &lt;a class="reference external" href="https://github.com/python/cpython/commit/f01b2a1b84ee08df73a78cf1017eecf15e3cb995"&gt;commit f01b2a1b&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Author: Victor Stinner &amp;lt;vstinner&amp;#64;redhat.com&amp;gt;
Date:   Mon Sep 3 14:38:21 2018 +0200

    bpo-34544: Fix setlocale() in pymain_read_conf() (GH-9041)

    bpo-34485, bpo-34544: On some FreeBSD, nl_langinfo(CODESET) fails if
    LC_ALL or LC_CTYPE is set to an invalid locale name. Replace
    _Py_SetLocaleFromEnv(LC_CTYPE) with _Py_SetLocaleFromEnv(LC_ALL) to
    initialize properly locales.

    Partially revert commit 177d921c8c03d30daa32994362023f777624b10d.
&lt;/pre&gt;
&lt;p&gt;... but it didn't work.&lt;/p&gt;
&lt;p&gt;I decided to install a FreeBSD 10 VM and one week later... I finally succeded
to reproduce the issue!&lt;/p&gt;
&lt;p&gt;The bug was that the &lt;tt class="docutils literal"&gt;_Py_CoerceLegacyLocale()&lt;/tt&gt; function doesn't restore the
LC_CTYPE to its previous value if it attempted to coerce the LC_CTYPE locale
but no locale worked.&lt;/p&gt;
&lt;p&gt;Previously, it didn't matter, since the LC_CTYPE locale was initialized again
later, or it was saved/restored indirectly. But with my latest changes, the
LC_CTYPE was left unchanged.&lt;/p&gt;
&lt;p&gt;The fix is just to restore LC_CTYPE if &lt;tt class="docutils literal"&gt;_Py_CoerceLegacyLocale()&lt;/tt&gt; fails,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/8ea09110d413829f71d979d8c7073008cb87fb03"&gt;commit 8ea09110&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Author: Victor Stinner &amp;lt;vstinner&amp;#64;redhat.com&amp;gt;
Date:   Mon Sep 3 17:05:18 2018 +0200

    _Py_CoerceLegacyLocale() restores LC_CTYPE on fail (GH-9044)

    bpo-34544: If _Py_CoerceLegacyLocale() fails to coerce the C locale,
    restore the LC_CTYPE locale to the its previous value.
&lt;/pre&gt;
&lt;p&gt;Finally, I succeded to do what I wanted to do initially, remove the code which
saved/restored the LC_ALL locale: &lt;tt class="docutils literal"&gt;pymain_read_conf()&lt;/tt&gt; is now really
responsible to set the LC_CTYPE locale, and it doesn't modify the LC_ALL locale
anymore.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="configuration-of-locales-and-encodings"&gt;
&lt;h2&gt;Configuration of locales and encodings&lt;/h2&gt;
&lt;p&gt;Python has &lt;strong&gt;many&lt;/strong&gt; options to configure the locales and encodings.&lt;/p&gt;
&lt;p&gt;Main options of Python 3.7:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Legacy Windows stdio (PEP 528)&lt;/li&gt;
&lt;li&gt;Legacy Windows filesystem encoding (PEP 529)&lt;/li&gt;
&lt;li&gt;C locale coercion (PEP 538)&lt;/li&gt;
&lt;li&gt;UTF-8 mode (PEP 540)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The combination of C locale coercion and UTF-8 mode is non-obvious and should
be carefully tested!&lt;/p&gt;
&lt;p&gt;Environment variables:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PYTHONCOERCECLOCALE=0&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PYTHONCOERCECLOCALE=1&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PYTHONCOERCECLOCALE=warn&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;PYTHONIOENCODING=:&amp;lt;errors&amp;gt;&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;PYTHONIOENCODING=&amp;lt;encoding&amp;gt;:&amp;lt;errors&amp;gt;&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;PYTHONIOENCODING=&amp;lt;encoding&amp;gt;&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PYTHONLEGACYWINDOWSFSENCODING=1&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PYTHONLEGACYWINDOWSSTDIO=1&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PYTHONUTF8=0&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PYTHONUTF8=1&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Command line options:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-X&lt;/span&gt; utf8=0&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-X&lt;/span&gt; utf8&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-X&lt;/span&gt; utf8=1&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-E&lt;/span&gt;&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-I&lt;/span&gt;&lt;/tt&gt; (ignore &lt;tt class="docutils literal"&gt;PYTHON*&lt;/tt&gt; environment variables)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Global configuration variables:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_FileSystemDefaultEncodeErrors&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_FileSystemDefaultEncoding&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_LegacyWindowsFSEncodingFlag&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_LegacyWindowsStdioFlag&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_UTF8Mode&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;_PyCoreConfig:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;coerce_c_locale&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;coerce_c_locale_warn&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;filesystem_encoding&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;filesystem_errors&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;stdio_encoding&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;stdio_errors&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The LC_CTYPE locale depends on 3 environment variables:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;LC_ALL&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;LC_CTYPE&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;LANG&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Depending on the platform, the following configuration gives a different
LC_CTYPE locale:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;LC_ALL= LC_CTYPE= LANG=&lt;/tt&gt; (no variable set)&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;LC_ALL= LC_CTYPE=C LANG=&lt;/tt&gt; (C locale)&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;LC_ALL= LC_CTYPE=POSIX LANG=&lt;/tt&gt; (POSIX locale)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In case of doubt, I also tested:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;LC_ALL=C LC_CTYPE= LANG=&lt;/tt&gt; (C locale)&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;LC_ALL=POSIX LC_CTYPE= LANG=&lt;/tt&gt; (POSIX locale)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The LC_CTYPE encoding (locale encoding) can be queried using
&lt;tt class="docutils literal"&gt;nl_langinfo(CODESET)&lt;/tt&gt;. On FreeBSD, Solaris, HP-UX and maybe other platforms,
&lt;tt class="docutils literal"&gt;nl_langinfo(CODESET)&lt;/tt&gt; announces an encoding which is different than the
codec used by &lt;tt class="docutils literal"&gt;mbstowcs()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;wcstombs()&lt;/tt&gt; functions, and so Python forces
the usage of the ASCII encoding.&lt;/p&gt;
&lt;p&gt;The test matrix of all these configurations and all platforms is quite big.
Honestly, I would not bet that Python 3.8 will behave properly in all possible
cases. At least, I tried to fix all issues that I spotted! Moreover, I added
many tests which should help to detect bugs and prevent regressions.&lt;/p&gt;
&lt;/div&gt;
</content><category term="cpython"></category><category term="unicode"></category><category term="locales"></category></entry></feed>