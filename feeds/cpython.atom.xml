<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Victor Stinner blog 3 - cpython</title><link href="https://vstinner.github.io/" rel="alternate"></link><link href="https://vstinner.github.io/feeds/cpython.atom.xml" rel="self"></link><id>https://vstinner.github.io/</id><updated>2020-12-27T22:00:00+01:00</updated><entry><title>Isolate Python Subinterpreters</title><link href="https://vstinner.github.io/isolate-subinterpreters.html" rel="alternate"></link><published>2020-12-27T22:00:00+01:00</published><updated>2020-12-27T22:00:00+01:00</updated><author><name>Victor Stinner</name></author><id>tag:vstinner.github.io,2020-12-27:/isolate-subinterpreters.html</id><summary type="html">&lt;img alt="Christmas gift." src="https://vstinner.github.io/images/christmas-gift.jpg" /&gt;
&lt;p&gt;This article is about the work done in Python in 2019 and 2020 to better
isolate subinterpreters. Static types are converted to heap types, extension
modules are converted to use the new multiphase initialization API (PEP 489),
caches, states, singletons and free lists are made per-interpreter, many bugs
have been …&lt;/p&gt;</summary><content type="html">&lt;img alt="Christmas gift." src="https://vstinner.github.io/images/christmas-gift.jpg" /&gt;
&lt;p&gt;This article is about the work done in Python in 2019 and 2020 to better
isolate subinterpreters. Static types are converted to heap types, extension
modules are converted to use the new multiphase initialization API (PEP 489),
caches, states, singletons and free lists are made per-interpreter, many bugs
have been fixed, etc.&lt;/p&gt;
&lt;p&gt;Running multiple interpreters in parallel with one &amp;quot;GIL&amp;quot; per interpreter cannot
be done yet, but a lot of complex technical challenges have been solved.&lt;/p&gt;
&lt;div class="section" id="why-isolating-subinterpreters"&gt;
&lt;h2&gt;Why isolating subinterpreters?&lt;/h2&gt;
&lt;p&gt;The final goal is to be able run multiple interpreters in parallel in the same
process, like one interpreter per CPU, each interpreter would run in its own
thread. The principle is the same than the multiprocessing module and has the
same limitations: no Python object can be shared directly between two
interpreters. Later, we can imagine helpers to share Python mutable objects
using proxies which would prevent race conditions.&lt;/p&gt;
&lt;p&gt;The work on subinterpreter requires to modify many functions and extension
modules. It will benefit to Python in different ways.&lt;/p&gt;
&lt;p&gt;Converting static types to heap types and convert extension modules to the
multiphase initialization API (PEP 489) makes extension modules implemented in
C to behave closer to modules implemented in Python, which is good for the &lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0399/"&gt;PEP
399 -- Pure Python/C Accelerator Module Compatibility Requirements&lt;/a&gt;. So &lt;strong&gt;this work also helps
Python implementations other than CPython, like PyPy&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;These changes also destroy more Python objects and release more memory at
Python exit which matters &lt;strong&gt;when Python is embedded in an application&lt;/strong&gt;. Python
should be &amp;quot;state less&amp;quot;, especially release all memory at exit. This work slowly
fix the &lt;a class="reference external" href="https://bugs.python.org/issue1635741"&gt;bpo-163574: Py_Finalize() doesn't clear all Python objects at exit&lt;/a&gt;. Python leaks less and less Python
objects at exit.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="proof-of-concept-in-may-2020"&gt;
&lt;h2&gt;Proof-of-concept in May 2020&lt;/h2&gt;
&lt;p&gt;In May 2020, I wrote a proof-of-concept to prove the feasability of the project
and to prove that it is faster than sequential execution: &lt;a class="reference external" href="https://mail.python.org/archives/list/python-dev&amp;#64;python.org/thread/S5GZZCEREZLA2PEMTVFBCDM52H4JSENR/#RIK75U3ROEHWZL4VENQSQECB4F4GDELV"&gt;PoC: Subinterpreters
4x faster than sequential execution or threads on CPU-bound workaround&lt;/a&gt;.
Benchmark on 4 CPUs:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Sequential: 1.99 sec +- 0.01 sec&lt;/li&gt;
&lt;li&gt;Threads: 3.15 sec +- 0.97 sec (1.5x &lt;strong&gt;slower&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;Multiprocessing: 560 ms +- 12 ms (3.6x &lt;strong&gt;faster&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;Subinterpreters: 583 ms +- 7 ms (3.4x &lt;strong&gt;faster&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The performance of subintepreters is basically the same speed than
multiprocessing on this benchmark which is promising.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="experimental-isolated-subintepreters"&gt;
&lt;h2&gt;Experimental isolated subintepreters&lt;/h2&gt;
&lt;p&gt;To write this PoC, I added a &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--with-experimental-isolated-subinterpreters&lt;/span&gt;&lt;/tt&gt;
option to &lt;tt class="docutils literal"&gt;./configure&lt;/tt&gt; in &lt;a class="reference external" href="https://bugs.python.org/issue40514"&gt;bpo-40514&lt;/a&gt;
which defines the &lt;tt class="docutils literal"&gt;EXPERIMENTAL_ISOLATED_SUBINTERPRETERS&lt;/tt&gt; macro. Effects of
this special build:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Make the GIL per-interpreter.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;_xxsubinterpreters.run_string()&lt;/tt&gt; releases the GIL when running the
subinterpreter.&lt;/li&gt;
&lt;li&gt;Add a thread local storage for the Python thread state (&amp;quot;tstate&amp;quot;).&lt;/li&gt;
&lt;li&gt;Disable the garbage collector in subinterpreters.&lt;/li&gt;
&lt;li&gt;Disable the type attribute lookup cache.&lt;/li&gt;
&lt;li&gt;Disable free lists: frame, list, tuple, type attribute lookup cache.&lt;/li&gt;
&lt;li&gt;Disable singletons: latin1 characters.&lt;/li&gt;
&lt;li&gt;Disable interned strings.&lt;/li&gt;
&lt;li&gt;Disable the fast pymalloc memory allocator (force libc malloc memory
allocator).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Features are disabled because their implementation is currently not compatible
with multiple interpreters running in parallel.&lt;/p&gt;
&lt;p&gt;This special build is designed to be temporary. It should ease the development
of isolated subinterpreters. It will be removed once subinterpreters will be
fully isolated (once each interpreter will have its own GIL).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="convert-static-types-to-heap-types"&gt;
&lt;h2&gt;Convert static types to heap types&lt;/h2&gt;
&lt;p&gt;Types declared in Python (&lt;tt class="docutils literal"&gt;class MyType: ...&lt;/tt&gt;) are always &amp;quot;heap types&amp;quot;:
types dynamically allocated on the heap memory. Historically, all types
declared in C were declared as &amp;quot;static types&amp;quot;: defined statically at build
time.&lt;/p&gt;
&lt;p&gt;In C, static types are referenced directly using the using &lt;tt class="docutils literal"&gt;&amp;amp;&lt;/tt&gt; operator to
get their address, they are not copied. For example, the Python &lt;tt class="docutils literal"&gt;str&lt;/tt&gt; type is
referenced as &lt;tt class="docutils literal"&gt;&amp;amp;PyUnicode_Type&lt;/tt&gt; in C.&lt;/p&gt;
&lt;p&gt;Types are also regular objects (&lt;tt class="docutils literal"&gt;PyTypeObject&lt;/tt&gt; inherits from &lt;tt class="docutils literal"&gt;PyObject&lt;/tt&gt;)
and have a reference count, whereas the &lt;tt class="docutils literal"&gt;PyObject.ob_refcnt&lt;/tt&gt; member is not
atomic and so must not be modified in parallel. Problem: all interpreters share
the same static types.  Static types have other problems:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;A type &lt;tt class="docutils literal"&gt;__mro__&lt;/tt&gt; tuple (&lt;tt class="docutils literal"&gt;PyTypeObject.tp_mro&lt;/tt&gt; member) has the same
problem of non-atomic reference count.&lt;/li&gt;
&lt;li&gt;When a subtype is created, it is stored in the &lt;tt class="docutils literal"&gt;PyTypeObject.tp_subclasses&lt;/tt&gt;
dictionary member (accessible in Python with the &lt;tt class="docutils literal"&gt;__subclasses__()&lt;/tt&gt;
method), whereas Python dictionaries are not thread-safe.&lt;/li&gt;
&lt;li&gt;Static types behave differently than regular Python types. For example,
usually it is not possible to add an arbitrary attribute or override
an attribute. It goes against the &lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0399/"&gt;PEP 399 -- Pure Python/C Accelerator
Module Compatibility Requirements&lt;/a&gt; principles.&lt;/li&gt;
&lt;li&gt;etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Right now, &lt;strong&gt;43% (89/206)&lt;/strong&gt; of types are declared as heap types on a total of
206 types. For comparison, in Python 3.8, only 9% (15/172) of types were
declared as heap types: &lt;strong&gt;74 types&lt;/strong&gt; have been converted in the meanwhile.&lt;/p&gt;
&lt;p&gt;TODO: convert the remaining 117 static types: see &lt;a class="reference external" href="https://bugs.python.org/issue40077"&gt;bpo-40077&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="multiphase-initialization-api"&gt;
&lt;h2&gt;Multiphase initialization API&lt;/h2&gt;
&lt;p&gt;Historically, extension modules are declared with the &lt;tt class="docutils literal"&gt;PyModule_Create()&lt;/tt&gt;
function. Usually, such extension can be instanciated exactly once. It is
stored in an internal &lt;tt class="docutils literal"&gt;PyInterpreterState.modules_by_index&lt;/tt&gt; list; an unique
index is assigned to the module and stored in &lt;tt class="docutils literal"&gt;PyModuleDef.m_base.m_index&lt;/tt&gt;.
Usually, such extension use static global variables.&lt;/p&gt;
&lt;p&gt;Such &amp;quot;static&amp;quot; extension has multiple issues:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;The extension cannot be unloaded: its memory is not released at Python exit.
It is an issue when Python is embedded in an application.&lt;/li&gt;
&lt;li&gt;The extension behaves differently than modules defined in Python. When an
extension is reimported, its namespace (&lt;tt class="docutils literal"&gt;module.__dict__&lt;/tt&gt;) is duplicated,
but mutable objects and static global variables are still shared. It goes
against the &lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0399/"&gt;PEP 399 -- Pure Python/C Accelerator Module Compatibility
Requirements&lt;/a&gt; principles.&lt;/li&gt;
&lt;li&gt;etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In 2013, &lt;strong&gt;Petr Viktorin&lt;/strong&gt;, &lt;strong&gt;Stefan Behnel&lt;/strong&gt; and &lt;strong&gt;Nick Coghlan&lt;/strong&gt; wrote the
&lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0489/"&gt;PEP 489 -- Multi-phase extension module initialization&lt;/a&gt; which has been approved and
implemented in Python 3.5. For example, the &lt;tt class="docutils literal"&gt;_abc&lt;/tt&gt; module initialization
function is now just a call to the new &lt;tt class="docutils literal"&gt;PyModuleDef_Init()&lt;/tt&gt; function:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
PyMODINIT_FUNC
PyInit__abc(void)
{
    return PyModuleDef_Init(&amp;amp;_abcmodule);
}
&lt;/pre&gt;
&lt;p&gt;An extension module can have a module state, if &lt;tt class="docutils literal"&gt;PyModuleDef.m_size&lt;/tt&gt; is
greater than zero. Example:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
typedef struct {
    PyTypeObject *_abc_data_type;
    unsigned long long abc_invalidation_counter;
} _abcmodule_state;

static struct PyModuleDef _abcmodule = {
    ...
    .m_size = sizeof(_abcmodule_state),  // &amp;lt;=== HERE ===
};
&lt;/pre&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;PyModule_GetState()&lt;/tt&gt; can be used to retrieve the module state. Example:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static inline _abcmodule_state*
get_abc_state(PyObject *module)
{
    void *state = PyModule_GetState(module);
    assert(state != NULL);
    return (_abcmodule_state *)state;
}

static PyObject *
_abc__abc_init(PyObject *module, PyObject *self)
{
    _abcmodule_state *state = get_abc_state(module);
    ...
    data = abc_data_new(state-&amp;gt;_abc_data_type, NULL, NULL);
    ...
}
&lt;/pre&gt;
&lt;p&gt;Right now, &lt;strong&gt;77% (102/132)&lt;/strong&gt; of extension modules use the new multiphase
initialization API (PEP 489) on a total of 132 extension modules.  For
comparison, in Python 3.8, only 23% (27/118) of extensions used the new
multiphase initialization API: &lt;strong&gt;75 extensions&lt;/strong&gt; have been converted in the
meanwhile.&lt;/p&gt;
&lt;p&gt;TODO: convert the remaining 30 extension modules (&lt;a class="reference external" href="https://bugs.python.org/issue1635741"&gt;bpo-163574&lt;/a&gt;).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="module-states"&gt;
&lt;h2&gt;Module states&lt;/h2&gt;
&lt;p&gt;Some modules have a state which should be stored in the interpreter to share
its state between multiple instances of the module, and also to give access to
the state in functions of the public C API (ex: &lt;tt class="docutils literal"&gt;PyAST_Check()&lt;/tt&gt;).&lt;/p&gt;
&lt;p&gt;States made per-interpreter:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;2019-05-10: &lt;strong&gt;warnings&lt;/strong&gt;
(&lt;a class="reference external" href="https://bugs.python.org/issue36737"&gt;bpo-36737&lt;/a&gt;,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/86ea58149c3e83f402cecd17e6a536865fb06ce1"&gt;commit&lt;/a&gt; by &lt;strong&gt;Eric Snow&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;2019-11-07: &lt;strong&gt;parser&lt;/strong&gt;
(&lt;a class="reference external" href="https://bugs.python.org/issue36876"&gt;bpo-36876&lt;/a&gt;,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/9def81aa52adc3cc89554156e40742cf17312825"&gt;commit&lt;/a&gt; by &lt;strong&gt;Vinay Sajip&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;2019-11-20: &lt;strong&gt;gc&lt;/strong&gt;
(&lt;a class="reference external" href="https://bugs.python.org/issue36854"&gt;bpo-36854&lt;/a&gt;,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/7247407c35330f3f6292f1d40606b7ba6afd5700"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;li&gt;2020-11-02: &lt;strong&gt;ast&lt;/strong&gt;
(&lt;a class="reference external" href="https://bugs.python.org/issue41796"&gt;bpo-41796&lt;/a&gt;,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/5cf4782a2630629d0978bf4cf6b6340365f449b2"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;li&gt;2020-12-15: &lt;strong&gt;atexit&lt;/strong&gt;
(&lt;a class="reference external" href="https://bugs.python.org/issue42639"&gt;bpo-42639&lt;/a&gt;,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/b8fa135908d294b350cdad04e2f512327a538dee"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="singletons"&gt;
&lt;h2&gt;Singletons&lt;/h2&gt;
&lt;p&gt;Singletons must not be shared between interpreters.&lt;/p&gt;
&lt;p&gt;Singletons made per-interpreter.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://bugs.python.org/issue38858"&gt;bpo-38858&lt;/a&gt;:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;2019-12-17: small &lt;strong&gt;integer&lt;/strong&gt;, the [-5; 256] range
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/630c8df5cf126594f8c1c4579c1888ca80a29d59"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a class="reference external" href="https://bugs.python.org/issue40521"&gt;bpo-40521&lt;/a&gt;:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;2020-06-04: empty &lt;strong&gt;tuple&lt;/strong&gt; singleton
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/69ac6e58fd98de339c013fe64cd1cf763e4f9bca"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;li&gt;2020-06-23: empty &lt;strong&gt;bytes&lt;/strong&gt; string singleton and single byte character
(&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;b'\x00'&lt;/span&gt;&lt;/tt&gt; to &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;b'\xFF'&lt;/span&gt;&lt;/tt&gt;) singletons
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/c41eed1a874e2f22bde45c3c89418414b7a37f46"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;li&gt;2020-06-23: empty &lt;strong&gt;Unicode&lt;/strong&gt; string singleton
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/f363d0a6e9cfa50677a6de203735fbc0d06c2f49"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;li&gt;2020-06-23: empty &lt;strong&gt;frozenset&lt;/strong&gt; singleton
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/261cfedf7657a515e04428bba58eba2a9bb88208"&gt;commit&lt;/a&gt; by me);
later removed.&lt;/li&gt;
&lt;li&gt;2020-06-24: single &lt;strong&gt;Unicode&lt;/strong&gt; character (U+0000-U+00FF range)
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/2f9ada96e0d420fed0d09a032b37197f08ef167a"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I also micro-optimized the code: most singletons are now always created at
startup, it's no longer needed to check if it is created at each function call.
Moreover, an assertion now ensures that singletons are no longer used after
they are deleted.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="free-lists"&gt;
&lt;h2&gt;Free lists&lt;/h2&gt;
&lt;p&gt;A free list is a micro-optimization on memory allocations. The memory of
recently destroyed objects is not freed to be able to reuse it for new objects.
Free lists must not be shared between interpreters.&lt;/p&gt;
&lt;p&gt;Free lists made per-interpreter (&lt;a class="reference external" href="https://bugs.python.org/issue40521"&gt;bpo-40521&lt;/a&gt;):&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;2020-06-04: &lt;strong&gt;slice&lt;/strong&gt;
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/7daba6f221e713f7f60c613b246459b07d179f91"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;li&gt;2020-06-04: &lt;strong&gt;tuple&lt;/strong&gt;
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/69ac6e58fd98de339c013fe64cd1cf763e4f9bca"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;li&gt;2020-06-04: &lt;strong&gt;float&lt;/strong&gt;
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/2ba59370c3dda2ac229c14510e53a05074b133d1"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;li&gt;2020-06-04: &lt;strong&gt;frame&lt;/strong&gt;
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/3744ed2c9c0b3905947602fc375de49533790cb9"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;li&gt;2020-06-05: &lt;strong&gt;async generator&lt;/strong&gt;
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/78a02c2568714562e23e885b6dc5730601f35226"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;li&gt;2020-06-05: &lt;strong&gt;context&lt;/strong&gt;
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/e005ead49b1ee2b1507ceea94e6f89c28ecf1f81"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;li&gt;2020-06-05: &lt;strong&gt;list&lt;/strong&gt;
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/88ec9190105c9b03f49aaef601ce02b242a75273"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;li&gt;2020-06-23: &lt;strong&gt;dict&lt;/strong&gt;
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/b4e85cadfbc2b1b24ec5f3159e351dbacedaa5e0"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;li&gt;2020-06-23: &lt;strong&gt;MemoryError&lt;/strong&gt;
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/281cce1106568ef9fec17e3c72d289416fac02a5"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="caches"&gt;
&lt;h2&gt;Caches&lt;/h2&gt;
&lt;p&gt;Caches made per interpreter:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;2020-06-04: &lt;strong&gt;slice&lt;/strong&gt; cache
(&lt;a class="reference external" href="https://bugs.python.org/issue40521"&gt;bpo-40521&lt;/a&gt;,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/7daba6f221e713f7f60c613b246459b07d179f91"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;li&gt;2020-12-26: &lt;strong&gt;type&lt;/strong&gt; attribute lookup cache
(&lt;a class="reference external" href="https://bugs.python.org/issue42745"&gt;bpo-42745&lt;/a&gt;,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/41010184880151d6ae02a226dbacc796e5c90d11"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="interned-strings-and-identifiers"&gt;
&lt;h2&gt;Interned strings and identifiers&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;2020-12-25: Per-interpreter identifiers: &lt;tt class="docutils literal"&gt;_PyUnicode_FromId()&lt;/tt&gt;
(&lt;a class="reference external" href="https://bugs.python.org/issue39465"&gt;bpo-39465&lt;/a&gt;,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/ba3d67c2fb04a7842741b1b6da5d67f22c579f33"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;li&gt;2020-12-26: Per-interpreter interned strings: &lt;tt class="docutils literal"&gt;PyUnicode_InternInPlace()&lt;/tt&gt;
(&lt;a class="reference external" href="https://bugs.python.org/issue40521"&gt;bpo-40521&lt;/a&gt;,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/ea251806b8dffff11b30d2182af1e589caf88acf"&gt;commit&lt;/a&gt; by me)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For &lt;tt class="docutils literal"&gt;_PyUnicode_FromId()&lt;/tt&gt;, I added the &lt;tt class="docutils literal"&gt;pycore_atomic_funcs.h&lt;/tt&gt; header file
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/52a327c1cbb86c7f2f5c460645889b23615261bf"&gt;commit&lt;/a&gt;)
which adds functions for atomic memory accesses (to variables of type
&lt;tt class="docutils literal"&gt;Py_ssize_t&lt;/tt&gt;). It uses &lt;tt class="docutils literal"&gt;__atomic_load_n()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;__atomic_store_n()&lt;/tt&gt; on GCC
and clang, or &lt;tt class="docutils literal"&gt;_InterlockedCompareExchange64()&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;_InterlockedExchange64()&lt;/tt&gt; on MSC (Windows).&lt;/p&gt;
&lt;p&gt;First, I tried to use the &lt;tt class="docutils literal"&gt;_Py_hashtable&lt;/tt&gt; type: &lt;a class="reference external" href="https://github.com/python/cpython/pull/20048"&gt;PR 20048&lt;/a&gt;. Using &lt;tt class="docutils literal"&gt;_Py_hashtable&lt;/tt&gt;,
&lt;tt class="docutils literal"&gt;_PyUnicode_FromId()&lt;/tt&gt; took 15.5 ns +- 0.1 ns.  I optimized &lt;tt class="docutils literal"&gt;_Py_hashtable&lt;/tt&gt;:
&lt;tt class="docutils literal"&gt;_PyUnicode_FromId()&lt;/tt&gt; took 6.65 ns +- 0.09 ns. But it was still slower than
the reference code: 2.38 ns +- 0.00 ns.&lt;/p&gt;
&lt;p&gt;The merged implementation uses an array. An unique index is assigned, index in
this array. The array is made larger on demand. The final change adds 1 ns
per function call:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
[ref] 2.42 ns +- 0.00 ns -&amp;gt; [atomic] 3.39 ns +- 0.00 ns: 1.40x slower
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="misc"&gt;
&lt;h2&gt;Misc&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;2020-03-19: Per-interpreter pending calls
(&lt;a class="reference external" href="https://bugs.python.org/issue39984"&gt;bpo-39984&lt;/a&gt;,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/50e6e991781db761c496561a995541ca8d83ff87"&gt;commit&lt;/a&gt; by me).&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="bugfixes"&gt;
&lt;h2&gt;Bugfixes&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://vstinner.github.io/gil-bugfixes-daemon-threads-python39.html"&gt;GIL bugfixes for daemon threads in Python 3.9&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Fix many &lt;a class="reference external" href="https://vstinner.github.io/subinterpreter-leaks.html"&gt;leaks discovered by subinterpreters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Fix pickling heap types implemented in C with protocols 0 and 1
(&lt;a class="reference external" href="https://bugs.python.org/issue41052"&gt;bpo-41052&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="thanks"&gt;
&lt;h2&gt;Thanks&lt;/h2&gt;
&lt;p&gt;The work on subintepreters, multiphase init and heap types is a collaborative
work on-going for 2 years. I would like to thank the following developers for
helping on this large task:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;Christian Heimes&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dong-hee Na&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Eric Snow&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Erlend Egeberg Aasland&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hai Shi&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mohamed Koubaa&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Nick Coghlan&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Paulo Henrique Silva&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Vinay Sajip&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note: Since the work is scattered in many issues and pull requests, it's hard
to track who helped: sorry if I forgot someone! (Please contact me and I
will complete the list.)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="what-s-next"&gt;
&lt;h2&gt;What's Next?&lt;/h2&gt;
&lt;p&gt;There are still multiple interesting technical challenges:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://bugs.python.org/issue39511"&gt;bpo-39511: Per-interpreter singletons (None, True, False, etc.)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://bugs.python.org/issue40601"&gt;bpo-40601: Hide static types from the C API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Make pymalloc allocator compatible with subinterpreters.&lt;/li&gt;
&lt;li&gt;Make the GIL per interpreter. Maybe even give the choice to share or not
the GIL when a subinterpreter is created.&lt;/li&gt;
&lt;li&gt;Make the &lt;tt class="docutils literal"&gt;_PyArg_Parser&lt;/tt&gt; (&lt;tt class="docutils literal"&gt;parser_init()&lt;/tt&gt;) function compatible with
subinterpreters. Maybe use a per-interpreter array, similar solution than
&lt;tt class="docutils literal"&gt;_PyUnicode_FromId()&lt;/tt&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://bugs.python.org/issue15751"&gt;bpo-15751: Make the PyGILState API compatible with subinterpreters&lt;/a&gt; (issue created in 2012!)&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://bugs.python.org/issue40522"&gt;bpo-40522: Get the current Python interpreter state from Thread Local
Storage (autoTSSkey)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Also, there are still many static types to convert to heap types (&lt;a class="reference external" href="https://bugs.python.org/issue40077"&gt;bpo-40077&lt;/a&gt;) and many extension modules to convert
to the multiphase initialization API (&lt;a class="reference external" href="https://bugs.python.org/issue1635741"&gt;bpo-163574&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;I'm tracking the work in my &lt;a class="reference external" href="https://pythondev.readthedocs.io/subinterpreters.html"&gt;Python Subinterpreters&lt;/a&gt; page
and in the &lt;a class="reference external" href="https://bugs.python.org/issue40512"&gt;bpo-40512: Meta issue: per-interpreter GIL&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
</content><category term="cpython"></category><category term="cpython"></category><category term="subinterpreters"></category></entry><entry><title>Hide implementation details from the Python C API</title><link href="https://vstinner.github.io/hide-implementation-details-python-c-api.html" rel="alternate"></link><published>2020-12-25T22:00:00+01:00</published><updated>2020-12-25T22:00:00+01:00</updated><author><name>Victor Stinner</name></author><id>tag:vstinner.github.io,2020-12-25:/hide-implementation-details-python-c-api.html</id><summary type="html">&lt;img alt="My cat attacking the Python C API" src="https://vstinner.github.io/images/pepsie.jpg" /&gt;
&lt;p&gt;This article is the history of Python C API discussions over the last 4 years,
and the creation of C API projects: &lt;a class="reference external" href="https://pythoncapi.readthedocs.io/"&gt;pythoncapi website&lt;/a&gt;, &lt;a class="reference external" href="https://github.com/pythoncapi/pythoncapi_compat"&gt;pythoncapi_compat.h header file&lt;/a&gt; and &lt;a class="reference external" href="https://hpy.readthedocs.io/"&gt;HPy (new clean C API)&lt;/a&gt;. More and more people are aware of issues
caused by the C API and are working …&lt;/p&gt;</summary><content type="html">&lt;img alt="My cat attacking the Python C API" src="https://vstinner.github.io/images/pepsie.jpg" /&gt;
&lt;p&gt;This article is the history of Python C API discussions over the last 4 years,
and the creation of C API projects: &lt;a class="reference external" href="https://pythoncapi.readthedocs.io/"&gt;pythoncapi website&lt;/a&gt;, &lt;a class="reference external" href="https://github.com/pythoncapi/pythoncapi_compat"&gt;pythoncapi_compat.h header file&lt;/a&gt; and &lt;a class="reference external" href="https://hpy.readthedocs.io/"&gt;HPy (new clean C API)&lt;/a&gt;. More and more people are aware of issues
caused by the C API and are working on solutions.&lt;/p&gt;
&lt;p&gt;It took me a lot of iterations to find the right approach to evolve the C API
without breaking too many third-party extension modules. My first ideas were
based on two APIs with an opt-in option somehow. At the end, I decided to fix
directly the default API, and helped maintainers of extension modules to update
their projects for incompatible C API changes.&lt;/p&gt;
&lt;p&gt;I wrote a &lt;tt class="docutils literal"&gt;pythoncapi_compat.h&lt;/tt&gt; header file which adds C API functions of
newer Python to old Python versions up to Python 2.7. I also wrote a
&lt;tt class="docutils literal"&gt;upgrade_pythoncapi.py&lt;/tt&gt; script to add Python 3.10 support to an extension
module without losing Python 2.7 support: the tool adds &lt;tt class="docutils literal"&gt;#include
&amp;quot;pythoncapi_compat.h&amp;quot;&lt;/tt&gt;. For example, it replaces &lt;tt class="docutils literal"&gt;Py_TYPE(obj) = type&lt;/tt&gt;
with &lt;tt class="docutils literal"&gt;Py_SET_SIZE(obj, type)&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;The photo: my cat attacking the Python C API.&lt;/p&gt;
&lt;div class="section" id="year-2016"&gt;
&lt;h2&gt;Year 2016&lt;/h2&gt;
&lt;p&gt;Between 2016 and 2017, Larry Hastings worked on removing the GIL in a CPython
fork called &amp;quot;The Gilectomy&amp;quot;. He pushed the first commit in April 2016: &lt;a class="reference external" href="https://github.com/larryhastings/gilectomy/commit/4a1a4ff49e34b9705608cad968f467af161dcf02"&gt;Removed
the GIL. Don't merge this!&lt;/a&gt;
(&amp;quot;Few programs work now&amp;quot;). At EuroPython 2016, he gave the talk &lt;a class="reference external" href="https://www.youtube.com/watch?v=fgWUwQVoLHo"&gt;Larry Hastings
- The Gilectomy&lt;/a&gt; where he
explains that the current parallelism bottleneck is the CPython reference
counting which doesn't scale with the number of threads.&lt;/p&gt;
&lt;p&gt;It was just another hint telling me that &amp;quot;something&amp;quot; should be done to make the
C API more abstract, move away from implementation details like reference
counting. PyPy also has performance issues with the C API for many years.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="year-2017"&gt;
&lt;h2&gt;Year 2017&lt;/h2&gt;
&lt;div class="section" id="may"&gt;
&lt;h3&gt;May&lt;/h3&gt;
&lt;p&gt;In 2017, I discussed with Eric Snow who was working on subinterpreters. He had
to modify public structures, especially the &lt;tt class="docutils literal"&gt;PyInterpreterState&lt;/tt&gt; structure.
He created &lt;tt class="docutils literal"&gt;Include/internal/&lt;/tt&gt; subdirectory to create a new &amp;quot;internal C API&amp;quot;
which should not be exported. (Later, he moved the &lt;tt class="docutils literal"&gt;PyInterpreterState&lt;/tt&gt;
structure to the internal C API in Python 3.8.)&lt;/p&gt;
&lt;p&gt;I started the discuss C API changes during the Python Language Summit
(PyCon US 2017): &lt;a class="reference external" href="https://github.com/vstinner/conf/raw/master/2017-PyconUS/summit.pdf"&gt;&amp;quot;Python performance&amp;quot; slides (PDF)&lt;/a&gt;:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Split Include in sub-directories&lt;/li&gt;
&lt;li&gt;Move towards a stable ABI by default&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See also the LWN article: &lt;a class="reference external" href="https://lwn.net/Articles/723752/#723949"&gt;Keeping Python competitive&lt;/a&gt; by Jake Edge.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="july-first-pep-draft"&gt;
&lt;h3&gt;July: first PEP draft&lt;/h3&gt;
&lt;p&gt;I proposed the first PEP draft to python-ideas:
&lt;a class="reference external" href="https://mail.python.org/archives/list/python-ideas&amp;#64;python.org/thread/6XATDGWK4VBUQPRHCRLKQECTJIPBVNJQ/"&gt;PEP: Hide implementation details in the C API&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The idea is to add an opt-in option to distutils to build an extension module
with a new C API, remove implementation details from the new C API, and maybe
later switch to the new C API by default.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="september"&gt;
&lt;h3&gt;September&lt;/h3&gt;
&lt;p&gt;I discussed my C API change ideas at the CPython core dev sprint (at Instagram,
California).  The ideas were liked by most (if not all) core developers who are
fine with a minor performance slowdown (caused by replacing macros with
function calls). I wrote &lt;a class="reference external" href="https://vstinner.github.io/new-python-c-api.html"&gt;A New C API for CPython&lt;/a&gt; blog post about these
discussions.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="november"&gt;
&lt;h3&gt;November&lt;/h3&gt;
&lt;p&gt;I proposed &lt;a class="reference external" href="https://mail.python.org/pipermail/python-dev/2017-November/150607.html"&gt;Make the stable API-ABI usable&lt;/a&gt; on
the python-dev list. The idea is to add &lt;tt class="docutils literal"&gt;PyTuple_GET_ITEM()&lt;/tt&gt; (for example) to
the limited C API but declared as a function call. Later, if enough extension
modules are compatible with the extended limited C API, make it the default.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="year-2018"&gt;
&lt;h2&gt;Year 2018&lt;/h2&gt;
&lt;p&gt;In July, I created the &lt;a class="reference external" href="https://pythoncapi.readthedocs.io/"&gt;pythoncapi website&lt;/a&gt; to collect issues of the current C
API, list things to avoid in new functions like borrowed references, and start
to design a new better C API.&lt;/p&gt;
&lt;p&gt;In September, Antonio Cuni wrote &lt;a class="reference external" href="https://morepypy.blogspot.com/2018/09/inside-cpyext-why-emulating-cpython-c.html"&gt;Inside cpyext: Why emulating CPython C API is
so Hard&lt;/a&gt;
article.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="year-2019"&gt;
&lt;h2&gt;Year 2019&lt;/h2&gt;
&lt;p&gt;In February, I sent &lt;a class="reference external" href="https://mail.python.org/archives/list/capi-sig&amp;#64;python.org/thread/WS6ATJWRUQZESGGYP3CCSVPF7OMPMNM6/"&gt;Update on CPython header files reorganization&lt;/a&gt;
to the capi-sig list.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Include/&lt;/tt&gt;: limited C API&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Include/cpython/&lt;/tt&gt;: CPython C API&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Include/internal/&lt;/tt&gt;: CPython internal C API&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In March, I modified the Python debug build to make its ABI compatible with the
release build ABI:
&lt;a class="reference external" href="https://docs.python.org/dev/whatsnew/3.8.html#debug-build-uses-the-same-abi-as-release-build"&gt;What’s New In Python 3.8: Debug build uses the same ABI as release build&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In May, I gave a lightning talk &lt;a class="reference external" href="https://github.com/vstinner/conf/blob/master/2019-Pycon/status_stable_api_abi.pdf"&gt;Status of the stable API and ABI in Python 3.8&lt;/a&gt;,
at the Language Summit (during Pycon US 2019):&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Convert macros to static inline functions&lt;/li&gt;
&lt;li&gt;Install the internal C API&lt;/li&gt;
&lt;li&gt;Debug build now ABI compatible with the release build ABI&lt;/li&gt;
&lt;li&gt;Getting rid of global variables&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;By the way, see my &lt;a class="reference external" href="https://vstinner.github.io/split-include-directory-python38.html"&gt;Split Include/ directory in Python 3.8&lt;/a&gt; article: I converted many macros in
Python 3.8.&lt;/p&gt;
&lt;p&gt;In July, the &lt;a class="reference external" href="https://hpy.readthedocs.io/"&gt;HPy project&lt;/a&gt; was created during
EuroPython at Basel. There was an informal meeting which included core
developers of PyPy (Antonio, Armin and Ronan), CPython (Victor Stinner and Mark
Shannon) and Cython (Stefan Behnel).&lt;/p&gt;
&lt;p&gt;In December, Antonio, Armin and Ronan had a small internal sprint to kick-off
the development of HPy: &lt;a class="reference external" href="https://morepypy.blogspot.com/2019/12/hpy-kick-off-sprint-report.html"&gt;HPy kick-off sprint report&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="year-2020"&gt;
&lt;h2&gt;Year 2020&lt;/h2&gt;
&lt;div class="section" id="april"&gt;
&lt;h3&gt;April&lt;/h3&gt;
&lt;p&gt;I proposed &lt;a class="reference external" href="https://mail.python.org/archives/list/python-dev&amp;#64;python.org/thread/HKM774XKU7DPJNLUTYHUB5U6VR6EQMJF/#TKHNENOXP6H34E73XGFOL2KKXSM4Z6T2"&gt;PEP: Modify the C API to hide implementation details&lt;/a&gt;
on the python-dev list. The main idea is to provide a new optimized Python
runtime which is backward incompatible on purpose, and continue to ship the
regular runtime which is fully backward compatible.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="june"&gt;
&lt;h3&gt;June&lt;/h3&gt;
&lt;p&gt;I wrote &lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0620/"&gt;PEP 620 -- Hide implementation details from the C API&lt;/a&gt; and &lt;a class="reference external" href="https://mail.python.org/archives/list/python-dev&amp;#64;python.org/thread/HKM774XKU7DPJNLUTYHUB5U6VR6EQMJF/"&gt;proposed the PEP to
python-dev&lt;/a&gt;.
This PEP is my 3rd attempt to fix the C API: I rewrote it from scratch. Python
now distributes a new &lt;tt class="docutils literal"&gt;pythoncapi_compat.h&lt;/tt&gt; header and a process is defined
to reduce the number of broken C extensions when introducing C API incompatible
changes listed in this PEP.&lt;/p&gt;
&lt;p&gt;I created the &lt;a class="reference external" href="https://github.com/pythoncapi/pythoncapi_compat"&gt;pythoncapi_compat project&lt;/a&gt;: header file providing new
C API functions to old Python versions using static inline functions.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="december"&gt;
&lt;h3&gt;December&lt;/h3&gt;
&lt;p&gt;I wrote a new &lt;tt class="docutils literal"&gt;upgrade_pythoncapi.py&lt;/tt&gt; script to add Python 3.10
support to an extension module without losing support with Python 2.7.  I sent
&lt;a class="reference external" href="https://mail.python.org/archives/list/capi-sig&amp;#64;python.org/thread/LFLXFMKMZ77UCDUFD5EQCONSAFFWJWOZ/"&gt;New script: add Python 3.10 support to your C extensions without losing Python
3.6 support&lt;/a&gt;
to the capi-sig list.&lt;/p&gt;
&lt;p&gt;The pythoncapi_compat project got its first users (bitarray, immutables,
python-zstandard)! It proves that the project is useful and needed.&lt;/p&gt;
&lt;p&gt;I collaborated with the HPy project to create a manifesto explaining how the C
API prevents to optimize CPython and makes the CPython C API inefficient on
PyPy. It is still a draft.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="cpython"></category><category term="optimization"></category><category term="cpython"></category><category term="c-api"></category></entry><entry><title>Leaks discovered by subinterpreters</title><link href="https://vstinner.github.io/subinterpreter-leaks.html" rel="alternate"></link><published>2020-12-23T14:00:00+01:00</published><updated>2020-12-23T14:00:00+01:00</updated><author><name>Victor Stinner</name></author><id>tag:vstinner.github.io,2020-12-23:/subinterpreter-leaks.html</id><summary type="html">&lt;p&gt;This article is about old reference leaks discovered or caused by the work on
isolating subinterpreters: leaks in 6 different modules (gc, _weakref, _abc,
_signal, _ast and _thread).&lt;/p&gt;
&lt;img alt="_thread GC bug" src="https://vstinner.github.io/images/thread_gc_bug.jpg" /&gt;
&lt;div class="section" id="refleaks-buildbot-failures"&gt;
&lt;h2&gt;Refleaks buildbot failures&lt;/h2&gt;
&lt;p&gt;With my work on isolating subinterpreters, old bugs about Python objects leaked
at Python exit are suddenly becoming blocker …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;This article is about old reference leaks discovered or caused by the work on
isolating subinterpreters: leaks in 6 different modules (gc, _weakref, _abc,
_signal, _ast and _thread).&lt;/p&gt;
&lt;img alt="_thread GC bug" src="https://vstinner.github.io/images/thread_gc_bug.jpg" /&gt;
&lt;div class="section" id="refleaks-buildbot-failures"&gt;
&lt;h2&gt;Refleaks buildbot failures&lt;/h2&gt;
&lt;p&gt;With my work on isolating subinterpreters, old bugs about Python objects leaked
at Python exit are suddenly becoming blocker issues on buildbots.&lt;/p&gt;
&lt;p&gt;When subinterpreters still share Python objects with the main interpreter, it
is ok-ish to leak these objects at Python exit. Right now (current master
branch), there are still more than 18 000 Python objects which are not
destroyed at Python exit:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ./python -X showrefcount -c pass
[18411 refs, 6097 blocks]
&lt;/pre&gt;
&lt;p&gt;This issue is being solved in the &lt;a class="reference external" href="https://bugs.python.org/issue1635741"&gt;bpo-1635741: Py_Finalize() doesn't clear all
Python objects at exit&lt;/a&gt; which was
opened almost 14 years ago (2007).&lt;/p&gt;
&lt;p&gt;When subinterpreters are better isolated, objects are no longer shared, and
suddenly these leaks make subinterpreters tests failing on Refleak buildbots.
For example, when an extension module is converted to the multiphase
initialization API (PEP 489) or when static types are converted to heap types,
these issues pop up.&lt;/p&gt;
&lt;p&gt;It is a blocker issue for me, since I care of having only &amp;quot;green&amp;quot; buildbots (no
test failure), otherwise more serious regressions can be easily missed.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="per-interpreter-gc-state"&gt;
&lt;h2&gt;Per-interpreter GC state&lt;/h2&gt;
&lt;p&gt;In November 2019, I made the state of the GC module per-interpreter in
&lt;a class="reference external" href="https://bugs.python.org/issue36854"&gt;bpo-36854&lt;/a&gt;
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/7247407c35330f3f6292f1d40606b7ba6afd5700"&gt;commit&lt;/a&gt;)
and test_atexit started to leak:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ./python -m test -R 3:3 test_atexit -m test.test_atexit.SubinterpreterTest.test_callbacks_leak
test_atexit leaked [3988, 3986, 3988] references, sum=11962
&lt;/pre&gt;
&lt;p&gt;I fixed the usage of the &lt;tt class="docutils literal"&gt;PyModule_AddObject()&lt;/tt&gt; function in the &lt;tt class="docutils literal"&gt;_testcapi&lt;/tt&gt;
module (&lt;a class="reference external" href="https://github.com/python/cpython/commit/310e2d25170a88ef03f6fd31efcc899fe062da2c"&gt;commit&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;I also pushed a &lt;strong&gt;workaround&lt;/strong&gt; in &lt;tt class="docutils literal"&gt;finalize_interp_clear()&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
+    /* bpo-36854: Explicitly clear the codec registry
+       and trigger a GC collection */
+    PyInterpreterState *interp = tstate-&amp;gt;interp;
+    Py_CLEAR(interp-&amp;gt;codec_search_path);
+    Py_CLEAR(interp-&amp;gt;codec_search_cache);
+    Py_CLEAR(interp-&amp;gt;codec_error_registry);
+    _PyGC_CollectNoFail();
&lt;/pre&gt;
&lt;p&gt;I dislike having to push a &amp;quot;temporary&amp;quot; workaround, but the Python finalization
is really complex and fragile. Fixing the root issues would require too much
work, whereas I wanted to repair the Refleak buildbots as soon as possible.&lt;/p&gt;
&lt;p&gt;In December 2019, the workaround was partially removed (&lt;a class="reference external" href="https://github.com/python/cpython/commit/ac0e1c2694bc199dbd073312145e3c09bee52cc4"&gt;commit&lt;/a&gt;):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
-    Py_CLEAR(interp-&amp;gt;codec_search_path);
-    Py_CLEAR(interp-&amp;gt;codec_search_cache);
-    Py_CLEAR(interp-&amp;gt;codec_error_registry);
&lt;/pre&gt;
&lt;p&gt;The year after (December 2020), the last GC collection was moved into
&lt;tt class="docutils literal"&gt;PyInterpreterState_Clear()&lt;/tt&gt;, before finalizating the GC (&lt;a class="reference external" href="https://github.com/python/cpython/commit/eba5bf2f5672bf4861c626937597b85ac0c242b9"&gt;commit&lt;/a&gt;).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="port-weakref-to-multiphase-init"&gt;
&lt;h2&gt;Port _weakref to multiphase init&lt;/h2&gt;
&lt;p&gt;In March 2020, the &lt;tt class="docutils literal"&gt;_weakref&lt;/tt&gt; module was ported to the multiphase
initialization API (PEP 489) in &lt;a class="reference external" href="https://bugs.python.org/issue40050"&gt;bpo-40050&lt;/a&gt; and test_importlib started to leak:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ./python -m test -R 3:3 test_importlib
test_importlib leaked [6303, 6299, 6303] references, sum=18905
&lt;/pre&gt;
&lt;p&gt;The analysis was quite long and complicated. The importlib imported some
extension modules twice and it has to inject frozen modules to &amp;quot;bootstrap&amp;quot; the
code.&lt;/p&gt;
&lt;p&gt;At the end, I fixed the issue by removing the now unused &lt;tt class="docutils literal"&gt;_weakref&lt;/tt&gt; import in
&lt;tt class="docutils literal"&gt;importlib._bootstrap_external&lt;/tt&gt;
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/83d46e0622d2efdf5f3bf8bf8904d0dcb55fc322"&gt;commit&lt;/a&gt;).
The fix also avoids importing an extension module twice.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="convert-abc-static-types-to-heap-types"&gt;
&lt;h2&gt;Convert _abc static types to heap types&lt;/h2&gt;
&lt;p&gt;In April 2020, the static types of the &lt;tt class="docutils literal"&gt;_abc&lt;/tt&gt; extension module were converted
to heap types in &lt;a class="reference external" href="https://bugs.python.org/issue40077"&gt;bpo-40077&lt;/a&gt;
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/53e4c91725083975598350877e2ed8e2d0194114"&gt;commit&lt;/a&gt;) and
test_threading started to leak:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ./python -m test -R 3:3 test_threading
test_threading leaked [19, 19, 19] references, sum=57
&lt;/pre&gt;
&lt;p&gt;I created &lt;a class="reference external" href="https://bugs.python.org/issue40149"&gt;bpo-40149&lt;/a&gt; to track the leak.&lt;/p&gt;
&lt;div class="section" id="objects-hold-a-reference-to-heap-types"&gt;
&lt;h3&gt;Objects hold a reference to heap types&lt;/h3&gt;
&lt;p&gt;In March 2019, the &lt;tt class="docutils literal"&gt;PyObject_Init()&lt;/tt&gt; function was modified in &lt;a class="reference external" href="https://bugs.python.org/issue35810"&gt;bpo-35810&lt;/a&gt; to keep a strong reference (&lt;tt class="docutils literal"&gt;INCREF&lt;/tt&gt;)
to the type if the type is a heap type
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/364f0b0f19cc3f0d5e63f571ec9163cf41c62958"&gt;commit&lt;/a&gt;):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
+    if (PyType_GetFlags(tp) &amp;amp; Py_TPFLAGS_HEAPTYPE) {
+        Py_INCREF(tp);
+    }
&lt;/pre&gt;
&lt;p&gt;I opened &lt;a class="reference external" href="https://bugs.python.org/issue40217"&gt;bpo-40217: The garbage collector doesn't take in account that objects
of heap allocated types hold a strong reference to their type&lt;/a&gt; to discuss the regression
(the test_threading leak).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="first-workaround-not-merged-force-a-second-garbage-collection"&gt;
&lt;h3&gt;First workaround (not merged): force a second garbage collection&lt;/h3&gt;
&lt;p&gt;While analysing test_threading regression leak, I identified a first
workaround: add a second &lt;tt class="docutils literal"&gt;_PyGC_CollectNoFail()&lt;/tt&gt; call in
&lt;tt class="docutils literal"&gt;finalize_interp_clear()&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;It was only a workaround which helped to understand the issue, it was not
merged.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="first-fix-merged-abc-data-traverse"&gt;
&lt;h3&gt;First fix (merged): abc_data_traverse()&lt;/h3&gt;
&lt;p&gt;I merged a first fix: add a traverse function to the &lt;tt class="docutils literal"&gt;_abc._abc_data&lt;/tt&gt; type
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/9cc3ebd7e04cb645ac7b2f372eaafa7464e16b9c"&gt;commit&lt;/a&gt;):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
+static int
+abc_data_traverse(_abc_data *self, visitproc visit, void *arg)
+{
+    Py_VISIT(self-&amp;gt;_abc_registry);
+    Py_VISIT(self-&amp;gt;_abc_cache);
+    Py_VISIT(self-&amp;gt;_abc_negative_cache);
+    return 0;
+}
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="second-workaround-not-merged-visit-the-type-in-abc-data-traverse"&gt;
&lt;h3&gt;Second workaround (not merged): visit the type in abc_data_traverse()&lt;/h3&gt;
&lt;p&gt;A second workaround was identified: add &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;Py_VISIT(Py_TYPE(self));&lt;/span&gt;&lt;/tt&gt; to
the new &lt;tt class="docutils literal"&gt;abc_data_traverse()&lt;/tt&gt; function.&lt;/p&gt;
&lt;p&gt;Again, it was only a workaround which helped to understand the issue, but it
was not merged.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="second-fix-merged-call-py-visit-py-type-self-automatically"&gt;
&lt;h3&gt;Second fix (merged): call Py_VISIT(Py_TYPE(self)) automatically&lt;/h3&gt;
&lt;p&gt;20 days after I opened &lt;a class="reference external" href="https://bugs.python.org/issue40217"&gt;bpo-40217&lt;/a&gt;,
&lt;strong&gt;Pablo Galindo&lt;/strong&gt; modified &lt;tt class="docutils literal"&gt;PyType_FromSpec()&lt;/tt&gt; to add a wrapper around the
traverse function of heap types to ensure that &lt;tt class="docutils literal"&gt;Py_VISIT(Py_TYPE(self))&lt;/tt&gt; is
always called (&lt;a class="reference external" href="https://github.com/python/cpython/commit/0169d3003be3d072751dd14a5c84748ab63a249f"&gt;commit&lt;/a&gt;).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="last-fix-merged-fix-every-traverse-function"&gt;
&lt;h3&gt;Last fix (merged): fix every traverse function&lt;/h3&gt;
&lt;p&gt;In May 2020, &lt;strong&gt;Pablo Galindo&lt;/strong&gt; changed his mind. He reverted his
&lt;tt class="docutils literal"&gt;PyType_FromSpec()&lt;/tt&gt; change and instead fixed traverse function of heap types
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/1cf15af9a6f28750f37b08c028ada31d38e818dd"&gt;commit&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;At the end, &lt;tt class="docutils literal"&gt;abc_data_traverse()&lt;/tt&gt; calls &lt;tt class="docutils literal"&gt;Py_VISIT(Py_TYPE(self))&lt;/tt&gt;. The
second &amp;quot;workaround&amp;quot; was the correct fix!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="convert-signal-to-multiphase-init"&gt;
&lt;h2&gt;Convert _signal to multiphase init&lt;/h2&gt;
&lt;p&gt;In September 2020, &lt;strong&gt;Mohamed Koubaa&lt;/strong&gt; ported the &lt;tt class="docutils literal"&gt;_signal&lt;/tt&gt; module to the
multiphase initialization API (PEP 489) in &lt;a class="reference external" href="https://bugs.python.org/issue1635741"&gt;bpo-1635741&lt;/a&gt; (&lt;a class="reference external" href="https://github.com/python/cpython/commit/71d1bd9569c8a497e279f2fea6fe47cd70a87ea3"&gt;commit 71d1bd95&lt;/a&gt;)
and test_interpreters started to leak:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ./python -m test -R 3:3 test_interpreters
test_interpreters leaked [237, 237, 237] references, sum=711
&lt;/pre&gt;
&lt;p&gt;I created &lt;a class="reference external" href="https://bugs.python.org/issue41713"&gt;bpo-41713&lt;/a&gt; to track the
regression. Since I failed to find a simple fix, I started by reverting the
change which caused Refleak buildbots to fail (&lt;a class="reference external" href="https://github.com/python/cpython/commit/4b8032e5a4994a7902076efa72fca1e2c85d8b7f"&gt;commit&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;I had to refactor the &lt;tt class="docutils literal"&gt;_signal&lt;/tt&gt; extension module code with multiple commits
to fix all bugs.&lt;/p&gt;
&lt;p&gt;The first fix was to remove the &lt;tt class="docutils literal"&gt;IntHandler&lt;/tt&gt; variable: there was no need to
keep it alive, it was only needed once in &lt;tt class="docutils literal"&gt;signal_module_exec()&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;The second fix is to close the Windows event at exit:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
+ #ifdef MS_WINDOWS
+     if (sigint_event != NULL) {
+         CloseHandle(sigint_event);
+         sigint_event = NULL;
+     }
+ #endif
&lt;/pre&gt;
&lt;p&gt;The last fix, the most important, is to clear the strong reference to old
Python signal handlers when &lt;tt class="docutils literal"&gt;signal_module_exec()&lt;/tt&gt; is called more than once:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
// If signal_module_exec() is called more than one, we must
// clear the strong reference to the previous function.
Py_XSETREF(Handlers[signum].func, Py_NewRef(func));
&lt;/pre&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;_signal&lt;/tt&gt; module is not well isolated for subinterpreters yet, but at
least it no longer leaks.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="per-interpreter-ast-state"&gt;
&lt;h2&gt;Per-interpreter _ast state&lt;/h2&gt;
&lt;p&gt;In September 2019, the &lt;tt class="docutils literal"&gt;_ast&lt;/tt&gt; extension module was converted to PEP 384
(stable ABI) in &lt;a class="reference external" href="https://bugs.python.org/issue38113"&gt;bpo-38113&lt;/a&gt; (&lt;a class="reference external" href="https://github.com/python/cpython/commit/ac46eb4ad6662cf6d771b20d8963658b2186c48c"&gt;commit&lt;/a&gt;):
the AST state moves into a module state.&lt;/p&gt;
&lt;p&gt;This change caused 3 different bugs including crashes (&lt;a class="reference external" href="https://bugs.python.org/issue41194"&gt;bpo-41194&lt;/a&gt;, &lt;a class="reference external" href="https://bugs.python.org/issue41261"&gt;bpo-41261&lt;/a&gt;, &lt;a class="reference external" href="https://bugs.python.org/issue41631"&gt;bpo-41631&lt;/a&gt;). The issue is complex since there are
public C APIs which require to access AST types, whereas it became possible to
have multiple &lt;tt class="docutils literal"&gt;_ast&lt;/tt&gt; extension module instances.&lt;/p&gt;
&lt;p&gt;In July 2020, I fixed the root issue in &lt;a class="reference external" href="https://bugs.python.org/issue41194"&gt;bpo-41194&lt;/a&gt; by replacing the module state with a
global state (&lt;a class="reference external" href="https://github.com/python/cpython/commit/91e1bc18bd467a13bceb62e16fbc435b33381c82"&gt;commit&lt;/a&gt;):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static astmodulestate global_ast_state;
&lt;/pre&gt;
&lt;p&gt;A global state is bad for subinterpreters. In November 2020, I made the AST
state per-interpreter in &lt;a class="reference external" href="https://bugs.python.org/issue41796"&gt;bpo-41796&lt;/a&gt;
(&lt;a class="reference external" href="https://github.com/python/cpython/commit/5cf4782a2630629d0978bf4cf6b6340365f449b2"&gt;commit&lt;/a&gt;
and test_ast started to leak:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ./python -m test -R 3:3 test_ast
test_ast leaked [23640, 23636, 23640] references, sum=70916
&lt;/pre&gt;
&lt;p&gt;The fix is to call &lt;tt class="docutils literal"&gt;_PyAST_Fini()&lt;/tt&gt; earlier (&lt;a class="reference external" href="https://github.com/python/cpython/commit/fd957c124c44441d9c5eaf61f7af8cf266bafcb1"&gt;commit&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Python types contain a reference to themselves in in their
&lt;tt class="docutils literal"&gt;PyTypeObject.tp_mro&lt;/tt&gt; member (the MRO tuple: Method Resolution Order).
&lt;tt class="docutils literal"&gt;_PyAST_Fini()&lt;/tt&gt; must called before the last GC collection to destroy AST
types.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;_PyInterpreterState_Clear()&lt;/tt&gt; now calls &lt;tt class="docutils literal"&gt;_PyAST_Fini()&lt;/tt&gt;. It now also
calls &lt;tt class="docutils literal"&gt;_PyWarnings_Fini()&lt;/tt&gt; on subinterpeters, not only on the main
interpreter.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="thread-lock-traverse"&gt;
&lt;h2&gt;_thread lock traverse&lt;/h2&gt;
&lt;p&gt;In December 2020, while I tried to port the &lt;tt class="docutils literal"&gt;_thread&lt;/tt&gt; extesnion module to the multiphase initialization API
(PEP 489), test_threading started to leak:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ./python -m test -R 3:3 test_threading
test_threading leaked [56, 56, 56] references, sum=168
&lt;/pre&gt;
&lt;p&gt;As usual, the workaround was to force a second GC collection in &lt;tt class="docutils literal"&gt;interpreter_clear()&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
     /* Last garbage collection on this interpreter */
     _PyGC_CollectNoFail(tstate);
+    _PyGC_CollectNoFail(tstate);
     _PyGC_Fini(tstate);
&lt;/pre&gt;
&lt;p&gt;It took me two days to full understand the problem. I drew reference cycles
on paper to help me to understand the problem:&lt;/p&gt;
&lt;img alt="_thread GC bug" src="https://vstinner.github.io/images/thread_gc_bug.jpg" /&gt;
&lt;p&gt;There are two cycles:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Cycle 1:&lt;ul&gt;
&lt;li&gt;at fork function&lt;/li&gt;
&lt;li&gt;-&amp;gt; __main__ module dict&lt;/li&gt;
&lt;li&gt;-&amp;gt; at fork function&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Cycle 2:&lt;ul&gt;
&lt;li&gt;_thread lock type&lt;/li&gt;
&lt;li&gt;-&amp;gt; lock type methods&lt;/li&gt;
&lt;li&gt;-&amp;gt; _thread module dict&lt;/li&gt;
&lt;li&gt;-&amp;gt; _thread local type&lt;/li&gt;
&lt;li&gt;-&amp;gt; _thread module&lt;/li&gt;
&lt;li&gt;-&amp;gt; _thread module state&lt;/li&gt;
&lt;li&gt;-&amp;gt; _thread lock type&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Moreover, there is a link between these two reference cycles: an instance of
the lock type.&lt;/p&gt;
&lt;p&gt;I fixed the issue by adding a traverse function to the lock type and add
&lt;tt class="docutils literal"&gt;Py_TPFLAGS_HAVE_GC&lt;/tt&gt; flag to the type (&lt;a class="reference external" href="https://github.com/python/cpython/commit/6104013838e181e3c698cb07316f449a0c31ea96"&gt;commit&lt;/a&gt;):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
+static int
+lock_traverse(lockobject *self, visitproc visit, void *arg)
+{
+    Py_VISIT(Py_TYPE(self));
+    return 0;
+}
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="notes-on-weird-gc-bugs"&gt;
&lt;h2&gt;Notes on weird GC bugs&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;gc.get_referents()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;gc.get_referrers()&lt;/tt&gt; can be used to check
traverse functions.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;gc.is_tracked()&lt;/tt&gt; can be used to check if the GC tracks an object.&lt;/li&gt;
&lt;li&gt;Using the &lt;tt class="docutils literal"&gt;gdb&lt;/tt&gt; debugger on &lt;tt class="docutils literal"&gt;gc_collect_main()&lt;/tt&gt; helps to see which
objects are collected. See for example the &lt;tt class="docutils literal"&gt;finalize_garbage()&lt;/tt&gt; functions
which calls finalizers on unreachable objects.&lt;/li&gt;
&lt;li&gt;The solution is usually a missing traverse functions or a missing
&lt;tt class="docutils literal"&gt;Py_VISIT()&lt;/tt&gt; in an existing traverse function.&lt;/li&gt;
&lt;li&gt;GC bugs are hard to debug :-)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Thanks &lt;strong&gt;Pablo Galindo&lt;/strong&gt; for helping me to debug all these tricky GC bugs!&lt;/p&gt;
&lt;p&gt;Thanks to everybody who are helping to better isolate subintrepreters by
converting extension modules to the multiphase initialization API (PEP 489) and
by converting dozens of static types to heap types. We made huge progresses
last months!&lt;/p&gt;
&lt;/div&gt;
</content><category term="cpython"></category><category term="cpython"></category><category term="subinterpreters"></category></entry><entry><title>GIL bugfixes for daemon threads in Python 3.9</title><link href="https://vstinner.github.io/gil-bugfixes-daemon-threads-python39.html" rel="alternate"></link><published>2020-04-04T22:00:00+02:00</published><updated>2020-04-04T22:00:00+02:00</updated><author><name>Victor Stinner</name></author><id>tag:vstinner.github.io,2020-04-04:/gil-bugfixes-daemon-threads-python39.html</id><summary type="html">&lt;a class="reference external image-reference" href="https://twitter.com/Bouletcorp/status/1241018332112998401"&gt;&lt;img alt="`#CoronaMaison by Boulet" src="https://vstinner.github.io/images/coronamaison_boulet.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;My previous article &lt;a class="reference external" href="https://vstinner.github.io/daemon-threads-python-finalization-python32.html"&gt;Daemon threads and the Python finalization in Python 3.2 and 3.3&lt;/a&gt; introduces
issues caused by daemon threads in the Python finalization and past changes to
make them work.&lt;/p&gt;
&lt;p&gt;This article is about bugfixes of the infamous GIL (Global Interpreter Lock) in
Python 3.9, between …&lt;/p&gt;</summary><content type="html">&lt;a class="reference external image-reference" href="https://twitter.com/Bouletcorp/status/1241018332112998401"&gt;&lt;img alt="`#CoronaMaison by Boulet" src="https://vstinner.github.io/images/coronamaison_boulet.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;My previous article &lt;a class="reference external" href="https://vstinner.github.io/daemon-threads-python-finalization-python32.html"&gt;Daemon threads and the Python finalization in Python 3.2 and 3.3&lt;/a&gt; introduces
issues caused by daemon threads in the Python finalization and past changes to
make them work.&lt;/p&gt;
&lt;p&gt;This article is about bugfixes of the infamous GIL (Global Interpreter Lock) in
Python 3.9, between March 2019 and March 2020, for daemon threads during Python
finalization. Some bugs were old: up to 6 years old. Some bugs were triggered
by the on-going work on isolating subinterpreters in Python 3.9.&lt;/p&gt;
&lt;p&gt;Drawing: &lt;a class="reference external" href="https://twitter.com/Bouletcorp/status/1241018332112998401"&gt;#CoronaMaison by Boulet&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="fix-1-exit-pyeval-acquirethread-if-finalizing"&gt;
&lt;h2&gt;Fix 1: Exit PyEval_AcquireThread() if finalizing&lt;/h2&gt;
&lt;p&gt;In March 2019, &lt;strong&gt;Remy Noel&lt;/strong&gt; created &lt;a class="reference external" href="https://bugs.python.org/issue36469"&gt;bpo-36469&lt;/a&gt;: a multithreaded Python application
using 20 daemon threads hangs randomly at exit on Python 3.5:&lt;/p&gt;
&lt;blockquote&gt;
The bug happens about once every two weeks on a script that is fired more
than 10K times a day.&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Eric Snow&lt;/strong&gt; analyzed the bug and understood that it is related to daemon
threads and Python finalization. He identified that &lt;tt class="docutils literal"&gt;PyEval_AcquireLock()&lt;/tt&gt;
and &lt;tt class="docutils literal"&gt;PyEval_AcquireThread()&lt;/tt&gt; function take the GIL but don't exit the thread
if Python is finalizing.&lt;/p&gt;
&lt;p&gt;When Python is finalizing and a daemon thread takes the GIL, Python can hang
randomly.&lt;/p&gt;
&lt;p&gt;Eric created &lt;a class="reference external" href="https://bugs.python.org/issue36475"&gt;bpo-36475&lt;/a&gt; to propose to
modify &lt;tt class="docutils literal"&gt;PyEval_AcquireLock()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;PyEval_AcquireThread()&lt;/tt&gt; to also exit
the thread in this case. In April 2019, &lt;strong&gt;Joannah Nanjekye&lt;/strong&gt; fixed the issue
with &lt;a class="reference external" href="https://github.com/python/cpython/commit/f781d202a2382731b43bade845a58d28a02e9ea1"&gt;commit f781d202&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
bpo-36475: Finalize PyEval_AcquireLock() and PyEval_AcquireThread() properly (GH-12667)

PyEval_AcquireLock() and PyEval_AcquireThread() now
terminate the current thread if called while the interpreter is
finalizing, making them consistent with PyEval_RestoreThread(),
Py_END_ALLOW_THREADS, and PyGILState_Ensure().
&lt;/pre&gt;
&lt;p&gt;The fix adds &lt;tt class="docutils literal"&gt;exit_thread_if_finalizing()&lt;/tt&gt; function which exit the thread if
Python is finalizing. This function is called after each &lt;tt class="docutils literal"&gt;take_gil()&lt;/tt&gt; call.&lt;/p&gt;
&lt;p&gt;The fix is very similar to &lt;tt class="docutils literal"&gt;PyEval_RestoreThread()&lt;/tt&gt; fix made in 2013 (&lt;a class="reference external" href="https://github.com/python/cpython/commit/0d5e52d3469a310001afe50689f77ddba6d554d1"&gt;commit
0d5e52d3&lt;/a&gt;)
to fix &lt;a class="reference external" href="https://bugs.python.org/issue1856#msg60014"&gt;bpo-1856&lt;/a&gt; (Python crash
involving daemon threads during Python exit).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="fix-2-pyeval-restorethread-on-freed-tstate"&gt;
&lt;h2&gt;Fix 2: PyEval_RestoreThread() on freed tstate&lt;/h2&gt;
&lt;div class="section" id="concurrent-futures-crash-on-freebsd"&gt;
&lt;h3&gt;concurrent.futures crash on FreeBSD&lt;/h3&gt;
&lt;p&gt;In December 2019, I reported &lt;a class="reference external" href="https://bugs.python.org/issue39088"&gt;bpo-39088&lt;/a&gt;:
test_concurrent_futures &lt;strong&gt;crashed randomly&lt;/strong&gt; with a coredump on AMD64 FreeBSD
Shared 3.x buildbot. In March 2020, I succeeded to reproduce the bug on FreeBSD
and I was able to debug the coredump in gdb:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
(gdb) frame
#0  0x00000000003b518c in PyEval_RestoreThread (tstate=0x801f23790) at Python/ceval.c:387
387         _PyRuntimeState *runtime = tstate-&amp;gt;interp-&amp;gt;runtime;

(gdb) p tstate-&amp;gt;interp
$3 = (PyInterpreterState *) 0xdddddddddddddddd
&lt;/pre&gt;
&lt;p&gt;The Python thread state (&lt;tt class="docutils literal"&gt;tstate&lt;/tt&gt;) was freed. In debug mode, the &amp;quot;free()&amp;quot;
function of the Python memory allocator fills the freed memory block with
&lt;tt class="docutils literal"&gt;0xDD&lt;/tt&gt; byte pattern (&lt;tt class="docutils literal"&gt;D&lt;/tt&gt; stands for dead byte) to detect usage of freed
memory.&lt;/p&gt;
&lt;p&gt;The problem is that Python finalization already freed the memory of all
PyThreadState structures, when &lt;tt class="docutils literal"&gt;PyEval_RestoreThread(tstate)&lt;/tt&gt; is called by a
daemon thread. &lt;tt class="docutils literal"&gt;PyEval_RestoreThread()&lt;/tt&gt; dereferences &lt;tt class="docutils literal"&gt;tstate&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
_PyRuntimeState *runtime = tstate-&amp;gt;interp-&amp;gt;runtime;
&lt;/pre&gt;
&lt;p&gt;This bug is a regression caused by my change:
&lt;a class="reference external" href="https://github.com/python/cpython/commit/01b1cc12e7c6a3d6a3d27ba7c731687d57aae92a"&gt;Add PyInterpreterState.runtime field&lt;/a&gt;
of &lt;a class="reference external" href="https://bugs.python.org/issue36710"&gt;bpo-36710&lt;/a&gt;. I replaced:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
void PyEval_RestoreThread(PyThreadState *tstate) {
    _PyRuntimeState *runtime = &amp;amp;_PyRuntime;
    ...
}
&lt;/pre&gt;
&lt;p&gt;with:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
void PyEval_RestoreThread(PyThreadState *tstate) {
    _PyRuntimeState *runtime = tstate-&amp;gt;interp-&amp;gt;runtime;
    ...
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="fix-pyeval-restorethread-for-daemon-threads"&gt;
&lt;h3&gt;Fix PyEval_RestoreThread() for daemon threads&lt;/h3&gt;
&lt;p&gt;I created &lt;a class="reference external" href="https://bugs.python.org/issue39877"&gt;bpo-39877&lt;/a&gt; to investigate
this bug. I managed to reproduce the crash on Linux with a script spawning
daemon threads which sleep randomly between 0.0 and 1.0 second, and by adding
&lt;tt class="docutils literal"&gt;sleep(1);&lt;/tt&gt; call at &lt;tt class="docutils literal"&gt;Py_RunMain()&lt;/tt&gt; exit.&lt;/p&gt;
&lt;p&gt;I wrote a &lt;tt class="docutils literal"&gt;PyEval_RestoreThread()&lt;/tt&gt; fix which access to
&lt;tt class="docutils literal"&gt;_PyRuntimeState.finalizing&lt;/tt&gt; without the GIL.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Antoine Pitrou&lt;/strong&gt; asked me to convert &lt;tt class="docutils literal"&gt;_PyRuntimeState.finalizing&lt;/tt&gt; to an
atomic variable to avoid inconsistencies in case of parallel accesses. At March
7, 2020, I pushed &lt;a class="reference external" href="https://github.com/python/cpython/commit/7b3c252dc7f44d4bdc4c7c82d225ebd09c78f520"&gt;commit 7b3c252d&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
bpo-39877: _PyRuntimeState.finalizing becomes atomic (GH-18816)

Convert _PyRuntimeState.finalizing field to an atomic variable:

* Rename it to _finalizing
* Change its type to _Py_atomic_address
* Add _PyRuntimeState_GetFinalizing() and _PyRuntimeState_SetFinalizing()
  functions
* Remove _Py_CURRENTLY_FINALIZING() function: replace it with testing
  directly _PyRuntimeState_GetFinalizing() value

Convert _PyRuntimeState_GetThreadState() to static inline function.
&lt;/pre&gt;
&lt;p&gt;The day after, I pushed my fix, &lt;a class="reference external" href="https://github.com/python/cpython/commit/eb4e2ae2b8486e8ee4249218b95d94a9f0cc513e"&gt;commit eb4e2ae2&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
bpo-39877: Fix PyEval_RestoreThread() for daemon threads (GH-18811)

* exit_thread_if_finalizing() does now access directly _PyRuntime
  variable, rather than using tstate-&amp;gt;interp-&amp;gt;runtime since tstate
  can be a dangling pointer after Py_Finalize() has been called.
* exit_thread_if_finalizing() is now called *before* calling
  take_gil(). _PyRuntime.finalizing is an atomic variable,
  we don't need to hold the GIL to access it.
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;exit_thread_if_finalizing()&lt;/tt&gt; is now called &lt;strong&gt;before&lt;/strong&gt; &lt;tt class="docutils literal"&gt;take_gil()&lt;/tt&gt; to
ensure that &lt;tt class="docutils literal"&gt;take_gil()&lt;/tt&gt; cannot be called with an invalid Python thread state
(&lt;tt class="docutils literal"&gt;tstate&lt;/tt&gt;).&lt;/p&gt;
&lt;p&gt;I commented &lt;em&gt;naively&lt;/em&gt;:&lt;/p&gt;
&lt;blockquote&gt;
Ok, it should now be fixed.&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="clear-python-thread-states-earlier-my-first-failed-attempt-in-2013"&gt;
&lt;h2&gt;Clear Python thread states earlier: my first failed attempt in 2013&lt;/h2&gt;
&lt;p&gt;In 2013, I opened &lt;a class="reference external" href="https://bugs.python.org/issue19466"&gt;bpo-19466&lt;/a&gt; to clear
earlier the Python thread state of threads during Python finalization. My
intent was to display &lt;tt class="docutils literal"&gt;ResourceWarning&lt;/tt&gt; warnings of daemon threads as well.
In November 2013, I pushed &lt;a class="reference external" href="https://github.com/python/cpython/commit/45956b9a33af634a2919ade64c1dd223ab2d5235"&gt;commit 45956b9a&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Close #19466: Clear the frames of daemon threads earlier during the Python
shutdown to call objects destructors. So &amp;quot;unclosed file&amp;quot; resource warnings
are now correctly emitted for daemon threads.
&lt;/pre&gt;
&lt;p&gt;Later, I discovered a crash in the the garbage collector while trying to
reproduce a race condition in asyncio: I created &lt;a class="reference external" href="https://bugs.python.org/issue20526"&gt;bpo-20526&lt;/a&gt;. Sadly, this bug was trigger by my
previous change. I decided that it's safer to revert my change.&lt;/p&gt;
&lt;p&gt;By the way, when I looked again at &lt;a class="reference external" href="https://bugs.python.org/issue20526"&gt;bpo-20526&lt;/a&gt;, I was able to reproduce again the
garbage collector bug, likely because of recent changes. With the help of
&lt;strong&gt;Pablo Galindo Salgado&lt;/strong&gt;, Pablo and me &lt;a class="reference external" href="https://bugs.python.org/issue20526#msg364851"&gt;understood the root issue&lt;/a&gt;.  At March 24, 2020, I pushed
a fix (&lt;a class="reference external" href="https://github.com/python/cpython/commit/5804f878e779712e803be927ca8a6df389d82cdf"&gt;commit&lt;/a&gt;)
to finally fix this 6 years old bug! The fix removes the following line from
&lt;tt class="docutils literal"&gt;PyThreadState_Clear()&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Py_CLEAR(tstate-&amp;gt;frame);
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="fix-3-exit-also-take-gil-at-exit-point-if-finalizing"&gt;
&lt;h2&gt;Fix 3: Exit also take_gil() at exit point if finalizing&lt;/h2&gt;
&lt;p&gt;After fixing &lt;tt class="docutils literal"&gt;PyEval_RestoreThread()&lt;/tt&gt;, I decided to attempt again to fix
&lt;a class="reference external" href="https://bugs.python.org/issue19466"&gt;bpo-19466&lt;/a&gt; (clear earlier Python thread
states). Sadly, I discovered that my &lt;tt class="docutils literal"&gt;PyEval_RestoreThread()&lt;/tt&gt; fix
&lt;strong&gt;introduced a race condition&lt;/strong&gt;!&lt;/p&gt;
&lt;p&gt;While the main thread finalizes Python, daemon threads can be waiting for the
GIL: they block in &lt;tt class="docutils literal"&gt;take_gil()&lt;/tt&gt;. When the main thread releases the GIL during
finalization, a daemon thread take the GIL instead of exiting. Daemon threads
only check if they must exit &lt;strong&gt;before&lt;/strong&gt; trying to take the GIL.&lt;/p&gt;
&lt;p&gt;The solution is to call &lt;tt class="docutils literal"&gt;exit_thread_if_finalizing()&lt;/tt&gt; twice in
&lt;tt class="docutils literal"&gt;take_gil()&lt;/tt&gt;: before &lt;strong&gt;and&lt;/strong&gt; after taking the GIL.&lt;/p&gt;
&lt;p&gt;In March 2020, I pushed &lt;a class="reference external" href="https://github.com/python/cpython/commit/9229eeee105f19705f72e553cf066751ac47c7b7"&gt;commit 9229eeee&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
bpo-39877: take_gil() checks tstate_must_exit() twice (GH-18890)

take_gil() now also checks tstate_must_exit() after acquiring
the GIL: exit the thread if Py_Finalize() has been called.
&lt;/pre&gt;
&lt;p&gt;I commented:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I ran multiple times &lt;tt class="docutils literal"&gt;daemon_threads_exit.py&lt;/tt&gt; with &lt;tt class="docutils literal"&gt;slow_exit.patch&lt;/tt&gt;:
no crash.&lt;/p&gt;
&lt;p&gt;I also ran multiple times &lt;tt class="docutils literal"&gt;stress.py&lt;/tt&gt; + &lt;tt class="docutils literal"&gt;sleep_at_exit.patch&lt;/tt&gt; of
bpo-37135: no crash.&lt;/p&gt;
&lt;p&gt;And I tested &lt;tt class="docutils literal"&gt;asyncio_gc.py&lt;/tt&gt; of bpo-19466: no crash neither.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Python finalization now looks reliable.&lt;/strong&gt; I'm not sure if it's &amp;quot;more&amp;quot;
reliable than previously, but at least, I cannot get a crash anymore, even
after bpo-19466 has been fixed (clear Python thread states of daemon
threads earlier).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Funny fact, in June 2019, &lt;strong&gt;Eric Snow&lt;/strong&gt; added a very similar bug in &lt;a class="reference external" href="https://bugs.python.org/issue36818"&gt;bpo-36818&lt;/a&gt; with &lt;a class="reference external" href="https://github.com/python/cpython/commit/396e0a8d9dc65453cb9d53500d0a620602656cfe"&gt;commit 396e0a8d&lt;/a&gt;:
test_multiprocessing_spawn segfault on FreeBSD (&lt;a class="reference external" href="https://bugs.python.org/issue37135"&gt;bpo-37135&lt;/a&gt;). I reverted his change to fix the
issue. At this time, I didn't have the bandwidth to investigate the root cause.
I just reverted Eric's change.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="fix-4-exit-take-gil-while-waiting-for-the-gil-if-finalizing"&gt;
&lt;h2&gt;Fix 4: Exit take_gil() while waiting for the GIL if finalizing&lt;/h2&gt;
&lt;p&gt;While I was working on moving pending calls from &lt;tt class="docutils literal"&gt;_PyRuntime&lt;/tt&gt; to
&lt;tt class="docutils literal"&gt;PyInterpreterState&lt;/tt&gt;, &lt;a class="reference external" href="https://bugs.python.org/issue39984"&gt;bpo-3998&lt;/a&gt;, I had
another bug.&lt;/p&gt;
&lt;p&gt;At March 18, 2020, I pushed a &lt;tt class="docutils literal"&gt;take_gil()&lt;/tt&gt; fix to avoid accessing &lt;tt class="docutils literal"&gt;tstate&lt;/tt&gt;
if Python is finalizing, &lt;a class="reference external" href="https://github.com/python/cpython/commit/29356e03d4f8800b04f799efe7a10e3ce8b16f61"&gt;commit 29356e03&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
bpo-39877: Fix take_gil() for daemon threads (GH-19054)

bpo-39877, bpo-39984: If the thread must exit, don't access tstate to
prevent a potential crash: tstate memory has been freed.
&lt;/pre&gt;
&lt;p&gt;And while working on the inefficient signal handling in multithreaded
applications (&lt;a class="reference external" href="https://bugs.python.org/issue40010"&gt;bpo-40010&lt;/a&gt;), I discovered
that the previous fix was not enough!&lt;/p&gt;
&lt;p&gt;At March 19, 2020, I pushed a &lt;tt class="docutils literal"&gt;take_gil()&lt;/tt&gt; fix to exit while &lt;tt class="docutils literal"&gt;take_gil()&lt;/tt&gt;
is waiting for the GIL if Python is finalizing, &lt;a class="reference external" href="https://github.com/python/cpython/commit/a36adfa6bbf5e612a4d4639124502135690899b8"&gt;commit a36adfa6&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
bpo-39877: 4th take_gil() fix for daemon threads (GH-19080)

bpo-39877, bpo-40010: Add a third tstate_must_exit() check in
take_gil() to prevent using tstate which has been freed.
&lt;/pre&gt;
&lt;p&gt;I can only hope that this fix is the last one to fix all corner cases with
daemon threads in &lt;tt class="docutils literal"&gt;take_gil()&lt;/tt&gt; (&lt;a class="reference external" href="https://bugs.python.org/issue39877"&gt;bpo-39877&lt;/a&gt;)!&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="summary-of-gil-bugfixes"&gt;
&lt;h2&gt;Summary of GIL bugfixes&lt;/h2&gt;
&lt;p&gt;The GIL got 5 main bugfixes for daemon threads and Python finalization:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;May 2011, &lt;strong&gt;Antoine Pitrou&lt;/strong&gt;,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/0d5e52d3469a310001afe50689f77ddba6d554d1"&gt;commit 0d5e52d3&lt;/a&gt;:
&lt;tt class="docutils literal"&gt;take_gil()&lt;/tt&gt; exits if finalizing &lt;strong&gt;after&lt;/strong&gt; taking the GIL (1 check)&lt;/li&gt;
&lt;li&gt;April 2019, &lt;strong&gt;Joannah Nanjekye&lt;/strong&gt;,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/f781d202a2382731b43bade845a58d28a02e9ea1"&gt;commit f781d202&lt;/a&gt;:
PyEval_AcquireLock() and PyEval_AcquireThread() also exit if Python is finalizing&lt;/li&gt;
&lt;li&gt;March 8, 2020, &lt;strong&gt;Victor Stinner&lt;/strong&gt;,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/eb4e2ae2b8486e8ee4249218b95d94a9f0cc513e"&gt;commit eb4e2ae2&lt;/a&gt;:
&lt;tt class="docutils literal"&gt;take_gil()&lt;/tt&gt; exits if finalizing &lt;strong&gt;before&lt;/strong&gt; taking the GIL (1 check)&lt;/li&gt;
&lt;li&gt;March 9, 2020, &lt;strong&gt;Victor Stinner&lt;/strong&gt;,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/9229eeee105f19705f72e553cf066751ac47c7b7"&gt;commit 9229eeee&lt;/a&gt;:
&lt;tt class="docutils literal"&gt;take_gil()&lt;/tt&gt; exits if finalizing &lt;strong&gt;before and after&lt;/strong&gt; taking the GIL (2 checks)&lt;/li&gt;
&lt;li&gt;March 19, 2020, &lt;strong&gt;Victor Stinner&lt;/strong&gt;,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/a36adfa6bbf5e612a4d4639124502135690899b8"&gt;commit a36adfa6&lt;/a&gt;:
&lt;tt class="docutils literal"&gt;take_gil()&lt;/tt&gt; exits if finalizing &lt;strong&gt;before, while, and after&lt;/strong&gt; taking the GIL (3 checks)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content><category term="cpython"></category><category term="cpython"></category><category term="subinterpreters"></category></entry><entry><title>Threading shutdown race condition</title><link href="https://vstinner.github.io/threading-shutdown-race-condition.html" rel="alternate"></link><published>2020-04-03T20:00:00+02:00</published><updated>2020-04-03T20:00:00+02:00</updated><author><name>Victor Stinner</name></author><id>tag:vstinner.github.io,2020-04-03:/threading-shutdown-race-condition.html</id><summary type="html">&lt;p&gt;This article is about a race condition in threading shutdown that I fixed in
Python 3.9 in March 2019. I also forbid spawning daemon threads in
subinterpreters to fix another related bug.&lt;/p&gt;
&lt;a class="reference external image-reference" href="https://twitter.com/neeljulien/status/1240292383369150464"&gt;&lt;img alt="#CoronaMaison by Julien Neel" src="https://vstinner.github.io/images/coronamaison_jneel.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;Drawing: &lt;a class="reference external" href="https://twitter.com/neeljulien/status/1240292383369150464"&gt;#CoronaMaison by Julien Neel&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="race-condition-in-threading-shutdown"&gt;
&lt;h2&gt;Race condition in threading shutdown&lt;/h2&gt;
&lt;div class="section" id="random-test-failure-noticed-on-freebsd-buildbot"&gt;
&lt;h3&gt;Random test failure noticed on FreeBSD buildbot …&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;This article is about a race condition in threading shutdown that I fixed in
Python 3.9 in March 2019. I also forbid spawning daemon threads in
subinterpreters to fix another related bug.&lt;/p&gt;
&lt;a class="reference external image-reference" href="https://twitter.com/neeljulien/status/1240292383369150464"&gt;&lt;img alt="#CoronaMaison by Julien Neel" src="https://vstinner.github.io/images/coronamaison_jneel.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;Drawing: &lt;a class="reference external" href="https://twitter.com/neeljulien/status/1240292383369150464"&gt;#CoronaMaison by Julien Neel&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="race-condition-in-threading-shutdown"&gt;
&lt;h2&gt;Race condition in threading shutdown&lt;/h2&gt;
&lt;div class="section" id="random-test-failure-noticed-on-freebsd-buildbot"&gt;
&lt;h3&gt;Random test failure noticed on FreeBSD buildbot&lt;/h3&gt;
&lt;p&gt;In March 2019, I noticed that &lt;tt class="docutils literal"&gt;test_threading.test_threads_join_2()&lt;/tt&gt; was
killed by SIGABRT on the FreeBSD CURRENT buildbot, &lt;a class="reference external" href="https://bugs.python.org/issue36402"&gt;bpo-36402&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Fatal Python error: Py_EndInterpreter: not the last thread
&lt;/pre&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;test_threads_join_2()&lt;/tt&gt; test &lt;strong&gt;failed randomly&lt;/strong&gt; on buildbots when tests
were &lt;strong&gt;run in parallel&lt;/strong&gt;, but test_threading &lt;strong&gt;passed&lt;/strong&gt; when it was &lt;strong&gt;re-run
sequentially&lt;/strong&gt;.  Such failure was silently ignored, since the build was seen
overall as a success.&lt;/p&gt;
&lt;p&gt;The test &lt;tt class="docutils literal"&gt;test_threading.test_threads_join_2()&lt;/tt&gt; was added by in 2013 &lt;a class="reference external" href="https://github.com/python/cpython/commit/7b4769937fb612d576b6829c3b834f3dd31752f1"&gt;commit
7b476993&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In 2016, I already reported the same test failure: &lt;a class="reference external" href="https://bugs.python.org/issue27791"&gt;bpo-27791&lt;/a&gt; (same test, also on FreeBSD). And
Christian Heimes reported a similar issue: &lt;a class="reference external" href="https://bugs.python.org/issue28084"&gt;bpo-28084&lt;/a&gt;. I simply closed these issues because I
only saw the failure once in 4 months and &lt;strong&gt;I didn't have access to FreeBSD to
attempt to reproduce the crash&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="reproduce-the-race-condition"&gt;
&lt;h3&gt;Reproduce the race condition&lt;/h3&gt;
&lt;p&gt;In 2019, I had a FreeBSD VM to attempt to reproduce the bug locally.&lt;/p&gt;
&lt;p&gt;In June 2019, I found a reliable way to reproduce the bug by &lt;a class="reference external" href="https://github.com/python/cpython/pull/13889/files"&gt;adding random
sleeps to the test&lt;/a&gt;. With
this patch, I was also able to reproduce the bug on Linux. &lt;strong&gt;I am way more
comfortable to debug an issue on Linux&lt;/strong&gt; with my favorite debugging tools!&lt;/p&gt;
&lt;p&gt;I identified a race condition in the Python finalization. I also understood
that the bug was not specific to subinterpreters:&lt;/p&gt;
&lt;blockquote&gt;
The test shows the bug using subinterpreters (Py_EndInterpreter), but
&lt;strong&gt;the bug also exists in Py_Finalize()&lt;/strong&gt; which has the same race condition.&lt;/blockquote&gt;
&lt;p&gt;I wrote a patch for &lt;tt class="docutils literal"&gt;Py_Finalize()&lt;/tt&gt; to help me to reproduce the bug without
subinterpreters:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
+    if (tstate != interp-&amp;gt;tstate_head || tstate-&amp;gt;next != NULL) {
+        Py_FatalError(&amp;quot;Py_EndInterpreter: not the last thread&amp;quot;);
+    }
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;threading._shutdown() race condition&lt;/h3&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;threading._shutdown()&lt;/tt&gt; uses &lt;tt class="docutils literal"&gt;threading.enumerate()&lt;/tt&gt; which iterates on
&lt;tt class="docutils literal"&gt;threading._active&lt;/tt&gt; dictionary.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;threading.Thread&lt;/tt&gt; registers itself into &lt;tt class="docutils literal"&gt;threading._active&lt;/tt&gt; when the
thread starts. It unregisters itself from &lt;tt class="docutils literal"&gt;threading._active&lt;/tt&gt; when it
completes.&lt;/p&gt;
&lt;p&gt;The bug occurs when the thread is unregistered whereas the underlying native
thread is still running and &lt;strong&gt;the Python thread state is not deleted yet&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;_thread._set_sentinel()&lt;/tt&gt; creates a lock and registers a
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;tstate-&amp;gt;on_delete&lt;/span&gt;&lt;/tt&gt; callback to release this lock. It's called by
&lt;tt class="docutils literal"&gt;threading.Thread&lt;/tt&gt; when the thread starts to set
&lt;tt class="docutils literal"&gt;threading.Thread._tstate_lock&lt;/tt&gt;.  This lock is used by
&lt;tt class="docutils literal"&gt;threading.Thread.join()&lt;/tt&gt; method to wait until the thread completes.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;_thread.start_new_thread()&lt;/tt&gt; calls the C function &lt;tt class="docutils literal"&gt;t_bootstrap()&lt;/tt&gt; which
ends with:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
tstate-&amp;gt;interp-&amp;gt;num_threads--;
PyThreadState_Clear(tstate);
PyThreadState_DeleteCurrent();
PyThread_exit_thread();
&lt;/pre&gt;
&lt;p&gt;When the native thread completes, &lt;tt class="docutils literal"&gt;_PyThreadState_DeleteCurrent()&lt;/tt&gt; is called:
it calls &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;tstate-&amp;gt;on_delete()&lt;/span&gt;&lt;/tt&gt; callback which releases
&lt;tt class="docutils literal"&gt;threading.Thread._tstate_lock&lt;/tt&gt; lock.&lt;/p&gt;
&lt;p&gt;The root issue is that:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;threading._shutdown()&lt;/tt&gt; rely on &lt;tt class="docutils literal"&gt;threading._alive&lt;/tt&gt; dictionary&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_EndInterpreter()&lt;/tt&gt; rely on the interpreter linked list of Python thread
states of the interpreter (&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;interp-&amp;gt;tstate_head&lt;/span&gt;&lt;/tt&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The lock on Python thread states (&lt;tt class="docutils literal"&gt;threading.Thread._tstate_lock&lt;/tt&gt;) and
&lt;tt class="docutils literal"&gt;PyThreadState.on_delete&lt;/tt&gt; callback were added in 2013 by &lt;strong&gt;Antoine Pitrou&lt;/strong&gt;
to Python 3.4, &lt;a class="reference external" href="https://github.com/python/cpython/commit/7b4769937fb612d576b6829c3b834f3dd31752f1"&gt;commit 7b476993&lt;/a&gt;
of &lt;a class="reference external" href="https://bugs.python.org/issue18808"&gt;bpo-18808&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Issue #18808: Thread.join() now waits for the underlying thread state
to be destroyed before returning. This prevents unpredictable aborts
in Py_EndInterpreter() when some non-daemon threads are still running.
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="fix-threading-shutdown"&gt;
&lt;h3&gt;Fix threading._shutdown()&lt;/h3&gt;
&lt;p&gt;Finally in June 2019, I fixed the race condition in &lt;tt class="docutils literal"&gt;threading._shutdown()&lt;/tt&gt;
with &lt;a class="reference external" href="https://github.com/python/cpython/commit/468e5fec8a2f534f1685d59da3ca4fad425c38dd"&gt;commit 468e5fec&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
bpo-36402: Fix threading._shutdown() race condition (GH-13948)

Fix a race condition at Python shutdown when waiting for threads.  Wait
until the Python thread state of all non-daemon threads get deleted
(join all non-daemon threads), rather than just wait until Python
threads complete.
&lt;/pre&gt;
&lt;p&gt;The fix is to modify &lt;tt class="docutils literal"&gt;threading._shutdown()&lt;/tt&gt; to wait until the Python thread
state of all non-daemon threads get deleted, rather than calling the &lt;tt class="docutils literal"&gt;join()&lt;/tt&gt;
method of all non-daemon threads. The &lt;tt class="docutils literal"&gt;join()&lt;/tt&gt; does not ensure that the
Python thread state is deleted.&lt;/p&gt;
&lt;p&gt;The Python finalization calls &lt;tt class="docutils literal"&gt;threading._shutdown()&lt;/tt&gt; to wait until all
threads complete. Only non-daemon threads are awaited: daemon threads can
continue to run after &lt;tt class="docutils literal"&gt;threading._shutdown()&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;Py_EndInterpreter()&lt;/tt&gt; requires that the Python thread states of all threads
have been deleted. &lt;strong&gt;What about daemon threads?&lt;/strong&gt; More about that in the next
section ;-)&lt;/p&gt;
&lt;p&gt;Note: This change introduced a regression (memory leak) which is not fixed yet:
&lt;a class="reference external" href="https://bugs.python.org/issue37788"&gt;bpo-37788&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="forbid-daemon-threads-in-subinterpreters"&gt;
&lt;h2&gt;Forbid daemon threads in subinterpreters&lt;/h2&gt;
&lt;p&gt;In June 2019, while fixing the threading shutdown, I found a reliable way to
trigger a bug with daemon threads when a subinterpreter is finalized:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Fatal Python error: Py_EndInterpreter: not the last thread
&lt;/pre&gt;
&lt;p&gt;By design, daemon threads can run after a Python interpreter is finalized,
whereas &lt;tt class="docutils literal"&gt;Py_EndInterpreter()&lt;/tt&gt; requires that all threads completed.&lt;/p&gt;
&lt;p&gt;I reported &lt;a class="reference external" href="https://bugs.python.org/issue37266"&gt;bpo-37266&lt;/a&gt; to propose to
forbid the creation of daemon threads in subinterpreters. I fixed the issue
with &lt;a class="reference external" href="https://github.com/python/cpython/commit/066e5b1a917ec2134e8997d2cadd815724314252"&gt;commit 066e5b1a&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
bpo-37266: Daemon threads are now denied in subinterpreters (GH-14049)

In a subinterpreter, spawning a daemon thread now raises an
exception. Daemon threads were never supported in subinterpreters.
Previously, the subinterpreter finalization crashed with a Pyton
fatal error if a daemon thread was still running.
&lt;/pre&gt;
&lt;p&gt;The change adds this check to &lt;tt class="docutils literal"&gt;Thread.start()&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
if self.daemon and not _is_main_interpreter():
    raise RuntimeError(&amp;quot;daemon thread are not supported &amp;quot;
                       &amp;quot;in subinterpreters&amp;quot;)
&lt;/pre&gt;
&lt;p&gt;I commented:&lt;/p&gt;
&lt;blockquote&gt;
&lt;strong&gt;Daemon threads must die.&lt;/strong&gt; That's a first step towards their death!&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Antoine Pitrou&lt;/strong&gt; created &lt;a class="reference external" href="https://bugs.python.org/issue39812"&gt;bpo-39812: Avoid daemon threads in
concurrent.futures&lt;/a&gt; as a follow-up.&lt;/p&gt;
&lt;p&gt;In February 2020, when rebuilding Fedora Rawhide with Python 3.9, &lt;strong&gt;Miro
Hrončok&lt;/strong&gt; of my team noticed that my change &lt;a class="reference external" href="https://bugzilla.redhat.com/show_bug.cgi?id=1792062"&gt;broke the python-jep project&lt;/a&gt;. I &lt;a class="reference external" href="https://github.com/ninia/jep/issues/229"&gt;reported the bug
upstream&lt;/a&gt;. It has been fixed by
using regular threads, rather than daemon threads: &lt;a class="reference external" href="https://github.com/ninia/jep/commit/a31d461c6cacc96de68d68320eaa83e19a45d0cc"&gt;commit&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;A random failure on a FreeBSD buildbot was hiding a severe race condition in
the threading shutdown. The bug existed since 2013, but was silently ignored
since the test passed when re-run.&lt;/p&gt;
&lt;p&gt;The race condition was that that the threading shutdown didn't ensure that the
Python thread state of all non-daemon threads are deleted, whereas it is a
&lt;tt class="docutils literal"&gt;Py_EndInterpreter()&lt;/tt&gt; requirement.&lt;/p&gt;
&lt;p&gt;I fixed the threading shutdown by waiting until the Python thread state of all
non-daemon threads is deleted.&lt;/p&gt;
&lt;p&gt;I also modified &lt;tt class="docutils literal"&gt;Thread.start()&lt;/tt&gt; to forbid spawning daemon threads in Python
subinterpreters to fix a related issue.&lt;/p&gt;
&lt;/div&gt;
</content><category term="cpython"></category><category term="cpython"></category><category term="subinterpreters"></category></entry><entry><title>Daemon threads and the Python finalization in Python 3.2 and 3.3</title><link href="https://vstinner.github.io/daemon-threads-python-finalization-python32.html" rel="alternate"></link><published>2020-03-26T22:00:00+01:00</published><updated>2020-03-26T22:00:00+01:00</updated><author><name>Victor Stinner</name></author><id>tag:vstinner.github.io,2020-03-26:/daemon-threads-python-finalization-python32.html</id><summary type="html">&lt;a class="reference external image-reference" href="https://twitter.com/LuppiChan/status/1240346448606171136"&gt;&lt;img alt="#CoronaMaison by Luppi" src="https://vstinner.github.io/images/coronamaison_luppi.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;At exit, the Python finalization calls Python objects finalizers (the
&lt;tt class="docutils literal"&gt;__del__()&lt;/tt&gt; method) and deallocates memory.  The daemon threads are a special
kind of threads which continue to run during and after the Python finalization.
They are causing race conditions and tricky bugs in the Python finalization.&lt;/p&gt;
&lt;p&gt;This article covers bugs …&lt;/p&gt;</summary><content type="html">&lt;a class="reference external image-reference" href="https://twitter.com/LuppiChan/status/1240346448606171136"&gt;&lt;img alt="#CoronaMaison by Luppi" src="https://vstinner.github.io/images/coronamaison_luppi.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;At exit, the Python finalization calls Python objects finalizers (the
&lt;tt class="docutils literal"&gt;__del__()&lt;/tt&gt; method) and deallocates memory.  The daemon threads are a special
kind of threads which continue to run during and after the Python finalization.
They are causing race conditions and tricky bugs in the Python finalization.&lt;/p&gt;
&lt;p&gt;This article covers bugs fixed in the Python finalization in Python 3.2 and
Python 3.3 (2009 to 2011), and a backport in Python 2.7.8 (2014).&lt;/p&gt;
&lt;p&gt;Drawing: &lt;a class="reference external" href="https://twitter.com/LuppiChan/status/1240346448606171136"&gt;#CoronaMaison by Luppi&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="daemon-threads"&gt;
&lt;h2&gt;Daemon threads&lt;/h2&gt;
&lt;p&gt;Python has a special kind of thread: &amp;quot;daemon&amp;quot; threads. The difference with
regular threads is that Python doesn't wait until daemon threads complete at
exit, whereas it waits until all regular (&amp;quot;non-daemon&amp;quot;) threads complete.
Example:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
import threading, time
thread = threading.Thread(target=time.sleep, args=(5.0,), daemon=False)
thread.start()
&lt;/pre&gt;
&lt;p&gt;This Python program spawns a regular thread which sleeps for 5 seconds. Python
takes 5 seconds to exit:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ time python3 sleep.py

real   0m5,047s
&lt;/pre&gt;
&lt;p&gt;If &lt;tt class="docutils literal"&gt;daemon=False&lt;/tt&gt; is replaced with &lt;tt class="docutils literal"&gt;daemon=True&lt;/tt&gt; to spawn a daemon thread
instead, Python exits immediately (57 ms):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ time python3 sleep.py

real   0m0,057s
&lt;/pre&gt;
&lt;p&gt;Note: The &lt;tt class="docutils literal"&gt;Thread.join()&lt;/tt&gt; method can be called explicitly to wait until a
daemon thread completes.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="don-t-destroy-the-gil-at-exit"&gt;
&lt;h2&gt;Don't destroy the GIL at exit&lt;/h2&gt;
&lt;p&gt;In November 2009, &lt;strong&gt;Antoine Pitrou&lt;/strong&gt; implemented a new GIL (Global Interpreter
Lock) in Python 3.2: &lt;a class="reference external" href="https://github.com/python/cpython/commit/074e5ed974be65fbcfe75a4c0529dbc53f13446f"&gt;commit 074e5ed9&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In September 2010, he found a crash with daemon threads while stressing
&lt;tt class="docutils literal"&gt;test_threading&lt;/tt&gt;: &lt;a class="reference external" href="https://bugs.python.org/issue9901"&gt;bpo-9901: GIL destruction can fail&lt;/a&gt;. &lt;tt class="docutils literal"&gt;test_finalize_with_trace()&lt;/tt&gt; failed
with:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Fatal Python error: pthread_mutex_destroy(gil_mutex) failed
&lt;/pre&gt;
&lt;p&gt;He pushed a fix for this crash in Python 3.2, &lt;a class="reference external" href="https://github.com/python/cpython/commit/b0b384b7c0333bf1183cd6f90c0a3f9edaadd6b9"&gt;commit b0b384b7&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Issue #9901: Destroying the GIL in Py_Finalize() can fail if some other
threads are still running.  Instead, reinitialize the GIL on a second
call to Py_Initialize().
&lt;/pre&gt;
&lt;p&gt;The Python GIL internally uses a lock. If the lock is destroyed while a daemon
thread is waiting for it, the thread can crash. The fix is to &lt;strong&gt;no longer
destroy the GIL at exit&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="exit-the-thread-in-pyeval-restorethread"&gt;
&lt;h2&gt;Exit the thread in PyEval_RestoreThread()&lt;/h2&gt;
&lt;p&gt;The Python finalization clears and deallocates the &amp;quot;Python thread state&amp;quot; of all
threads (in &lt;tt class="docutils literal"&gt;PyInterpreterState_Delete()&lt;/tt&gt;) which calls Python object
finalizers of these threads. Calling a finalizer can drop the GIL to call a
system call. For example, closing a file drops the GIL. When the GIL is
dropped, a daemon thread is awaken to take the GIL. Since the Python thread
state was just deallocated, the daemon thread crash.&lt;/p&gt;
&lt;p&gt;This bug is a race condition. It depends on which order threads are executed,
on which order objects are finalized, on which order memory is deallocated,
etc.&lt;/p&gt;
&lt;p&gt;The crash was first reported in April 2005: &lt;a class="reference external" href="https://bugs.python.org/issue1193099"&gt;bpo-1193099: Embedded python thread
crashes&lt;/a&gt;. In January 2008, &lt;strong&gt;Gregory P.
Smith&lt;/strong&gt; reported &lt;a class="reference external" href="https://bugs.python.org/issue1856#msg60014"&gt;bpo-1856: shutdown (exit) can hang or segfault with daemon
threads running&lt;/a&gt;. He wrote a
short Python program reproducing the bug: spawn 40 daemon threads which do some
I/O operations and sleep randomly between 0 ms and 5 ms in a loop.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Adam Olsen&lt;/strong&gt; &lt;a class="reference external" href="https://bugs.python.org/issue1856#msg60059"&gt;proposed a solution&lt;/a&gt; (with a patch):&lt;/p&gt;
&lt;blockquote&gt;
I think &lt;strong&gt;non-main threads should kill themselves off&lt;/strong&gt; if they grab the
interpreter lock and the interpreter is tearing down. They're about to get
killed off anyway, when the process exits.&lt;/blockquote&gt;
&lt;p&gt;In May 2011, &lt;strong&gt;Antoine Pitrou&lt;/strong&gt; pushed a fix to Python 3.3 (6 years after the
first bug report) which implements this solution, &lt;a class="reference external" href="https://github.com/python/cpython/commit/0d5e52d3469a310001afe50689f77ddba6d554d1"&gt;commit 0d5e52d3&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Issue #1856: Avoid crashes and lockups when daemon threads run while the
interpreter is shutting down; instead, these threads are now killed when
they try to take the GIL.
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="pyeval-restorethread-fix-explanation"&gt;
&lt;h2&gt;PyEval_RestoreThread() fix explanation&lt;/h2&gt;
&lt;p&gt;The fix adds a new &lt;tt class="docutils literal"&gt;_Py_Finalizing&lt;/tt&gt; variable which is set by
&lt;tt class="docutils literal"&gt;Py_Finalize()&lt;/tt&gt; to the (Python thread state of the) thread which runs the
finalization.&lt;/p&gt;
&lt;p&gt;Simplified patch of the &lt;tt class="docutils literal"&gt;PyEval_RestoreThread()&lt;/tt&gt; fix:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;#64;&amp;#64; -440,6 +440,12 &amp;#64;&amp;#64; PyEval_RestoreThread()
         take_gil(tstate);
+        if (_Py_Finalizing &amp;amp;&amp;amp; tstate != _Py_Finalizing) {
+            drop_gil(tstate);
+            PyThread_exit_thread();
+        }
&lt;/pre&gt;
&lt;p&gt;If Python is finalizing (&lt;tt class="docutils literal"&gt;_Py_Finalizing&lt;/tt&gt; is not NULL) and
&lt;tt class="docutils literal"&gt;PyEval_RestoreThread()&lt;/tt&gt; is called by a thread which is not thread running
the finalization, the thread exits immediately (call
&lt;tt class="docutils literal"&gt;PyThread_exit_thread()&lt;/tt&gt;).&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;PyEval_RestoreThread()&lt;/tt&gt; is called when a thread takes the GIL.  Typical
example of code which drops the GIL to call a system call (close a file
descriptor, &lt;tt class="docutils literal"&gt;io.FileIO()&lt;/tt&gt; finalizer) and then takes again the GIL:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Py_BEGIN_ALLOW_THREADS
close(fd);
Py_END_ALLOW_THREADS
&lt;/pre&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;Py_BEGIN_ALLOW_THREADS&lt;/tt&gt; macro calls &lt;tt class="docutils literal"&gt;PyEval_SaveThread()&lt;/tt&gt; to drop the
GIL, and the &lt;tt class="docutils literal"&gt;Py_END_ALLOW_THREADS&lt;/tt&gt; macro calls &lt;tt class="docutils literal"&gt;PyEval_RestoreThread()&lt;/tt&gt; to
take the GIL.  Pseudo-code:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
PyEval_SaveThread();     // drop the GIL
close(fd);
PyEval_RestoreThread();  // take the GIL
&lt;/pre&gt;
&lt;p&gt;With Antoine's fix, if Python is finalizing, a thread now exits immediately
when calling &lt;tt class="docutils literal"&gt;PyEval_RestoreThread()&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="revert-take-gil-backport-to-2-7"&gt;
&lt;h2&gt;Revert take_gil() backport to 2.7&lt;/h2&gt;
&lt;p&gt;In June 2014, &lt;strong&gt;Benjamin Peterson&lt;/strong&gt; (Python 2.7 release manager) backported
Antoine's change to Python 2.7: fix included in 2.7.8.&lt;/p&gt;
&lt;p&gt;Problem: the Ceph project &lt;a class="reference external" href="https://tracker.ceph.com/issues/8797"&gt;started to crash with Python 2.7.8&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In November 2014, the change was reverted in Python 2.7.9: see
&lt;a class="reference external" href="https://bugs.python.org/issue21963"&gt;bpo-21963 discussion&lt;/a&gt; for the rationale.&lt;/p&gt;
&lt;p&gt;In 2014, I already wrote:&lt;/p&gt;
&lt;blockquote&gt;
Anyway, &lt;strong&gt;daemon threads are evil&lt;/strong&gt; :-( Expecting them to exit cleanly
automatically is not good. Last time I tried to improve code to cleanup
Python at exit in Python 3.4, I also had a regression (just before the
release of Python 3.4.0): see the &lt;a class="reference external" href="https://bugs.python.org/issue21788"&gt;issue #21788&lt;/a&gt;.&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Daemon threads caused crashes in the Python finalization, first noticed in
2005.&lt;/p&gt;
&lt;p&gt;Python 3.2 (released in February 2011) got a new GIL and also a bugfix for
daemon thread. Python 3.3 (released in September 2012) also got a bugfix for
daemon threads. The Python finalization became more reliable.&lt;/p&gt;
&lt;p&gt;Changing Python finalization is risky. A backport of a bugfix into Python 2.7.8
caused a regression which required to revert the bugfix in Python 2.7.9.&lt;/p&gt;
&lt;/div&gt;
</content><category term="cpython"></category><category term="cpython"></category><category term="subinterpreters"></category></entry><entry><title>asyncio WSASend() memory leak</title><link href="https://vstinner.github.io/asyncio-proactor-wsasend-memory-leak.html" rel="alternate"></link><published>2019-03-06T20:00:00+01:00</published><updated>2019-03-06T20:00:00+01:00</updated><author><name>Victor Stinner</name></author><id>tag:vstinner.github.io,2019-03-06:/asyncio-proactor-wsasend-memory-leak.html</id><summary type="html">&lt;p&gt;I fixed multiple bugs in asyncio &lt;tt class="docutils literal"&gt;ProactorEventLoop&lt;/tt&gt; previously. But test_asyncio
still failed sometimes. I noticed a memory leak in &lt;tt class="docutils literal"&gt;test_asyncio&lt;/tt&gt; which will
haunt me for 1 year in 2018...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Yet another example of a test failure which looks harmless but hides a
critical bug.&lt;/strong&gt; The bug is that sending a …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I fixed multiple bugs in asyncio &lt;tt class="docutils literal"&gt;ProactorEventLoop&lt;/tt&gt; previously. But test_asyncio
still failed sometimes. I noticed a memory leak in &lt;tt class="docutils literal"&gt;test_asyncio&lt;/tt&gt; which will
haunt me for 1 year in 2018...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Yet another example of a test failure which looks harmless but hides a
critical bug.&lt;/strong&gt; The bug is that sending a network packet on Windows using
asyncio &lt;tt class="docutils literal"&gt;ProactorEventLoop&lt;/tt&gt; can leak the packet. With such bug, it is easy to
imagine a very quick increase of the memory footprint of a network server...&lt;/p&gt;
&lt;p&gt;I'm curious why nobody noticed it before me? For me, the only explanation is
that nobody was running a server using &lt;tt class="docutils literal"&gt;ProactorEventLoop&lt;/tt&gt;. Before Python
3.8, &lt;tt class="docutils literal"&gt;SelectorEventLoop&lt;/tt&gt; was the default asyncio event loop on Windows.
&lt;a class="reference external" href="https://bugs.python.org/issue34687"&gt;bpo-34687&lt;/a&gt;: Andrew Svetlov, Yury
Selivanov and me agreed to make &lt;tt class="docutils literal"&gt;ProactorEventLoop&lt;/tt&gt; the default in Python
3.8! &lt;tt class="docutils literal"&gt;Lib/asyncio/windows_events.py&lt;/tt&gt; change of my &lt;a class="reference external" href="https://github.com/python/cpython/commit/6ea29c5e90dde6c240bd8e0815614b52ac307ea1"&gt;commit 6ea29c5e&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
-DefaultEventLoopPolicy = WindowsSelectorEventLoopPolicy
+DefaultEventLoopPolicy = WindowsProactorEventLoopPolicy
&lt;/pre&gt;
&lt;p&gt;The bug wasn't a regression. It was only discovered 5 years after the code has
been written thanks to new tests.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UPDATE:&lt;/strong&gt; I updated the article to add the &amp;quot;Regression? Nope&amp;quot; section and
elaborate the Conclusion.&lt;/p&gt;
&lt;p&gt;Previous article:
&lt;a class="reference external" href="https://vstinner.github.io/asyncio-proactor-wsarecv-cancellation-data-loss.html"&gt;asyncio: WSARecv() cancellation causing data loss&lt;/a&gt;.&lt;/p&gt;
&lt;a class="reference external image-reference" href="https://www.flickr.com/photos/jronaldlee/5996590138/"&gt;&lt;img alt="Leaking tap" src="https://vstinner.github.io/images/leaking_tap.jpg" /&gt;&lt;/a&gt;
&lt;div class="section" id="yet-another-random-buildbot-failure"&gt;
&lt;h2&gt;Yet another random buildbot failure&lt;/h2&gt;
&lt;p&gt;One day at the end of January 2018, I noticed a new failure on the AMD64
Windows8.1 Refleaks 3.x&amp;quot; buildbot worker. I reported &lt;a class="reference external" href="https://bugs.python.org/issue32710"&gt;bpo-32710&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;AMD64 Windows8.1 Refleaks 3.x:
&lt;a class="reference external" href="http://buildbot.python.org/all/#/builders/80/builds/118"&gt;http://buildbot.python.org/all/#/builders/80/builds/118&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;test_asyncio leaked [4, 4, 3] memory blocks, sum=11&lt;/p&gt;
&lt;p&gt;I reproduced the issue. I'm running test.bisect to try to isolate this bug.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Only 15 minutes later thanks to my &lt;tt class="docutils literal"&gt;test.bisect&lt;/tt&gt; tool, I identified the
leaking test, &lt;strong&gt;test_sendfile_close_peer_in_middle_of_receiving()&lt;/strong&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
It seems to be related to sendfile():

C:\vstinner\python\master&amp;gt;python -m test -R 3:3 test_asyncio \
    -m test.test_asyncio.test_events.ProactorEventLoopTests.test_sendfile_close_peer_in_middle_of_receiving
...
test_asyncio leaked [1, 2, 1] memory blocks, sum=4
&lt;/pre&gt;
&lt;p&gt;The test is identified, so it should take a few hours, maximum, to fix the bug,
no? We will see...&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="april"&gt;
&lt;h2&gt;April&lt;/h2&gt;
&lt;p&gt;3 months later, I asked:&lt;/p&gt;
&lt;blockquote&gt;
The test is still leaking memory blocks. Any progress on investigating the
issue?&lt;/blockquote&gt;
&lt;p&gt;Nobody replied.&lt;/p&gt;
&lt;p&gt;At that time, I was busy to fix a bunch of various other bugs reported by
buildbots which were easier to fix and I was kind of exhausted by asyncio, I
didn't want to touch it.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="june"&gt;
&lt;h2&gt;June&lt;/h2&gt;
&lt;p&gt;Oh, I found again this bug while working on my &lt;a class="reference external" href="https://github.com/python/cpython/pull/7827"&gt;PR 7827&lt;/a&gt; (detect handle leaks on Windows
in regrtest).&lt;/p&gt;
&lt;p&gt;In 2018, I was very busy with fixing dozens of multiprocessing bugs (fix tests
but also fix some bugs in multiprocessing).&lt;/p&gt;
&lt;p&gt;For example, I noticed another memory leak on AMD64 Windows8.1 Refleaks
3.7, &lt;a class="reference external" href="https://bugs.python.org/issue33735#msg318425"&gt;bpo-33735&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class="reference external" href="http://buildbot.python.org/all/#/builders/132/builds/154"&gt;http://buildbot.python.org/all/#/builders/132/builds/154&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;test_multiprocessing_spawn leaked [1, 2, 1] memory blocks, sum=4&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This test_multiprocessing_spawn leak and the test_asyncio leak on Windows
Refleaks haunted me in 2018...&lt;/p&gt;
&lt;p&gt;In fact, it wasn't a real leak. After a few runs, &lt;a class="reference external" href="https://bugs.python.org/issue33735#msg320948"&gt;the test stopped to leak&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ./python -m test test_multiprocessing_spawn \
    -m test.test_multiprocessing_spawn.WithProcessesTestPool.test_imap_unordered \
    -R 1:30
...
test_multiprocessing_spawn leaked [4, 5, 1, 5, 1, 2, 0, 0, 0, ..., 0, 0, 0] memory blocks, sum=18
test_multiprocessing_spawn failed in 42 sec 470 ms
&lt;/pre&gt;
&lt;p&gt;I fixed the test with &lt;a class="reference external" href="https://github.com/python/cpython/commit/23401fb960bb94e6ea62d2999527968d53d3fc65"&gt;commit
23401fb9&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I fixed other multiprocessing bugs like &lt;a class="reference external" href="https://bugs.python.org/issue33929"&gt;bpo-33929&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;These multiprocessing bugs kept me busy.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="july-december"&gt;
&lt;h2&gt;July-December&lt;/h2&gt;
&lt;p&gt;Nothing. Nobody looked at the issue.&lt;/p&gt;
&lt;p&gt;Again, I was busy fixing various test failures reported by buildbots.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="update-in-january-2019"&gt;
&lt;h2&gt;Update in January 2019&lt;/h2&gt;
&lt;p&gt;In January 2019, after months of hard work on fixing every single buildbot
failure, I realized &lt;strong&gt;suddenly&lt;/strong&gt; that the &lt;tt class="docutils literal"&gt;test_asyncio&lt;/tt&gt; leak, &lt;a class="reference external" href="https://bugs.python.org/issue32710"&gt;bpo-32710&lt;/a&gt;, was one of the last unfixed known test
failure! So I decided to have a new look at it.&lt;/p&gt;
&lt;p&gt;Update on &lt;tt class="docutils literal"&gt;test_asyncio.test_sendfile.ProactorEventLoopTests&lt;/tt&gt;:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;test_sendfile_close_peer_in_the_middle_of_receiving()&lt;/tt&gt; leaks 1 reference per
run: this leak was the obvious bug &lt;a class="reference external" href="https://bugs.python.org/issue35682"&gt;bpo-35682&lt;/a&gt;, I already fixed it with &lt;a class="reference external" href="https://github.com/python/cpython/commit/80fda712c83f5dd9560d42bf2aa65a72b18b7759"&gt;commit
80fda712&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;test_sendfile_fallback_close_peer_in_the_middle_of_receiving()&lt;/tt&gt; leaks 1
reference per run: &lt;strong&gt;I don't understand why&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note: I had to copy/paste these test names a lot of times. Pleeease, for my
comfort, use shorter test names! :-) (I had to copy/paste them, I don't think
that a regular human is able to type these very long names!)&lt;/p&gt;
&lt;p&gt;I spent a lot of time to investigate
&lt;tt class="docutils literal"&gt;test_sendfile_fallback_close_peer_in_the_middle_of_receiving()&lt;/tt&gt; leak and I don't
understand the issue.&lt;/p&gt;
&lt;p&gt;The main loop is &lt;tt class="docutils literal"&gt;BaseEventLoop._sendfile_fallback()&lt;/tt&gt;. For
the specific case of this test, the loop can be simplified to:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
proto = _SendfileFallbackProtocol(transp)
try:
    while True:
        data = b'x' * (1024 * 64)
        await proto.drain()
        transp.write(data)
finally:
    await proto.restore()
&lt;/pre&gt;
&lt;p&gt;The server closes the connection after it gets 1024 bytes. The client socket
gets a &lt;tt class="docutils literal"&gt;ConnectionAbortedError&lt;/tt&gt; exception in
&lt;tt class="docutils literal"&gt;_ProactorBaseWritePipeTransport._loop_writing()&lt;/tt&gt; which calls &lt;tt class="docutils literal"&gt;_fatal_error()&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
except OSError as exc:
    self._fatal_error(exc, 'Fatal write error on pipe transport')
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;_fatal_error()&lt;/tt&gt; calls &lt;tt class="docutils literal"&gt;_force_close()&lt;/tt&gt; which sets &lt;tt class="docutils literal"&gt;_closing&lt;/tt&gt; to
&lt;tt class="docutils literal"&gt;True&lt;/tt&gt;, and calls &lt;tt class="docutils literal"&gt;protocol.connection_lost()&lt;/tt&gt;. In the meanwhile,
&lt;tt class="docutils literal"&gt;drain()&lt;/tt&gt; raises &lt;tt class="docutils literal"&gt;ConnectionError&lt;/tt&gt; because &lt;tt class="docutils literal"&gt;is_closing()&lt;/tt&gt; is true:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
async def drain(self):
    if self._transport.is_closing():
        raise ConnectionError(&amp;quot;Connection closed by peer&amp;quot;)
    ...
&lt;/pre&gt;
&lt;p&gt;Said differently: &lt;strong&gt;everything works as expected&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="regression-caused-by-my-previous-proactor-fix"&gt;
&lt;h2&gt;Regression caused by my previous proactor fix?&lt;/h2&gt;
&lt;p&gt;I suspected my own &lt;a class="reference external" href="https://github.com/python/cpython/commit/79790bc35fe722a49977b52647f9b5fe1deda2b7"&gt;commit 79790bc3&lt;/a&gt;
pushed 7 months ago to fix a race condition in WSARecv() causing data loss
(that's my previous article: &lt;a class="reference external" href="https://vstinner.github.io/asyncio-proactor-wsarecv-cancellation-data-loss.html"&gt;asyncio: WSARecv() cancellation causing data loss&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Hint: nah, it's unrelated. Moreover, this change has been pushed in May,
whereas I reported &lt;a class="reference external" href="https://bugs.python.org/issue32710"&gt;bpo-32710 leak&lt;/a&gt; in
January.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="short-script-reproducing-the-leak"&gt;
&lt;h2&gt;Short script reproducing the leak&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Identifying a leak of a single reference is really hard&lt;/strong&gt; since the test uses
hundreds of Python objects! My blocker issue was to repeat the test enough
times to trigger the leak N times rather than getting a leak of exactly a
single Python reference. The problem was that the test failed when ran more
than once.&lt;/p&gt;
&lt;p&gt;All my previous attempts to identify the bug failed:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Use &lt;tt class="docutils literal"&gt;gc.get_referrers()&lt;/tt&gt; to track references between Python objects.&lt;/li&gt;
&lt;li&gt;Use &lt;tt class="docutils literal"&gt;tracemalloc&lt;/tt&gt; to track memory usage: the leak is too small, it's lost
in the results &amp;quot;noise&amp;quot;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I decided to do what I should have done first: &lt;strong&gt;remove as much code as
possible&lt;/strong&gt; to reduce the code that I have to audit. I removed most Python
imports, I inlined manually function calls, I removed a lot of code which was
unused in the test, etc.&lt;/p&gt;
&lt;p&gt;After a few hours, I managed to reduce the giant pile of code used by the test
into a very short script of only 159 lines of Python code: &lt;a class="reference external" href="https://bugs.python.org/file48030/test_aiosend.py"&gt;test_aiosend.py&lt;/a&gt;. The script doesn't call
the asyncio &lt;tt class="docutils literal"&gt;sendfile()&lt;/tt&gt; implementation, but uses its own copy of the code,
simplified to do exactly what the test needs:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
async def sendfile(transp):
    proto = _SendfileFallbackProtocol(transp)
    try:
        data = b'x' * (1024 * 24)
        while True:
            await proto.drain()
            transp.write(data)
    finally:
        await proto.restore()
&lt;/pre&gt;
&lt;p&gt;with a local copy of the code of &lt;tt class="docutils literal"&gt;_SendfileFallbackProtocol&lt;/tt&gt; class.&lt;/p&gt;
&lt;p&gt;Having all code involved in the bug in a single file is way more efficient to
follow the control flow and understands what happens.&lt;/p&gt;
&lt;p&gt;The original code is waaaaay more complex, scattered across multiple Python
files in &lt;tt class="docutils literal"&gt;Lib/asyncio&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;Lib/test/test_asyncio/&lt;/tt&gt; directories.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="root-bug-identified-wsasend"&gt;
&lt;h2&gt;Root bug identified: WSASend()&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;It took me 1 year, a few sleepless nights, multiple attempts to understand
the leak, but I eventually found it!&lt;/strong&gt; WSASend() doesn't release the memory if
it fails immediately. I expected something way more complex, but it's that
simple...&lt;/p&gt;
&lt;p&gt;Using the &lt;tt class="docutils literal"&gt;test_aiosend.py&lt;/tt&gt; script that I created, I was finally able to
repeat the test in a loop. Thanks to that, it became obvious using
&lt;tt class="docutils literal"&gt;tracemalloc&lt;/tt&gt; that the leaked memory was the memory passed to &lt;tt class="docutils literal"&gt;WSASend()&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;I pushed &lt;a class="reference external" href="https://github.com/python/cpython/commit/a234e148394c2c7419372ab65b773d53a57f3625"&gt;commit a234e148&lt;/a&gt;
to fix &lt;tt class="docutils literal"&gt;WSASend()&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit a234e148394c2c7419372ab65b773d53a57f3625
Author: Victor Stinner &amp;lt;vstinner&amp;#64;redhat.com&amp;gt;
Date:   Tue Jan 8 14:23:09 2019 +0100

    bpo-32710: Fix leak in Overlapped_WSASend() (GH-11469)

    Fix a memory leak in asyncio in the ProactorEventLoop when ReadFile()
    or WSASend() overlapped operation fail immediately: release the
    internal buffer.
&lt;/pre&gt;
&lt;p&gt;I was very disappointed by the simplicity of the fix, &lt;strong&gt;it only adds a single
line&lt;/strong&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
diff --git a/Modules/overlapped.c b/Modules/overlapped.c
index 69875a7f37da..bbaa4fb3008f 100644
--- a/Modules/overlapped.c
+++ b/Modules/overlapped.c
&amp;#64;&amp;#64; -1011,6 +1012,7 &amp;#64;&amp;#64; Overlapped_WSASend(OverlappedObject *self, PyObject *args)
         case ERROR_IO_PENDING:
             Py_RETURN_NONE;
         default:
+            PyBuffer_Release(&amp;amp;self-&amp;gt;user_buffer);
             self-&amp;gt;type = TYPE_NOT_STARTED;
             return SetFromWindowsErr(err);
     }
&lt;/pre&gt;
&lt;p&gt;So what? One year to add a single line? That's unfair!&lt;/p&gt;
&lt;p&gt;My commit contains a very similar fix for &lt;tt class="docutils literal"&gt;do_ReadFile()&lt;/tt&gt; used by
&lt;tt class="docutils literal"&gt;Overlapped_ReadFile()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;Overlapped_ReadFileInto()&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="fixing-more-memory-leaks"&gt;
&lt;h2&gt;Fixing more memory leaks&lt;/h2&gt;
&lt;p&gt;By the way, the &lt;tt class="docutils literal"&gt;_overlapped.Overlapped&lt;/tt&gt; type has no traverse function: it may
help the garbage collector to add one. Asyncio is famous for building reference
cycles by design in &lt;tt class="docutils literal"&gt;Future.set_exception()&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;I wrote &lt;a class="reference external" href="https://github.com/python/cpython/pull/11489"&gt;PR 11489&lt;/a&gt; to implement
&lt;tt class="docutils literal"&gt;tp_traverse&lt;/tt&gt; for the &lt;tt class="docutils literal"&gt;_overlapped.Overlapped&lt;/tt&gt; type. &lt;a class="reference external" href="https://github.com/python/cpython/pull/11489#pullrequestreview-191093765"&gt;Serhiy Storchaka
added&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
I suspect that there are leaks when self-&amp;gt;type is set to TYPE_NOT_STARTED.&lt;/blockquote&gt;
&lt;p&gt;And he was right! I modified my PR to fix all memory leaks. After my PR has
been reviewed, I merged it, &lt;a class="reference external" href="https://github.com/python/cpython/commit/5485085b324a45307c1ff4ec7d85b5998d7d5e0d"&gt;commit 5485085b&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 5485085b324a45307c1ff4ec7d85b5998d7d5e0d
Author: Victor Stinner &amp;lt;vstinner&amp;#64;redhat.com&amp;gt;
Date:   Fri Jan 11 14:35:14 2019 +0100

    bpo-32710: Fix _overlapped.Overlapped memory leaks (GH-11489)

    Fix memory leaks in asyncio ProactorEventLoop on overlapped operation
    failures.

    Changes:

    * Implement the tp_traverse slot in the _overlapped.Overlapped type
      to help to break reference cycles and identify referrers in the
      garbage collector.
    * Always clear overlapped on failure: not only set type to
      TYPE_NOT_STARTED, but release also resources.
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="regression-nope"&gt;
&lt;h2&gt;Regression? Nope&lt;/h2&gt;
&lt;p&gt;Was the memory leak a regression? Nope. The bug existed since the creation of
the &lt;tt class="docutils literal"&gt;overlapped.c&lt;/tt&gt; file in the &amp;quot;Tulip&amp;quot; project in 2013, &lt;a class="reference external" href="https://github.com/python/asyncio/commit/27c403531670f52cad8388aaa2a13a658f753fd5"&gt;commit 27c40353&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 27c403531670f52cad8388aaa2a13a658f753fd5
Author: Richard Oudkerk &amp;lt;shibturn&amp;#64;gmail.com&amp;gt;
Date:   Mon Jan 21 20:34:38 2013 +0000

    New experimental iocp branch.
&lt;/pre&gt;
&lt;p&gt;Tulip was the old name of the asyncio project, when it was still an external
project on &lt;tt class="docutils literal"&gt;code.google.com&lt;/tt&gt;. In the meanwhile, &lt;tt class="docutils literal"&gt;code.google.com&lt;/tt&gt; has been
closed and the project moved to &lt;a class="reference external" href="https://github.com/python/asyncio/"&gt;https://github.com/python/asyncio/&lt;/a&gt; (now
read-only).&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/python/asyncio/blob/27c403531670f52cad8388aaa2a13a658f753fd5/overlapped.c#L632-L658"&gt;Extract of the original Overlapped_WSASend() implementation&lt;/a&gt;,
I added a comment to show the location of the bug:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
if (!PyArg_Parse(bufobj, &amp;quot;y*&amp;quot;, &amp;amp;self-&amp;gt;write_buffer))
    return NULL;

#if SIZEOF_SIZE_T &amp;gt; SIZEOF_LONG
if (self-&amp;gt;write_buffer.len &amp;gt; (Py_ssize_t)PY_ULONG_MAX) {
    PyBuffer_Release(&amp;amp;self-&amp;gt;write_buffer);
    PyErr_SetString(PyExc_ValueError, &amp;quot;buffer to large&amp;quot;);
    return NULL;
}
#endif
...
self-&amp;gt;error = err = (ret &amp;lt; 0 ? WSAGetLastError() : ERROR_SUCCESS);
switch (err) {
    case ERROR_SUCCESS:
    case ERROR_MORE_DATA:
    case ERROR_IO_PENDING:
        /********* !!! BUG HERE, BUFFER NOT RELEASED !!! ***********/
        Py_RETURN_NONE;
    ...
}
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;I fixed the memory leak 6 years after the code has been written!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;So... why was this bug only discovered in 2018? Multiple very asyncio old bugs
were discovered only recently thanks to more realistic and more advanced
&lt;strong&gt;functional tests&lt;/strong&gt;. First tests of asyncio were mostly tiny unit tests
mocking most part of the code. It made sense in the early days of asyncio, when
the code was not mature.&lt;/p&gt;
&lt;p&gt;By the way, the &lt;a class="reference external" href="https://github.com/python/cpython/blob/1f58f4fa6a0e3c60cee8df4a35c8dcf3903acde8/Lib/test/test_asyncio/test_sendfile.py#L446-L457"&gt;code of the test&lt;/a&gt;
which helped to discovered the bug is:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
def test_sendfile_close_peer_in_the_middle_of_receiving(self):
    srv_proto, cli_proto = self.prepare_sendfile(close_after=1024)
    with self.assertRaises(ConnectionError):
        self.run_loop(
            self.loop.sendfile(cli_proto.transport, self.file))
    self.run_loop(srv_proto.done)

    self.assertTrue(1024 &amp;lt;= srv_proto.nbytes &amp;lt; len(self.DATA),
                    srv_proto.nbytes)
    self.assertTrue(1024 &amp;lt;= self.file.tell() &amp;lt; len(self.DATA),
                    self.file.tell())
    self.assertTrue(cli_proto.transport.is_closing())
&lt;/pre&gt;
&lt;p&gt;Note: The test name has been made even longer in the meanwhile (add &amp;quot;the&amp;quot;) :-)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;For such complex bugs, &lt;strong&gt;a reliable debugging method is to remove as much code as
possible&lt;/strong&gt; to reduce the number of lines of code that should be read.
&lt;tt class="docutils literal"&gt;tracemalloc&lt;/tt&gt; remains efficient to identify a memory leak when a test can be
run in a loop to make the leak more obvious (I was blocked at the beginning
because the test failed when run a second time in a loop).&lt;/p&gt;
&lt;p&gt;Lessons learned? You should try to &lt;strong&gt;investigate every single failure of your
CI&lt;/strong&gt;.  It is important to have a test suite with functional tests. &amp;quot;Mock tests&amp;quot;
are fine to quickly write reliable tests, but there are not enough: functional
tests make the difference.&lt;/p&gt;
&lt;p&gt;Thanks &lt;strong&gt;Richard Oudkerk&lt;/strong&gt; for your great code to use Windows native APIs in
&lt;strong&gt;asyncio&lt;/strong&gt; and &lt;strong&gt;multiprocessing&lt;/strong&gt;! I like &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Input/output_completion_port"&gt;Windows IOCP&lt;/a&gt;, even if the
asyncio implementation is quite complex :-)&lt;/p&gt;
&lt;p&gt;Ok, &lt;tt class="docutils literal"&gt;_overlapped.Overlapped&lt;/tt&gt; should now have a few less memory leaks :-)&lt;/p&gt;
&lt;/div&gt;
</content><category term="cpython"></category><category term="asyncio"></category></entry><entry><title>asyncio: WSARecv() cancellation causing data loss</title><link href="https://vstinner.github.io/asyncio-proactor-wsarecv-cancellation-data-loss.html" rel="alternate"></link><published>2019-01-31T15:20:00+01:00</published><updated>2019-01-31T15:20:00+01:00</updated><author><name>Victor Stinner</name></author><id>tag:vstinner.github.io,2019-01-31:/asyncio-proactor-wsarecv-cancellation-data-loss.html</id><summary type="html">&lt;p&gt;In December 2017, &lt;strong&gt;Yury Selivanov&lt;/strong&gt; pushed the long awaited &lt;tt class="docutils literal"&gt;start_tls()&lt;/tt&gt;
function.&lt;/p&gt;
&lt;p&gt;A newly added test failed on Windows. Later, the test started to fail
randomly on Linux as well. In fact, it was a well hidden race condition in the
asynchronous handshake of &lt;tt class="docutils literal"&gt;SSLProtocol&lt;/tt&gt; which will take 5 months of …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In December 2017, &lt;strong&gt;Yury Selivanov&lt;/strong&gt; pushed the long awaited &lt;tt class="docutils literal"&gt;start_tls()&lt;/tt&gt;
function.&lt;/p&gt;
&lt;p&gt;A newly added test failed on Windows. Later, the test started to fail
randomly on Linux as well. In fact, it was a well hidden race condition in the
asynchronous handshake of &lt;tt class="docutils literal"&gt;SSLProtocol&lt;/tt&gt; which will take 5 months of work to
be identified and fixed. The bug wasn't a recent regression, but only spotted
thanks to newly added tests.&lt;/p&gt;
&lt;p&gt;Even after this bug has been fixed, the same test still failed randomly on
Windows! Once I found how to reproduce the bug, I understood that it's a &lt;strong&gt;very
scary bug&lt;/strong&gt;: &lt;tt class="docutils literal"&gt;WSARecv()&lt;/tt&gt; cancellation randomly caused &lt;strong&gt;data loss&lt;/strong&gt;! Again,
it was a very well hidden bug which likely existing since the early days of the
&lt;tt class="docutils literal"&gt;ProactorEventLoop&lt;/tt&gt; implementation.&lt;/p&gt;
&lt;p&gt;Previous article: &lt;a class="reference external" href="https://vstinner.github.io/asyncio-proactor-connect-pipe-race-condition.html"&gt;Asyncio: Proactor ConnectPipe() Race Condition&lt;/a&gt;.
Next article: &lt;a class="reference external" href="https://vstinner.github.io/asyncio-proactor-wsasend-memory-leak.html"&gt;asyncio: WSASend() memory leak&lt;/a&gt;.&lt;/p&gt;
&lt;a class="reference external image-reference" href="https://www.flickr.com/photos/joybot/6026542856/"&gt;&lt;img alt="Unlocked lock" src="https://vstinner.github.io/images/lock.jpg" /&gt;&lt;/a&gt;
&lt;div class="section" id="new-start-tls-function"&gt;
&lt;h2&gt;New start_tls() function&lt;/h2&gt;
&lt;p&gt;The &amp;quot;starttls&amp;quot; feature have been requested since creation of asyncio. At
October 24, 2013, &lt;strong&gt;Guido van Rossum&lt;/strong&gt; created &lt;a class="reference external" href="https://github.com/python/asyncio/issues/79"&gt;asyncio issue #79&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;strong&gt;Glyph [Lefkowitz]&lt;/strong&gt; and &lt;strong&gt;Antoine [Pitrou]&lt;/strong&gt; really want a API to upgrade an
existing Transport/Protocol pair to SSL/TLS, without having to create a new
protocol.&lt;/blockquote&gt;
&lt;p&gt;At March 23, 2015, &lt;strong&gt;Giovanni Cannata&lt;/strong&gt; created &lt;a class="reference external" href="https://bugs.python.org/issue23749"&gt;bpo-23749&lt;/a&gt; which is basically the same feature
request. I &lt;a class="reference external" href="https://bugs.python.org/issue23749#msg239022"&gt;replied&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
asyncio got a new SSL implementation which makes possible to implement
STARTTLS. Are you interested to implement it?&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Elizabeth Myers&lt;/strong&gt;, &lt;strong&gt;Antoine Pitrou&lt;/strong&gt;, &lt;strong&gt;Guido van Rossum&lt;/strong&gt; and
&lt;strong&gt;Yury Selivanov&lt;/strong&gt; designed the feature. Yury &lt;a class="reference external" href="https://bugs.python.org/issue23749#msg253495"&gt;wrote a prototype&lt;/a&gt; in 2015 for PostgreSQL.  In
2017, &lt;strong&gt;Barry Warsaw&lt;/strong&gt; &lt;a class="reference external" href="https://bugs.python.org/issue23749#msg293912"&gt;wrote his own implementation for SMTP&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;At the end of 2017, &lt;strong&gt;four year&lt;/strong&gt; after Guido van Rossum created the feature
request, &lt;strong&gt;Yury Selivanov&lt;/strong&gt; implemented the feature and pushed the &lt;a class="reference external" href="https://github.com/python/cpython/commit/f111b3dcb414093a4efb9d74b69925e535ddc470"&gt;commit
f111b3dc&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit f111b3dcb414093a4efb9d74b69925e535ddc470
Author: Yury Selivanov &amp;lt;yury&amp;#64;magic.io&amp;gt;
Date:   Sat Dec 30 00:35:36 2017 -0500

    bpo-23749: Implement loop.start_tls() (#5039)
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="sslprotocol-race-condition"&gt;
&lt;h2&gt;SSLProtocol Race Condition&lt;/h2&gt;
&lt;div class="section" id="test-fails-on-appveyor-windows-temporary-fix"&gt;
&lt;h3&gt;Test fails on AppVeyor (Windows): temporary fix&lt;/h3&gt;
&lt;p&gt;At December 30, 2017, just after Yury pushed his implementation of
&lt;tt class="docutils literal"&gt;start_tls()&lt;/tt&gt; (the same day), &lt;strong&gt;Antoine Pitrou&lt;/strong&gt; reported &lt;a class="reference external" href="https://bugs.python.org/issue32458"&gt;bpo-32458&lt;/a&gt;: it seems test_asyncio fails
sporadically on AppVeyor:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ERROR: test_start_tls_server_1 (test.test_asyncio.test_sslproto.ProactorStartTLS)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &amp;quot;C:\projects\cpython\lib\test\test_asyncio\test_sslproto.py&amp;quot;, line 284, in test_start_tls_server_1
    asyncio.wait_for(main(), loop=self.loop, timeout=10))
  File &amp;quot;C:\projects\cpython\lib\asyncio\base_events.py&amp;quot;, line 440, in run_until_complete
    return future.result()
  File &amp;quot;C:\projects\cpython\lib\asyncio\tasks.py&amp;quot;, line 398, in wait_for
    raise futures.TimeoutError()
concurrent.futures._base.TimeoutError
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Yury Selivanov&lt;/strong&gt; &lt;a class="reference external" href="https://bugs.python.org/issue32458#msg309254"&gt;wrote&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
I'm leaving on a two-weeks vacation today.  To avoid risking breaking the workflow, I'll mask this tests on AppVeyor.  I'll investigate this when I get back.&lt;/blockquote&gt;
&lt;p&gt;and skipped the test as a &lt;strong&gt;temporary fix&lt;/strong&gt;, &lt;a class="reference external" href="https://github.com/python/cpython/commit/0c36bed1c46d07ef91d3e02e69e974e4f3ecd31a"&gt;commit 0c36bed1&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 0c36bed1c46d07ef91d3e02e69e974e4f3ecd31a
Author: Yury Selivanov &amp;lt;yury&amp;#64;magic.io&amp;gt;
Date:   Sat Dec 30 15:40:20 2017 -0500

    bpo-32458: Temporarily mask start-tls proactor test on Windows (#5054)
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="bug-reproduced-on-linux"&gt;
&lt;h3&gt;Bug reproduced on Linux&lt;/h3&gt;
&lt;p&gt;At May 23, 2018, five month after the bug have been reported, &lt;a class="reference external" href="https://bugs.python.org/issue32458#msg317468"&gt;I wrote&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
test_start_tls_server_1() just failed on my Linux. It likely depends on the system load.&lt;/blockquote&gt;
&lt;p&gt;Christian Heimes &lt;a class="reference external" href="https://bugs.python.org/issue32458#msg317760"&gt;added&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
[On Linux,] It's failing reproducible with OpenSSL 1.1.1 and TLS 1.3
enabled. I haven't seen it failing with TLS 1.2 yet.&lt;/blockquote&gt;
&lt;p&gt;At May 28, 2018, I found a reliable way to &lt;a class="reference external" href="https://bugs.python.org/issue32458#msg317833"&gt;reproduce the issue on Linux&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Open 3 terminals and run these commands in parallel:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;./python &lt;span class="pre"&gt;-m&lt;/span&gt; test test_asyncio &lt;span class="pre"&gt;-m&lt;/span&gt; test_start_tls_server_1 &lt;span class="pre"&gt;-F&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;./python &lt;span class="pre"&gt;-m&lt;/span&gt; test &lt;span class="pre"&gt;-j16&lt;/span&gt; &lt;span class="pre"&gt;-r&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;./python &lt;span class="pre"&gt;-m&lt;/span&gt; test &lt;span class="pre"&gt;-j16&lt;/span&gt; &lt;span class="pre"&gt;-r&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;It's a &lt;strong&gt;race condition&lt;/strong&gt; which doesn't depend on the OS, but on the system
load.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="root-issue-identified"&gt;
&lt;h3&gt;Root issue identified&lt;/h3&gt;
&lt;p&gt;Once I found how to reproduce the bug, I was able to investigate it. I created
&lt;a class="reference external" href="https://bugs.python.org/issue33674"&gt;bpo-33674&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I found a race condition in &lt;tt class="docutils literal"&gt;SSLProtocol&lt;/tt&gt; of &lt;tt class="docutils literal"&gt;asyncio/sslproto.py&lt;/tt&gt;.
Sometimes, &lt;tt class="docutils literal"&gt;_sslpipe.feed_ssldata()&lt;/tt&gt; is called before
&lt;tt class="docutils literal"&gt;_sslpipe.shutdown()&lt;/tt&gt;.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;SSLProtocol.connection_made()&lt;/tt&gt; -&amp;gt; &lt;tt class="docutils literal"&gt;SSLProtocol._start_handshake()&lt;/tt&gt;: &lt;tt class="docutils literal"&gt;self._loop.call_soon(self._process_write_backlog)&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;SSLProtoco.data_received()&lt;/tt&gt;: direct call to &lt;tt class="docutils literal"&gt;self._sslpipe.feed_ssldata(data)&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;Later, &lt;tt class="docutils literal"&gt;self._process_write_backlog()&lt;/tt&gt; calls &lt;tt class="docutils literal"&gt;self._sslpipe.do_handshake()&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The first &lt;strong&gt;write&lt;/strong&gt; is &lt;strong&gt;delayed&lt;/strong&gt; by &lt;tt class="docutils literal"&gt;call_soon()&lt;/tt&gt;, whereas the first
&lt;strong&gt;read&lt;/strong&gt; is a &lt;strong&gt;direct call&lt;/strong&gt; to the SSL pipe.&lt;/p&gt;
&lt;p&gt;Workaround:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
diff --git a/Lib/asyncio/sslproto.py b/Lib/asyncio/sslproto.py
index 2bfa45dd15..4a5dbb38a1 100644
--- a/Lib/asyncio/sslproto.py
+++ b/Lib/asyncio/sslproto.py
&amp;#64;&amp;#64; -592,7 +592,7 &amp;#64;&amp;#64; class SSLProtocol(protocols.Protocol):
         # (b'', 1) is a special value in _process_write_backlog() to do
         # the SSL handshake
         self._write_backlog.append((b'', 1))
-        self._loop.call_soon(self._process_write_backlog)
+        self._process_write_backlog()
         self._handshake_timeout_handle = \
             self._loop.call_later(self._ssl_handshake_timeout,
                                   self._check_handshake_timeout)
&lt;/pre&gt;
&lt;p&gt;Yury Selivanov wrote:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;The fix is correct and the bug is now obvious&lt;/strong&gt;: &lt;tt class="docutils literal"&gt;data_received()&lt;/tt&gt; occurs
pretty much any time after &lt;tt class="docutils literal"&gt;connection_made()&lt;/tt&gt; call; if &lt;tt class="docutils literal"&gt;call_soon()&lt;/tt&gt; is
used in &lt;tt class="docutils literal"&gt;connection_made()&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;data_received()&lt;/tt&gt; may find the protocol in
an incorrect state.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Kudos Victor for debugging this.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I pushed &lt;a class="reference external" href="https://github.com/python/cpython/commit/be00a5583a2cb696335c527b921d1868266a42c6"&gt;commit be00a558&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit be00a5583a2cb696335c527b921d1868266a42c6
Author: Victor Stinner &amp;lt;vstinner&amp;#64;redhat.com&amp;gt;
Date:   Tue May 29 01:33:35 2018 +0200

    bpo-33674: asyncio: Fix SSLProtocol race (GH-7175)

    Fix a race condition in SSLProtocol.connection_made() of
    asyncio.sslproto: start immediately the handshake instead of using
    call_soon(). Previously, data_received() could be called before the
    handshake started, causing the handshake to hang or fail.
&lt;/pre&gt;
&lt;p&gt;... the change is basically a single line change:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
- self._loop.call_soon(self._process_write_backlog)
+ self._process_write_backlog()
&lt;/pre&gt;
&lt;p&gt;I closed &lt;a class="reference external" href="https://bugs.python.org/issue32458"&gt;bpo-32458&lt;/a&gt; and &lt;strong&gt;Yury
Selivanov&lt;/strong&gt; closed &lt;a class="reference external" href="https://bugs.python.org/issue33674"&gt;bpo-33674&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="not-a-regression"&gt;
&lt;h3&gt;Not a regression&lt;/h3&gt;
&lt;p&gt;The SSLProtocol race condition wasn't new: it existed since January 2015,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/231b404cb026649d4b7172e75ac394ef558efe60"&gt;commit 231b404c&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 231b404cb026649d4b7172e75ac394ef558efe60
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Wed Jan 14 00:19:09 2015 +0100

    Issue #22560: New SSL implementation based on ssl.MemoryBIO

    The new SSL implementation is based on the new ssl.MemoryBIO which is only
    available on Python 3.5. On Python 3.4 and older, the legacy SSL implementation
    (using SSL_write, SSL_read, etc.) is used. The proactor event loop only
    supports the new implementation.

    The new asyncio.sslproto module adds _SSLPipe, SSLProtocol and
    _SSLProtocolTransport classes. _SSLPipe allows to &amp;quot;wrap&amp;quot; or &amp;quot;unwrap&amp;quot; a socket
    (switch between cleartext and SSL/TLS).

    Patch written by Antoine Pitrou. sslproto.py is based on gruvi/ssl.py of the
    gruvi project written by Geert Jansen.

    This change adds SSL support to ProactorEventLoop on Python 3.5 and newer!

    It becomes also possible to implement STARTTTLS: switch a cleartext socket to
    SSL.
&lt;/pre&gt;
&lt;p&gt;This is the new cool asynchronous SSL implementation written by &lt;strong&gt;Antoine
Pitrou&lt;/strong&gt; and &lt;strong&gt;Geert Jansen&lt;/strong&gt;. It took &lt;strong&gt;3 years&lt;/strong&gt; and &lt;strong&gt;new functional tests&lt;/strong&gt;
to discover the race condition.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="wsarecv-cancellation-causing-data-loss"&gt;
&lt;h2&gt;WSARecv() cancellation causing data loss&lt;/h2&gt;
&lt;div class="section" id="yet-another-very-boring-buildbot-test-failure"&gt;
&lt;h3&gt;Yet another very boring buildbot test failure&lt;/h3&gt;
&lt;p&gt;At May 30, 2018, the day after I fixed SSLProtocol race condition, I created
&lt;a class="reference external" href="https://bugs.python.org/issue33694"&gt;bpo-33694&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;test_asyncio.test_start_tls_server_1() got multiple fixes recently (see
&lt;a class="reference external" href="https://bugs.python.org/issue32458"&gt;bpo-32458&lt;/a&gt; and &lt;a class="reference external" href="https://bugs.python.org/issue33674"&gt;bpo-33674&lt;/a&gt;)... but it still fails on Python on x86
Windows7 3.x at revision bb9474f1fb2fc7c7ed9f826b78262d6a12b5f9e8 which
contains all these fixes.&lt;/p&gt;
&lt;p&gt;The test fails even when test_asyncio is re-run alone (not when other tests run
in parallel).&lt;/p&gt;
&lt;p&gt;Example of failure:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ERROR: test_start_tls_server_1 (test.test_asyncio.test_sslproto.ProactorStartTLSTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &amp;quot;...\lib\test\test_asyncio\test_sslproto.py&amp;quot;, line 467, in test_start_tls_server_1
    self.loop.run_until_complete(run_main())
  File &amp;quot;...\lib\asyncio\base_events.py&amp;quot;, line 566, in run_until_complete
    raise RuntimeError('Event loop stopped before Future completed.')
RuntimeError: Event loop stopped before Future completed.
&lt;/pre&gt;
&lt;p&gt;The test fails also on x86 Windows7 3.7. Moreover, 3.7 got an additional failure:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ERROR: test_pipe_handle (test.test_asyncio.test_windows_utils.PipeTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &amp;quot;...\lib\test\test_asyncio\test_windows_utils.py&amp;quot;, line 73, in test_pipe_handle
    raise RuntimeError('expected ERROR_INVALID_HANDLE')
RuntimeError: expected ERROR_INVALID_HANDLE
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="unable-to-reproduce-the-bug"&gt;
&lt;h3&gt;Unable to reproduce the bug&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Yury Selivanov&lt;/strong&gt; &lt;a class="reference external" href="https://bugs.python.org/issue33694#msg318193"&gt;failed to reproduce the issue&lt;/a&gt; in Windows 7 VM (on macOS) using:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;run &lt;tt class="docutils literal"&gt;test_asyncio&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;run &lt;tt class="docutils literal"&gt;test_asyncio.test_sslproto&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;run &lt;tt class="docutils literal"&gt;test_asyncio.test_sslproto &lt;span class="pre"&gt;-m&lt;/span&gt; test_start_tls_server_1&lt;/tt&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Andrew Svetlov&lt;/strong&gt; &lt;a class="reference external" href="https://bugs.python.org/issue33694#msg318194"&gt;added&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
I used &lt;tt class="docutils literal"&gt;SNDBUF&lt;/tt&gt; to enforce send buffer overloading. It is not required by
sendfile tests but I thought that better to have non-mocked way to test such
situations. We can remove the socket buffers size manipulation at all
without any problem.&lt;/blockquote&gt;
&lt;p&gt;But Yury Selivanov &lt;a class="reference external" href="https://bugs.python.org/issue33694#msg318195"&gt;replied&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
When I tried to do that I think &lt;strong&gt;I was having more failures&lt;/strong&gt; with that
test. But really up to you.&lt;/blockquote&gt;
&lt;p&gt;Next days, I reported more and more similar failures on Windows buildbots and
AppVeyor (our Windows CI).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="root-issue-identified-pause-reading"&gt;
&lt;h3&gt;Root issue identified: pause_reading()&lt;/h3&gt;
&lt;p&gt;Since this bug became more and more frequent, I decided to work on it. Yury and
Andrew failed to reproduce it.&lt;/p&gt;
&lt;p&gt;At June 7, 2018, I managed to &lt;strong&gt;reproduce the bug on Linux&lt;/strong&gt; by &lt;a class="reference external" href="https://bugs.python.org/issue33694#msg318869"&gt;inserting a
sleep at the right place&lt;/a&gt;...
I understood one hour later that my patch is wrong: &amp;quot;it introduces a bug in
the test&amp;quot;.&lt;/p&gt;
&lt;p&gt;On the other hand, I found the root cause: calling &lt;tt class="docutils literal"&gt;pause_reading()&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;resume_reading()&lt;/tt&gt; on the transport is not safe. Sometimes, we loose data.
See the &lt;strong&gt;ugly hack&lt;/strong&gt; described in the TODO comment below:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
class _ProactorReadPipeTransport(_ProactorBasePipeTransport,
                                 transports.ReadTransport):
    &amp;quot;&amp;quot;&amp;quot;Transport for read pipes.&amp;quot;&amp;quot;&amp;quot;
    (...)
    def pause_reading(self):
        if self._closing or self._paused:
            return
        self._paused = True

        if self._read_fut is not None and not self._read_fut.done():
            # TODO: This is an ugly hack to cancel the current read future
            # *and* avoid potential race conditions, as read cancellation
            # goes through `future.cancel()` and `loop.call_soon()`.
            # We then use this special attribute in the reader callback to
            # exit *immediately* without doing any cleanup/rescheduling.
            self._read_fut.__asyncio_cancelled_on_pause__ = True

            self._read_fut.cancel()
            self._read_fut = None
            self._reschedule_on_resume = True

        if self._loop.get_debug():
            logger.debug(&amp;quot;%r pauses reading&amp;quot;, self)
&lt;/pre&gt;
&lt;p&gt;If you remove the &amp;quot;ugly hack&amp;quot;, the test no longer hangs...&lt;/p&gt;
&lt;p&gt;Extract of &lt;tt class="docutils literal"&gt;_ProactorReadPipeTransport.set_transport()&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
if self.is_reading():
    # reset reading callback / buffers / self._read_fut
    self.pause_reading()
    self.resume_reading()
&lt;/pre&gt;
&lt;p&gt;This method &lt;strong&gt;cancels the pending overlapped&lt;/strong&gt; &lt;tt class="docutils literal"&gt;WSARecv()&lt;/tt&gt;, and then creates
a new overlapped &lt;tt class="docutils literal"&gt;WSARecv()&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Even after &lt;tt class="docutils literal"&gt;CancelIoEx(old overlapped)&lt;/tt&gt;, the IOCP loop still gets an event
for the completion of the cancelled overlapped &lt;tt class="docutils literal"&gt;WSARecv()&lt;/tt&gt;. Problem: &lt;strong&gt;since
the Python future is cancelled, the event is ignored and so 176 bytes of data
are lost&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;I'm surprised that an overlapped &lt;tt class="docutils literal"&gt;WSARecv()&lt;/tt&gt; &lt;strong&gt;cancelled&lt;/strong&gt; by
&lt;tt class="docutils literal"&gt;CancelIoEx()&lt;/tt&gt; still returns data when IOCP polls for events.&lt;/p&gt;
&lt;p&gt;Something else. The bug occurs when &lt;tt class="docutils literal"&gt;CancelIoEx()&lt;/tt&gt; (on the current overlapped
&lt;tt class="docutils literal"&gt;WSARecv()&lt;/tt&gt;) fails internally with &lt;tt class="docutils literal"&gt;ERROR_NOT_FOUND&lt;/tt&gt;. According to
overlapped.c, it means:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
/* CancelIoEx returns ERROR_NOT_FOUND if the I/O completed in-between */
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;HasOverlappedIoCompleted()&lt;/tt&gt; returns 0 in that case.&lt;/p&gt;
&lt;p&gt;The problem is that currently, &lt;tt class="docutils literal"&gt;Overlapped.cancel()&lt;/tt&gt; also returns &lt;tt class="docutils literal"&gt;None&lt;/tt&gt; in
that case, and later the asyncio IOCP loop ignores the completion event and so
&lt;strong&gt;drops incoming received data&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="release-blocker-bug"&gt;
&lt;h3&gt;Release blocker bug?&lt;/h3&gt;
&lt;p&gt;Yury, Andrew, Ned: I set the priority to release blocker because I'm scared by
what I saw. The START TLS has a race condition in its ProactorEventLoop
implementation. But the bug doesn't see to be specific to START TLS, but rather
to &lt;tt class="docutils literal"&gt;transport.set_transport()&lt;/tt&gt;, and even more generally to
&lt;tt class="docutils literal"&gt;transport.pause_reading()&lt;/tt&gt; / &lt;tt class="docutils literal"&gt;transport.resume_reading()&lt;/tt&gt;. The bug is quite
severe: we loose data and it's really hard to know why (I spent a few hours to
add many many print and try to reproduce on a very tiny reliable unit test). As
an asyncio user, I expect that transports are 100% reliable, and I would first
look into my code (like looking into &lt;tt class="docutils literal"&gt;start_tls()&lt;/tt&gt; implementation in my case).&lt;/p&gt;
&lt;p&gt;If the bug was very specific to &lt;tt class="docutils literal"&gt;start_tls()&lt;/tt&gt;, I would suggest to &amp;quot;just&amp;quot;
&amp;quot;disable&amp;quot; start_tls() on ProactorEventLoop (sorry, Windows!). But since the
data loss seems to concern basically any application using
&lt;tt class="docutils literal"&gt;ProactorEventLoop&lt;/tt&gt;, I don't see any simple workaround.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;My hope is that a fix can be written shortly&lt;/strong&gt; to not block the 3.7.0 final
release for too long :-(&lt;/p&gt;
&lt;p&gt;Yury, Andrew: Can you please just confirm that it's a regression and that a
release blocker is justified?&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="functional-test-reproducing-the-bug"&gt;
&lt;h3&gt;Functional test reproducing the bug&lt;/h3&gt;
&lt;p&gt;I wrote &lt;a class="reference external" href="https://bugs.python.org/file47632/race.py"&gt;race.py script&lt;/a&gt;: simple
echo client and server sending packets in both directions.  Pause/resume
reading the client transport every 100 ms to trigger the bug.&lt;/p&gt;
&lt;p&gt;Using &lt;tt class="docutils literal"&gt;ProactorEventLoop&lt;/tt&gt; and 2000 packets of 16 KiB, I easily reproduce the
bug.&lt;/p&gt;
&lt;p&gt;So again, it's nothing related to &lt;tt class="docutils literal"&gt;start_tls()&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;start_tls()&lt;/tt&gt; was just one
way to spot the bug.&lt;/p&gt;
&lt;p&gt;The bug is in Proactor transport: the cancellation of overlapped &lt;tt class="docutils literal"&gt;WSARecv()&lt;/tt&gt;
sometime drops packets. The bug occurs when &lt;tt class="docutils literal"&gt;CancelIoEx()&lt;/tt&gt; fails with
&lt;tt class="docutils literal"&gt;ERROR_NOT_FOUND&lt;/tt&gt; which means that the I/O (&lt;tt class="docutils literal"&gt;WSARecv()&lt;/tt&gt;) completed.&lt;/p&gt;
&lt;p&gt;One solution would be to not cancel &lt;tt class="docutils literal"&gt;WSARecv()&lt;/tt&gt; on pause_reading(): wait
until the current &lt;tt class="docutils literal"&gt;WSARecv()&lt;/tt&gt; completes, store data somewhere but don't pass
it to &lt;tt class="docutils literal"&gt;protocol.data_received()&lt;/tt&gt;, and don't schedule a new &lt;tt class="docutils literal"&gt;WSARecv()&lt;/tt&gt;.
Once reading is resumed: call &lt;tt class="docutils literal"&gt;protocol.data_received()&lt;/tt&gt; and schedule a new
&lt;tt class="docutils literal"&gt;WSARecv()&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;That would be a workaround. I don't know how to really fix &lt;tt class="docutils literal"&gt;WSARecv()&lt;/tt&gt;
cancellation without loosing data. A good start would be to modify
&lt;tt class="docutils literal"&gt;Overlapped.cancel()&lt;/tt&gt; to return a boolean to notice if the overlapped I/O
completed even if we just cancelled it. Currently, the corner case
(&lt;tt class="docutils literal"&gt;CancelIoEx()&lt;/tt&gt; fails with &lt;tt class="docutils literal"&gt;ERROR_NOT_FOUND&lt;/tt&gt;) is silently ignored, and then
the IOCP loop silently ignores the event of completed I/O...&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="fix-the-bug-no-longer-cancel-wsarecv"&gt;
&lt;h3&gt;Fix the bug: no longer cancel WSARecv()&lt;/h3&gt;
&lt;p&gt;At June 8, 2018, I pushed &lt;a class="reference external" href="https://github.com/python/cpython/commit/79790bc35fe722a49977b52647f9b5fe1deda2b7"&gt;commit 79790bc3&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 79790bc35fe722a49977b52647f9b5fe1deda2b7
Author: Victor Stinner &amp;lt;vstinner&amp;#64;redhat.com&amp;gt;
Date:   Fri Jun 8 00:25:52 2018 +0200

    bpo-33694: Fix race condition in asyncio proactor (GH-7498)

    The cancellation of an overlapped WSARecv() has a race condition
    which causes data loss because of the current implementation of
    proactor in asyncio.

    No longer cancel overlapped WSARecv() in _ProactorReadPipeTransport
    to work around the race condition.

    Remove the optimized recv_into() implementation to get simple
    implementation of pause_reading() using the single _pending_data
    attribute.

    Move _feed_data_to_bufferred_proto() to protocols.py.

    Remove set_protocol() method which became useless.
&lt;/pre&gt;
&lt;p&gt;I fixed the root issue (in Python 3.7 and future Python 3.8).&lt;/p&gt;
&lt;p&gt;I used my &lt;tt class="docutils literal"&gt;race.py&lt;/tt&gt; script to validate that the issue is fixed for real.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;I fixed one race condition in the asynchronous handshake of &lt;tt class="docutils literal"&gt;SSLProtocol&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;I found and fixed a data loss bug caused by &lt;tt class="docutils literal"&gt;WSARecv()&lt;/tt&gt; cancellation.&lt;/p&gt;
&lt;p&gt;Lessons learnt from these two bugs:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;You should &lt;strong&gt;write an extensive test suite&lt;/strong&gt; for your code.&lt;/li&gt;
&lt;li&gt;You should &lt;strong&gt;keep an eye on your continuous integration (CI)&lt;/strong&gt;: any tiny test
failure can hide a very severe bug.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content><category term="cpython"></category><category term="asyncio"></category></entry><entry><title>Asyncio: Proactor ConnectPipe() Race Condition</title><link href="https://vstinner.github.io/asyncio-proactor-connect-pipe-race-condition.html" rel="alternate"></link><published>2019-01-30T18:00:00+01:00</published><updated>2019-01-30T18:00:00+01:00</updated><author><name>Victor Stinner</name></author><id>tag:vstinner.github.io,2019-01-30:/asyncio-proactor-connect-pipe-race-condition.html</id><summary type="html">&lt;p&gt;Between December 2014 and January 2015, once I succeeded to fix the root issue
of the random asyncio crashes on Windows (&lt;a class="reference external" href="https://vstinner.github.io/asyncio-proactor-cancellation-from-hell.html"&gt;Proactor Cancellation From Hell&lt;/a&gt;), I fixed more race conditions
and bugs in &lt;tt class="docutils literal"&gt;ProactorEventLoop&lt;/tt&gt;:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;ConnectPipe()&lt;/tt&gt; Race Condition&lt;/li&gt;
&lt;li&gt;Race Condition in &lt;tt class="docutils literal"&gt;BaseSubprocessTransport._try_finish()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;Close the transport on failure: ResourceWarning&lt;/li&gt;
&lt;li&gt;Cleanup code …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;Between December 2014 and January 2015, once I succeeded to fix the root issue
of the random asyncio crashes on Windows (&lt;a class="reference external" href="https://vstinner.github.io/asyncio-proactor-cancellation-from-hell.html"&gt;Proactor Cancellation From Hell&lt;/a&gt;), I fixed more race conditions
and bugs in &lt;tt class="docutils literal"&gt;ProactorEventLoop&lt;/tt&gt;:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;ConnectPipe()&lt;/tt&gt; Race Condition&lt;/li&gt;
&lt;li&gt;Race Condition in &lt;tt class="docutils literal"&gt;BaseSubprocessTransport._try_finish()&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;Close the transport on failure: ResourceWarning&lt;/li&gt;
&lt;li&gt;Cleanup code handling pipes&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Previous article: &lt;a class="reference external" href="https://vstinner.github.io/asyncio-proactor-cancellation-from-hell.html"&gt;Proactor Cancellation From Hell&lt;/a&gt;. Next article:
&lt;a class="reference external" href="https://vstinner.github.io/asyncio-proactor-wsarecv-cancellation-data-loss.html"&gt;asyncio: WSARecv() cancellation causing data loss&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="connectpipe-race-condition"&gt;
&lt;h2&gt;ConnectPipe() Race Condition&lt;/h2&gt;
&lt;p&gt;Once I succeeded to fix the root issue of the random asyncio crashes on Windows
(&lt;a class="reference external" href="https://vstinner.github.io/asyncio-proactor-cancellation-from-hell.html"&gt;Proactor Cancellation From Hell&lt;/a&gt;), I started to look at the
ConnectPipe special case: &lt;a class="reference external" href="https://github.com/python/asyncio/issues/204"&gt;asyncio issue #204: Investigate
IocpProactor.accept_pipe() special case (don't register overlapped)&lt;/a&gt; (issue created at 25 Aug
2014).&lt;/p&gt;
&lt;a class="reference external image-reference" href="https://www.flickr.com/photos/phrawr/7612947262/"&gt;&lt;img alt="Pipes" src="https://vstinner.github.io/images/pipes.jpg" /&gt;&lt;/a&gt;
&lt;p&gt;At January 21, 2015, I opened &lt;a class="reference external" href="https://bugs.python.org/issue23293"&gt;bpo-23293: race condition related to
IocpProactor.connect_pipe()&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;While fixing &lt;a class="reference external" href="https://bugs.python.org/issue23095"&gt;bpo-23095 (race condition when cancelling a _WaitHandleFuture)&lt;/a&gt;, I saw that
&lt;tt class="docutils literal"&gt;IocpProactor.connect_pipe()&lt;/tt&gt; causes &amp;quot;GetQueuedCompletionStatus() returned an
unexpected event&amp;quot; messages to be logged, but also to hang the test suite.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;IocpProactor._register()&lt;/tt&gt; contains the comment:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# Even if GetOverlappedResult() was called, we have to wait for the
# notification of the completion in GetQueuedCompletionStatus().
# Register the overlapped operation to keep a reference to the
# OVERLAPPED object, otherwise the memory is freed and Windows may
# read uninitialized memory.
#
# For an unknown reason, ConnectNamedPipe() behaves differently:
# the completion is not notified by GetOverlappedResult() if we
# already called GetOverlappedResult(). For this specific case, we
# don't expect notification (register is set to False).
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;IocpProactor.close()&lt;/tt&gt; contains this comment:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# The operation was started with connect_pipe() which
# queues a task to Windows' thread pool.  This cannot
# be cancelled, so just forget it.
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;IocpProactor.connect_pipe()&lt;/tt&gt; is implemented with &lt;tt class="docutils literal"&gt;QueueUserWorkItem()&lt;/tt&gt;
which &lt;strong&gt;starts a thread that cannot be interrupted&lt;/strong&gt;. Because of that, this
function requires special cases in &lt;tt class="docutils literal"&gt;_register()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;close()&lt;/tt&gt; methods of
&lt;tt class="docutils literal"&gt;IocpProactor&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;I proposed a solution to reimplement &lt;tt class="docutils literal"&gt;IocpProactor.connect_pipe()&lt;/tt&gt; &lt;strong&gt;without
a thread&lt;/strong&gt;: &lt;a class="reference external" href="https://code.google.com/p/tulip/issues/detail?id=197"&gt;asyncio issue #197: Rewrite IocpProactor.connect_pipe() with
non-blocking calls to avoid non interruptible QueueUserWorkItem()&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;At January 22, 2015, I pushed &lt;a class="reference external" href="https://github.com/python/cpython/commit/7ffa2c5fdda8a9cc254edf67c4458b15db1252fa"&gt;commit 7ffa2c5f&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 7ffa2c5fdda8a9cc254edf67c4458b15db1252fa
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Thu Jan 22 22:55:08 2015 +0100

    Issue #23293, asyncio: Rewrite IocpProactor.connect_pipe()
&lt;/pre&gt;
&lt;p&gt;The change adds &lt;tt class="docutils literal"&gt;_overlapped.ConnectPipe()&lt;/tt&gt; which tries to connect to the
pipe for asynchronous I/O (overlapped): &lt;strong&gt;call CreateFile() in a loop until
it doesn't fail with ERROR_PIPE_BUSY&lt;/strong&gt;. Use an increasing delay between 1 ms
and 100 ms.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="race-condition-in-basesubprocesstransport-try-finish"&gt;
&lt;h2&gt;Race Condition in BaseSubprocessTransport._try_finish()&lt;/h2&gt;
&lt;p&gt;If the process exited before the &lt;tt class="docutils literal"&gt;_post_init()&lt;/tt&gt; method was called, scheduling
the call to &lt;tt class="docutils literal"&gt;_call_connection_lost()&lt;/tt&gt; with &lt;tt class="docutils literal"&gt;call_soon()&lt;/tt&gt; is wrong:
&lt;tt class="docutils literal"&gt;connection_made()&lt;/tt&gt; must be called before &lt;tt class="docutils literal"&gt;connection_lost()&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Reuse the &lt;tt class="docutils literal"&gt;BaseSubprocessTransport._call()&lt;/tt&gt; method to schedule the call to
&lt;tt class="docutils literal"&gt;_call_connection_lost()&lt;/tt&gt; to ensure that &lt;tt class="docutils literal"&gt;connection_made()&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;connection_lost()&lt;/tt&gt; are called in the correct order.&lt;/p&gt;
&lt;p&gt;At Dec 18, 2014, I pushed &lt;a class="reference external" href="https://github.com/python/cpython/commit/1b9763d0a9c62c13dc2a06770032e5906b610c96"&gt;commit 1b9763d0&lt;/a&gt;.
The explanation is long, but the change is basically a single line change,
extract:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
- self._loop.call_soon(self._call_connection_lost, None)
+ self._call(self._call_connection_lost, None)
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Ordering properly callbacks in asyncio is challenging!&lt;/strong&gt; The order matters
for the semantics of asyncio: it is part of the design of the &lt;a class="reference external" href="https://www.python.org/dev/peps/pep-3156/"&gt;PEP 3156 --
Asynchronous IO Support Rebooted: the &amp;quot;asyncio&amp;quot; Module&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="close-the-transport-on-failure-resourcewarning"&gt;
&lt;h2&gt;Close the transport on failure: ResourceWarning&lt;/h2&gt;
&lt;p&gt;At January 15, 2015, I pushed &lt;a class="reference external" href="https://github.com/python/cpython/commit/4bf22e033e975f61c33752db5a3764dc0f7d0b03"&gt;commit 4bf22e03&lt;/a&gt;,
extract:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
-  yield from transp._post_init()
+  try:
+      yield from transp._post_init()
+  except:
+      transp.close()
+      raise
&lt;/pre&gt;
&lt;p&gt;Later, I will spend a lot of time (push many more changes) to ensure that
resources are properly released (especially close transports on failure,
similar to this change).&lt;/p&gt;
&lt;p&gt;I will add many &lt;strong&gt;ResourceWarnings&lt;/strong&gt; warnings in destructors when a transport,
subprocess or event loop is not closed explicitly.&lt;/p&gt;
&lt;p&gt;For example, notice the &lt;tt class="docutils literal"&gt;ResourceWarnings&lt;/tt&gt; in the current destructor of
&lt;tt class="docutils literal"&gt;_SelectorTransport&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
class _SelectorTransport(transports._FlowControlMixin,
                         transports.Transport):

    def __del__(self, _warn=warnings.warn):
        if self._sock is not None:
            _warn(f&amp;quot;unclosed transport {self!r}&amp;quot;, ResourceWarning, source=self)
            self._sock.close()
&lt;/pre&gt;
&lt;p&gt;I even enhanced Python 3.6 to be able to provide the &lt;strong&gt;traceback where the
leaked resource has been allocated&lt;/strong&gt; thanks to my &lt;tt class="docutils literal"&gt;tracemalloc&lt;/tt&gt; module.
Example with &lt;tt class="docutils literal"&gt;filebug.py&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
def func():
    f = open(__file__)
    f = None

func()
&lt;/pre&gt;
&lt;p&gt;Output with Python 3.6:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ python3 -Wd -X tracemalloc=5 filebug.py
filebug.py:3: ResourceWarning: unclosed file &amp;lt;_io.TextIOWrapper name='filebug.py' mode='r' encoding='UTF-8'&amp;gt;
  f = None
Object allocated at (most recent call first):
  File &amp;quot;filebug.py&amp;quot;, lineno 2
    f = open(__file__)
  File &amp;quot;filebug.py&amp;quot;, lineno 5
    func()
&lt;/pre&gt;
&lt;p&gt;The line where the warning is emitted is usually useless to understand the bug,
whereas the traceback is very useful to identify the leaked resource.&lt;/p&gt;
&lt;p&gt;See &lt;a class="reference external" href="https://pythondev.readthedocs.io/debug_tools.html#resourcewarning"&gt;my ResourceWarning documentation&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="cleanup-code-handling-pipes"&gt;
&lt;h2&gt;Cleanup code handling pipes&lt;/h2&gt;
&lt;p&gt;Thanks to the new implementation of &lt;tt class="docutils literal"&gt;connect_pipe()&lt;/tt&gt;, I was able to push
changes to simplify the code and remove various hacks in code handling pipes.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/python/cpython/commit/2b77c5467f376257ae22cbfbcb3a0e5e6349e92d"&gt;commit 2b77c546&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 2b77c5467f376257ae22cbfbcb3a0e5e6349e92d
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Thu Jan 22 23:50:03 2015 +0100

    asyncio, Tulip issue 204: Fix IocpProactor.accept_pipe()

    Overlapped.ConnectNamedPipe() now returns a boolean: True if the pipe is
    connected (if ConnectNamedPipe() failed with ERROR_PIPE_CONNECTED), False if
    the connection is in progress.

    This change removes multiple hacks in IocpProactor.
&lt;/pre&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/python/cpython/commit/3d2256f671b7ed5c769dd34b27ae597cbc69047c"&gt;commit 3d2256f6&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 3d2256f671b7ed5c769dd34b27ae597cbc69047c
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Mon Jan 26 11:02:59 2015 +0100

    Issue #23293, asyncio: Cleanup IocpProactor.close()

    The special case for connect_pipe() is not more needed. connect_pipe() doesn't
    use overlapped operations anymore.
&lt;/pre&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/python/cpython/commit/a19b7b3fcafe52b98245e14466ffc4d6750ca4f1"&gt;commit a19b7b3f&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit a19b7b3fcafe52b98245e14466ffc4d6750ca4f1
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Mon Jan 26 15:03:20 2015 +0100

    asyncio: Fix ProactorEventLoop.start_serving_pipe()

    If a client connected before the server was closed: drop the client (close the
    pipe) and exit.
&lt;/pre&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/python/cpython/commit/e0fd157ba0cc92e435e7520b4ff641ca68d72244"&gt;commit e0fd157b&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit e0fd157ba0cc92e435e7520b4ff641ca68d72244
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Mon Jan 26 15:04:03 2015 +0100

    Issue #23293, asyncio: Rewrite IocpProactor.connect_pipe() as a coroutine

    Use a coroutine with asyncio.sleep() instead of call_later() to ensure that the
    schedule call is cancelled.

    Add also a unit test cancelling connect_pipe().
&lt;/pre&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/python/cpython/commit/41063d2a59a24e257cd9ce62137e36c862e3ab1e"&gt;commit 41063d2a&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 41063d2a59a24e257cd9ce62137e36c862e3ab1e
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Mon Jan 26 22:30:49 2015 +0100

    asyncio, Tulip issue 204: Fix IocpProactor.recv()

    If ReadFile() fails with ERROR_BROKEN_PIPE, the operation is not pending: don't
    register the overlapped.

    I don't know if WSARecv() can fail with ERROR_BROKEN_PIPE. Since
    Overlapped.WSARecv() already handled ERROR_BROKEN_PIPE, let me guess that it
    has the same behaviour than ReadFile().
&lt;/pre&gt;
&lt;/div&gt;
</content><category term="cpython"></category><category term="asyncio"></category></entry><entry><title>Asyncio: Proactor Cancellation From Hell</title><link href="https://vstinner.github.io/asyncio-proactor-cancellation-from-hell.html" rel="alternate"></link><published>2019-01-28T20:20:00+01:00</published><updated>2019-01-28T20:20:00+01:00</updated><author><name>Victor Stinner</name></author><id>tag:vstinner.github.io,2019-01-28:/asyncio-proactor-cancellation-from-hell.html</id><summary type="html">&lt;p&gt;Between 2014 and 2015, I was working on the new shiny &lt;tt class="docutils literal"&gt;asyncio&lt;/tt&gt; module
(module added to Python 3.4 released in March 2014). I helped to stabilize the
Windows implementation because... well, nobody else was paying attention to it,
and I was worried that test_asyncio &lt;strong&gt;randomly crashed&lt;/strong&gt; on Windows.&lt;/p&gt;
&lt;p&gt;One …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Between 2014 and 2015, I was working on the new shiny &lt;tt class="docutils literal"&gt;asyncio&lt;/tt&gt; module
(module added to Python 3.4 released in March 2014). I helped to stabilize the
Windows implementation because... well, nobody else was paying attention to it,
and I was worried that test_asyncio &lt;strong&gt;randomly crashed&lt;/strong&gt; on Windows.&lt;/p&gt;
&lt;p&gt;One bug really annoyed me, I started to fix it in July 2014, but I only
succeeded to &lt;strong&gt;fix the root issue&lt;/strong&gt; in January 2015: &lt;strong&gt;six months later&lt;/strong&gt;!&lt;/p&gt;
&lt;p&gt;It was really difficult to find documentation on IOCP and asynchronous
programming on Windows. &lt;strong&gt;I had to ask for help to someone who had access to
the Windows source code&lt;/strong&gt; to understand the bug...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spoiler:&lt;/strong&gt; cancelling an overlapped &lt;tt class="docutils literal"&gt;RegisterWaitForSingleObject()&lt;/tt&gt; with
&lt;tt class="docutils literal"&gt;UnregisterWait()&lt;/tt&gt; is asynchronous. The asynchronous part is not well
documented and it took me months of debug to understand it. Moreover, the bug
was well hidden for various reasons that we will see below.&lt;/p&gt;
&lt;p&gt;Next article: &lt;a class="reference external" href="https://vstinner.github.io/asyncio-proactor-connect-pipe-race-condition.html"&gt;Asyncio: Proactor ConnectPipe() Race Condition&lt;/a&gt;.&lt;/p&gt;
&lt;img alt="South Park Hell" src="https://vstinner.github.io/images/south_park_hell.jpg" /&gt;
&lt;div class="section" id="fix-cancel-when-called-twice"&gt;
&lt;h2&gt;Fix cancel() when called twice&lt;/h2&gt;
&lt;p&gt;July 2014, &lt;a class="reference external" href="https://github.com/python/asyncio/issues/195"&gt;asyncio issue #195&lt;/a&gt;: while working on a
&lt;tt class="docutils literal"&gt;SIGINT&lt;/tt&gt; signal handler for the &lt;tt class="docutils literal"&gt;ProactorEventLoop&lt;/tt&gt; on Windows (&lt;a class="reference external" href="https://github.com/python/asyncio/issues/195"&gt;asyncio
issue #191&lt;/a&gt;), I hit a bug on
Windows: &lt;tt class="docutils literal"&gt;_WaitHandleFuture.cancel()&lt;/tt&gt; crash if the wait event was already
unregistered by &lt;tt class="docutils literal"&gt;finish_wait_for_handle()&lt;/tt&gt;. The bug was that
&lt;tt class="docutils literal"&gt;UnregisterWait()&lt;/tt&gt; was called twice.&lt;/p&gt;
&lt;p&gt;I pushed &lt;a class="reference external" href="https://github.com/python/cpython/commit/fea6a100dc51012cb0187374ad31de330ebc0035"&gt;commit fea6a100&lt;/a&gt;
to fix this crash:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit fea6a100dc51012cb0187374ad31de330ebc0035
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Fri Jul 25 00:54:53 2014 +0200

    Improve stability of the proactor event loop, especially operations on
    overlapped objects (...)
&lt;/pre&gt;
&lt;p&gt;Main changes:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Fix a crash: &lt;strong&gt;don't call UnregisterWait() twice if a _WaitHandleFuture
is cancelled twice&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Fix another crash: &lt;tt class="docutils literal"&gt;_OverlappedFuture.cancel()&lt;/tt&gt; doesn't cancel the
overlapped anymore if it is already cancelled or completed. Log also an error
if the cancellation failed.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;IocpProactor.close()&lt;/tt&gt; now cancels futures rather than cancelling directly
underlaying overlapped objects.&lt;/li&gt;
&lt;li&gt;Add a destructor to the &lt;tt class="docutils literal"&gt;IocpProactor&lt;/tt&gt; class which closes it&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="clear-reference-from-overlappedfuture-to-overlapped"&gt;
&lt;h2&gt;Clear reference from _OverlappedFuture to overlapped&lt;/h2&gt;
&lt;p&gt;July 2014, I created &lt;a class="reference external" href="https://github.com/python/asyncio/issues/196"&gt;asyncio issue #196&lt;/a&gt;:
&lt;tt class="docutils literal"&gt;_OverlappedFuture.set_result()&lt;/tt&gt; should clear the its reference to the
overlapped object.&lt;/p&gt;
&lt;p&gt;It is important to explicitly clear references to Python objects as soon as
possible to release resources. Otherwise, an object can remain alive
longer than expected.&lt;/p&gt;
&lt;p&gt;I noticed that _OverlappedFuture kept a reference to the undelying overlapped
object even after the asynchronous operation completed. I started to work on a
fix but I had many issues to fix completely this bug... it is just the
beginning of a long journey.&lt;/p&gt;
&lt;div class="section" id="clear-the-reference-on-cancellation-and-error"&gt;
&lt;h3&gt;Clear the reference on cancellation and error&lt;/h3&gt;
&lt;p&gt;I pushed a first fix: &lt;a class="reference external" href="https://github.com/python/cpython/commit/18a28dc5c28ae9a953f537486780159ddb768702"&gt;commit 18a28dc5&lt;/a&gt;
clears the reference to the overlapped in &lt;tt class="docutils literal"&gt;cancel()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;set_exception()&lt;/tt&gt;
methods of &lt;tt class="docutils literal"&gt;_OverlappedFuture&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 18a28dc5c28ae9a953f537486780159ddb768702
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Fri Jul 25 13:05:20 2014 +0200

    * _OverlappedFuture.cancel() now clears its reference to the overlapped object.
      Make also the _OverlappedFuture.ov attribute private.
    * _OverlappedFuture.set_exception() now cancels the overlapped operation.
    * (...)
&lt;/pre&gt;
&lt;p&gt;I started by this change because it didn't make the tests less stable.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="clear-the-reference-in-poll"&gt;
&lt;h3&gt;Clear the reference in poll()&lt;/h3&gt;
&lt;p&gt;Clearing the reference to the overlapped in &lt;tt class="docutils literal"&gt;cancel()&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;set_exception()&lt;/tt&gt; &lt;strong&gt;works well&lt;/strong&gt;. But when I try to do the same on success (in
&lt;tt class="docutils literal"&gt;set_result()&lt;/tt&gt;), &lt;strong&gt;I get random errors&lt;/strong&gt;. Example:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
C:\haypo\tulip&amp;gt;\python33\python.exe runtests.py test_pipe
...
Exception RuntimeError: '&amp;lt;_overlapped.Overlapped object at 0x00000000035E7660&amp;gt; s
till has pending operation at deallocation, the process may crash' ignored
...
Fatal read error on pipe transport
protocol: &amp;lt;asyncio.streams.StreamReaderProtocol object at 0x00000000035EE668&amp;gt;
transport: &amp;lt;_ProactorDuplexPipeTransport fd=348&amp;gt;
Traceback (most recent call last):
  File &amp;quot;C:\haypo\tulip\asyncio\proactor_events.py&amp;quot;, line 159, in _loop_reading
    data = fut.result()  # deliver data later in &amp;quot;finally&amp;quot; clause
  File &amp;quot;C:\haypo\tulip\asyncio\futures.py&amp;quot;, line 271, in result
    raise self._exception
  File &amp;quot;C:\haypo\tulip\asyncio\windows_events.py&amp;quot;, line 488, in _poll
    value = callback(transferred, key, ov)
  File &amp;quot;C:\haypo\tulip\asyncio\windows_events.py&amp;quot;, line 279, in finish_recv
    return ov.getresult()
OSError: [WinError 996] Overlapped I/O event is not in a signaled state
...
&lt;/pre&gt;
&lt;p&gt;It seems that the problem only occurs in the fast-path of
&lt;tt class="docutils literal"&gt;IocpProactor._register()&lt;/tt&gt;, when the overlapped is not added to &lt;tt class="docutils literal"&gt;_cache&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Clearing the reference in &lt;tt class="docutils literal"&gt;_poll()&lt;/tt&gt;, when &lt;tt class="docutils literal"&gt;GetQueuedCompletionStatus()&lt;/tt&gt; read
the status, &lt;strong&gt;works&lt;/strong&gt;! I pushed a second fix, &lt;a class="reference external" href="https://github.com/python/cpython/commit/65dd69a3da16257bd86b92900e5ec5a8dd26f1d9"&gt;commit 65dd69a3&lt;/a&gt;
changes &lt;tt class="docutils literal"&gt;_poll()&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 65dd69a3da16257bd86b92900e5ec5a8dd26f1d9
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Fri Jul 25 22:36:05 2014 +0200

    IocpProactor._poll() clears the reference to the overlapped operation
    when the operation is done. (...)
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="ignore-false-alarms"&gt;
&lt;h3&gt;Ignore false alarms&lt;/h3&gt;
&lt;p&gt;I tried to add the overlapped into &lt;tt class="docutils literal"&gt;_cache&lt;/tt&gt; but &lt;strong&gt;then the event loop started
to hang or to fail with new errors&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;I analyzed an overlapped &lt;tt class="docutils literal"&gt;WSARecv()&lt;/tt&gt; which has been cancelled. Just after
calling &lt;tt class="docutils literal"&gt;CancelIoEx()&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;HasOverlappedIoCompleted()&lt;/tt&gt; returns 0.&lt;/p&gt;
&lt;p&gt;Even after &lt;tt class="docutils literal"&gt;GetQueuedCompletionStatus()&lt;/tt&gt; read the status,
&lt;tt class="docutils literal"&gt;HasOverlappedIoCompleted()&lt;/tt&gt; still returns 0.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;After hours of debug, I eventually found the main issue!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Sometimes &lt;tt class="docutils literal"&gt;GetQueuedCompletionStatus()&lt;/tt&gt; returns an overlapped operation which
has not completed yet. I modified &lt;tt class="docutils literal"&gt;IocpProactor._poll()&lt;/tt&gt; to ignore the false
alarm, &lt;a class="reference external" href="https://github.com/python/cpython/commit/51e44ea66aefb4229e506263acf40d35596d279c"&gt;commit 51e44ea6&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 51e44ea66aefb4229e506263acf40d35596d279c
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Sat Jul 26 00:58:34 2014 +0200

    _OverlappedFuture.set_result() now clears its reference to the
    overlapped object.

    IocpProactor._poll() now also ignores false alarms:
    GetQueuedCompletionStatus() returns the overlapped but it is still
    pending.
&lt;/pre&gt;
&lt;p&gt;The fix adds this comment:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# FIXME: why do we get false alarms?
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="keep-a-reference-of-overlapped"&gt;
&lt;h3&gt;Keep a reference of overlapped&lt;/h3&gt;
&lt;p&gt;To stabilize the code, I modified &lt;tt class="docutils literal"&gt;ProactorIocp&lt;/tt&gt; to keep a reference to the
overlapped object (it already kept a reference previously but not in all cases).
&lt;strong&gt;Otherwise the memory may be reused and GetQueuedCompletionStatus() may use
random bytes and behaves badly&lt;/strong&gt;. I pushed &lt;a class="reference external" href="https://github.com/python/cpython/commit/42d3bdeed6e34117b787d61a471563a0dba6a894"&gt;commit 42d3bdee&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 42d3bdeed6e34117b787d61a471563a0dba6a894
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Mon Jul 28 00:18:43 2014 +0200

    ProactorIocp._register() now registers the overlapped
    in the _cache dictionary, even if we already got the result. We need to keep a
    reference to the overlapped object, otherwise the memory may be reused and
    GetQueuedCompletionStatus() may use random bytes and behaves badly.

    There is still a hack for ConnectNamedPipe(): the overlapped object is not
    registered into _cache if the overlapped object completed directly.

    Log also an error in debug mode in ProactorIocp._loop() if we get an unexpected
    event.

    Add a protection in ProactorIocp.close() to avoid blocking, even if it should
    not happen. I still don't understand exactly why some the completion of some
    overlapped objects are not notified.
&lt;/pre&gt;
&lt;p&gt;The change adds a long comment:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# Even if GetOverlappedResult() was called, we have to wait for the
# notification of the completion in GetQueuedCompletionStatus().
# Register the overlapped operation to keep a reference to the
# OVERLAPPED object, otherwise the memory is freed and Windows may
# read uninitialized memory.
#
# For an unknown reason, ConnectNamedPipe() behaves differently:
# the completion is not notified by GetOverlappedResult() if we
# already called GetOverlappedResult(). For this specific case, we
# don't expect notification (register is set to False).
&lt;/pre&gt;
&lt;p&gt;I pushed another change to attempt to stabilize the code, &lt;a class="reference external" href="https://github.com/python/cpython/commit/313a9809043ed2ed1ad25282af7169e08cdc92a3"&gt;commit 313a9809&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 313a9809043ed2ed1ad25282af7169e08cdc92a3
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Tue Jul 29 12:58:23 2014 +0200

    * _WaitHandleFuture.cancel() now notify IocpProactor through the overlapped
      object that the wait was cancelled.
    * Optimize IocpProactor.wait_for_handle() gets the result if the wait is
      signaled immediatly.
    (...)
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="asyncio-issue-196-closed"&gt;
&lt;h3&gt;asyncio issue #196 closed&lt;/h3&gt;
&lt;p&gt;The initial issue &amp;quot;_OverlappedFuture.set_result() should clear its reference to
the overlapped object&amp;quot; has been fixed, so &lt;strong&gt;I closed this issue&lt;/strong&gt;. I didn't
know at this point that all bugs were not fixed yet...&lt;/p&gt;
&lt;p&gt;I also opened the new &lt;a class="reference external" href="https://github.com/python/asyncio/issues/204"&gt;asyncio issue #204&lt;/a&gt; to investigate
&lt;tt class="docutils literal"&gt;accept_pipe()&lt;/tt&gt; special case. We will analyze this funny bug in another article.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="bpo-23095-race-condition-when-cancelling-a-waithandlefuture"&gt;
&lt;h2&gt;bpo-23095: race condition when cancelling a _WaitHandleFuture&lt;/h2&gt;
&lt;p&gt;At December 21, 2014, five months after a long serie of changes to stabilize
asyncio...  &lt;strong&gt;asyncio was still crashing randomly on Windows&lt;/strong&gt;! I created
&lt;a class="reference external" href="https://bugs.python.org/issue23095"&gt;bpo-23095: race condition when cancelling a _WaitHandleFuture&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;On Windows using the IOCP (proactor) event loop, I noticed race conditions when
running the test suite of Trollius (my old deprecated asyncio port to Python
2). For example, sometimes the return code of a process was &lt;tt class="docutils literal"&gt;None&lt;/tt&gt;, whereas
this case &lt;strong&gt;must never happen&lt;/strong&gt;. It looks like the &lt;tt class="docutils literal"&gt;wait_for_handle()&lt;/tt&gt; method
doesn't behave properly.&lt;/p&gt;
&lt;p&gt;When I run the test suite of asyncio in debug mode (PYTHONASYNCIODEBUG=1),
sometimes I see the message &amp;quot;GetQueuedCompletionStatus() returned an unexpected
event&amp;quot; which &lt;strong&gt;should never occur neither&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;I added debug traces. I saw that the &lt;tt class="docutils literal"&gt;IocpProactor.wait_for_handle()&lt;/tt&gt; calls
later &lt;tt class="docutils literal"&gt;PostQueuedCompletionStatus()&lt;/tt&gt; through its internal C callback
(&lt;tt class="docutils literal"&gt;PostToQueueCallback&lt;/tt&gt;). It looks like &lt;strong&gt;sometimes the callback is called
whereas the wait was cancelled/acked&lt;/strong&gt; by &lt;tt class="docutils literal"&gt;UnregisterWait()&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;... I didn't understand the logic between &lt;tt class="docutils literal"&gt;RegisterWaitForSingleObject()&lt;/tt&gt;,
&lt;tt class="docutils literal"&gt;UnregisterWait()&lt;/tt&gt; and the callback ....&lt;/p&gt;
&lt;p&gt;It looks like sometimes the overlapped object created in Python
(&lt;tt class="docutils literal"&gt;ov = _overlapped.Overlapped(NULL)&lt;/tt&gt;) is destroyed, before
&lt;tt class="docutils literal"&gt;PostToQueueCallback()&lt;/tt&gt; is called. In the unit tests, &lt;strong&gt;it doesn't crash
because a different overlapped object is created and it gets the same memory
address&lt;/strong&gt; (the memory allocator reuses a just freed memory block).&lt;/p&gt;
&lt;p&gt;The implementation of &lt;tt class="docutils literal"&gt;wait_for_handle()&lt;/tt&gt; had an optimization: it polls
immediatly the wait to check if it already completed. I tried to remove it, but
I got some different issues. If I understood correctly, &lt;strong&gt;this optimization
hides other bugs and reduce the probability of getting the race condition&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;wait_for_handle()&lt;/tt&gt; is used to wait for the completion of a subprocess, so by
all unit tests running subprocesses, but also in &lt;tt class="docutils literal"&gt;test_wait_for_handle()&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;test_wait_for_handle_cancel()&lt;/tt&gt; tests. I suspect that running
&lt;tt class="docutils literal"&gt;test_wait_for_handle()&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;test_wait_for_handle_cancel()&lt;/tt&gt; triggers the
bug.&lt;/p&gt;
&lt;p&gt;Removing &lt;tt class="docutils literal"&gt;_winapi.CloseHandle(self._iocp)&lt;/tt&gt; in &lt;tt class="docutils literal"&gt;IocpProactor.close()&lt;/tt&gt;
works around the bug. The bug looks to be an expected call to
&lt;tt class="docutils literal"&gt;PostToQueueCallback()&lt;/tt&gt; which calls &lt;tt class="docutils literal"&gt;PostQueuedCompletionStatus()&lt;/tt&gt; on an
IOCP. Not closing the IOCP means using a different IOCP for each test, so the
unexpected call to &lt;tt class="docutils literal"&gt;PostQueuedCompletionStatus()&lt;/tt&gt; has no effect on following
tests.&lt;/p&gt;
&lt;p&gt;I rewrote some parts of the IOCP code in asyncio. Maybe I introduced this issue
during the refactoring. Maybe &lt;strong&gt;it already existed before but nobody noticed
it, asyncio had fewer unit tests before&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="fixing-the-root-issue-overlapped-cancellation-from-hell"&gt;
&lt;h2&gt;Fixing the root issue: Overlapped Cancellation From Hell&lt;/h2&gt;
&lt;p&gt;I looked into Twisted implemented of proactor, but it didn't support
subprocesses.&lt;/p&gt;
&lt;p&gt;I looked at libuv: it supported processes but not cancelling a wait on a
process handle...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I had to ask for help to someone who had access to the Windows source code&lt;/strong&gt;
to understand the bug...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;After six months of intense debugging, I eventually identified the root
issue&lt;/strong&gt; (I pushed the first fix at July 25, 2014). I pushed the &lt;a class="reference external" href="https://github.com/python/cpython/commit/d0a28dee78d099fcadc71147cba4affb6efa0c97"&gt;commit
d0a28dee&lt;/a&gt;
(&lt;a class="reference external" href="https://bugs.python.org/issue23095"&gt;bpo-23095&lt;/a&gt;):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit d0a28dee78d099fcadc71147cba4affb6efa0c97
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Wed Jan 21 23:39:51 2015 +0100

    Issue #23095, asyncio: Rewrite _WaitHandleFuture.cancel()
&lt;/pre&gt;
&lt;p&gt;This change fixes a race conditon related to &lt;tt class="docutils literal"&gt;_WaitHandleFuture.cancel()&lt;/tt&gt;
leading to a Python crash or &amp;quot;GetQueuedCompletionStatus() returned an
unexpected event&amp;quot; logs. Previously, &lt;strong&gt;it was possible that the cancelled wait
completes whereas the overlapped object was already destroyed&lt;/strong&gt;. Sometimes, a
different overlapped was allocated at the same address, emitting a log about
unexpected completition (but no crash).&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;_WaitHandleFuture.cancel()&lt;/tt&gt; now &lt;strong&gt;waits until the handle wait is cancelled&lt;/strong&gt;
(until the cancellation completes) before clearing its reference to the
overlapped object. To wait until the cancellation completes,
&lt;tt class="docutils literal"&gt;UnregisterWaitEx()&lt;/tt&gt; is used with an event (instead of using
&lt;tt class="docutils literal"&gt;UnregisterWait()&lt;/tt&gt;).&lt;/p&gt;
&lt;p&gt;To wait for this event, a new &lt;tt class="docutils literal"&gt;_WaitCancelFuture&lt;/tt&gt; class was added. It's a
simplified version of &lt;tt class="docutils literal"&gt;_WaitCancelFuture&lt;/tt&gt;. For example, its &lt;tt class="docutils literal"&gt;cancel()&lt;/tt&gt;
method calls &lt;tt class="docutils literal"&gt;UnregisterWait()&lt;/tt&gt;, not &lt;tt class="docutils literal"&gt;UnregisterWaitEx()&lt;/tt&gt;.
&lt;tt class="docutils literal"&gt;_WaitCancelFuture&lt;/tt&gt; should not be cancelled.&lt;/p&gt;
&lt;p&gt;The overlapped object is &lt;strong&gt;kept alive&lt;/strong&gt; in &lt;tt class="docutils literal"&gt;_WaitHandleFuture&lt;/tt&gt; &lt;strong&gt;until the
wait is unregistered&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Later, I pushed a few more changes to fix corner cases.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/python/cpython/commit/1ca9392c7083972c1953c02e6f2cca54934ce0a6"&gt;commit 1ca9392c&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 1ca9392c7083972c1953c02e6f2cca54934ce0a6
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Thu Jan 22 00:17:54 2015 +0100

    Issue #23095, asyncio: IocpProactor.close() must not cancel pending
    _WaitCancelFuture futures
&lt;/pre&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/python/cpython/commit/752aba7f999b08c833979464a36840de8be0baf0"&gt;commit 752aba7f&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 752aba7f999b08c833979464a36840de8be0baf0
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Thu Jan 22 22:47:13 2015 +0100

    asyncio: IocpProactor.close() doesn't cancel anymore futures which are already
    cancelled
&lt;/pre&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/python/cpython/commit/24dfa3c1d6b21e731bd167a13153968bba8fa5ce"&gt;commit 24dfa3c1&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 24dfa3c1d6b21e731bd167a13153968bba8fa5ce
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Mon Jan 26 22:30:28 2015 +0100

    Issue #23095, asyncio: Fix _WaitHandleFuture.cancel()

    If UnregisterWaitEx() fais with ERROR_IO_PENDING, it doesn't mean that the wait
    is unregistered yet. We still have to wait until the wait is cancelled.
&lt;/pre&gt;
&lt;p&gt;I think that &lt;em&gt;this&lt;/em&gt; issue can now be closed: &lt;tt class="docutils literal"&gt;UnregisterWaitEx()&lt;/tt&gt; really do
what we need in asyncio.&lt;/p&gt;
&lt;p&gt;I don't like the complexity of the IocpProactor._unregister() method and of the
_WaitCancelFuture class, but it looks that it's how we are supposed to wait
until a wait for a handle is cancelled...&lt;/p&gt;
&lt;p&gt;Windows IOCP API is much more complex that what I expected. It's probably
because some parts (especially &lt;tt class="docutils literal"&gt;RegisterWaitForSingleObject()&lt;/tt&gt;) are
implemented with threads in user land, not in the kernel.&lt;/p&gt;
&lt;p&gt;In short, I'm very happy that have fixed this very complex but also very
annoying IOCP bug in asyncio.&lt;/p&gt;
&lt;p&gt;I got a nice comment from &lt;a class="reference external" href="https://bugs.python.org/issue23095#msg234453"&gt;Guido van Rossum&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;strong&gt;Congrats with the fix, and thanks for your perseverance!&lt;/strong&gt;&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="summary-of-the-race-condition"&gt;
&lt;h2&gt;Summary of the race condition&lt;/h2&gt;
&lt;p&gt;Events of the crashing unit test:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;The loop (ProactorEventLoop) spawns a subprocess.&lt;/li&gt;
&lt;li&gt;The loop creates a _WaitHandleFuture object which creates an overlapped to
wait until the process completes (call &lt;tt class="docutils literal"&gt;RegisterWaitForSingleObject()&lt;/tt&gt;):
&lt;strong&gt;allocate&lt;/strong&gt; memory for the overlapped.&lt;/li&gt;
&lt;li&gt;The wait future is cancelled (call &lt;tt class="docutils literal"&gt;UnregisterWait()&lt;/tt&gt;).&lt;/li&gt;
&lt;li&gt;The overlapped is destroyed: &lt;strong&gt;free&lt;/strong&gt; overlapped memory.&lt;/li&gt;
&lt;li&gt;The overlapped completes: &lt;strong&gt;write&lt;/strong&gt; into the overlapped memory.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The main issue is the order of the two last events.&lt;/p&gt;
&lt;p&gt;Sometimes, the overlapped completed before the memory was freed: everything is
fine.&lt;/p&gt;
&lt;p&gt;Sometimes, the overlapped completed after the memory was freed: Python crashed
(segmentation fault).&lt;/p&gt;
&lt;p&gt;Sometimes, another _WaitHandleFuture was created in the meanwhile and created a
second overlapped which was allocated at the same memory address than the freed
memory of the previous overlapped. In this case, when the first overlapped
completes, Python didn't crash but logged an unexpected completion message.&lt;/p&gt;
&lt;p&gt;Sometimes, the write was done in freed memory: the write didn't crash Python,
but caused bugs which didn't make sense.&lt;/p&gt;
&lt;p&gt;There were even more cases causing even more surprising behaviors.&lt;/p&gt;
&lt;p&gt;Summary of the fix:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;(... similar steps for the beginning ...)&lt;/li&gt;
&lt;li&gt;The wait future is cancelled: &lt;strong&gt;create an event&lt;/strong&gt; to wait until the
cancellation completes (call &lt;tt class="docutils literal"&gt;UnregisterWaitEx()&lt;/tt&gt;).&lt;/li&gt;
&lt;li&gt;Wait for the event.&lt;/li&gt;
&lt;li&gt;The event is signalled which means that the cancellation completed: &lt;strong&gt;write&lt;/strong&gt;
into the overlapped memory.&lt;/li&gt;
&lt;li&gt;The overlapped is destroyed: &lt;strong&gt;free&lt;/strong&gt; overlapped memory.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content><category term="cpython"></category><category term="asyncio"></category></entry><entry><title>Locale Bugfixes in Python 3</title><link href="https://vstinner.github.io/locale-bugfixes-python3.html" rel="alternate"></link><published>2019-01-09T00:30:00+01:00</published><updated>2019-01-09T00:30:00+01:00</updated><author><name>Victor Stinner</name></author><id>tag:vstinner.github.io,2019-01-09:/locale-bugfixes-python3.html</id><summary type="html">&lt;p&gt;This article describes a few locales bugs that I fixed in Python 3 between 2012
(Python 3.3) and 2018 (Python 3.7):&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Support non-ASCII decimal point and thousands separator&lt;/li&gt;
&lt;li&gt;Crash with non-ASCII decimal point&lt;/li&gt;
&lt;li&gt;LC_NUMERIC encoding different than LC_CTYPE encoding&lt;/li&gt;
&lt;li&gt;LC_MONETARY encoding different than LC_CTYPE encoding&lt;/li&gt;
&lt;li&gt;Tests non-ASCII locales …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;This article describes a few locales bugs that I fixed in Python 3 between 2012
(Python 3.3) and 2018 (Python 3.7):&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Support non-ASCII decimal point and thousands separator&lt;/li&gt;
&lt;li&gt;Crash with non-ASCII decimal point&lt;/li&gt;
&lt;li&gt;LC_NUMERIC encoding different than LC_CTYPE encoding&lt;/li&gt;
&lt;li&gt;LC_MONETARY encoding different than LC_CTYPE encoding&lt;/li&gt;
&lt;li&gt;Tests non-ASCII locales&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See also my previous locale bugfixes: &lt;a class="reference external" href="https://vstinner.github.io/python3-locales-encodings.html"&gt;Python 3, locales and encodings&lt;/a&gt;&lt;/p&gt;
&lt;a class="reference external image-reference" href="https://www.flickr.com/photos/svensson/40467591/"&gt;&lt;img alt="Unicode Mixed Bag" src="https://vstinner.github.io/images/unicode_bag.jpg" /&gt;&lt;/a&gt;
&lt;div class="section" id="introduction"&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Each language and each country has different ways to represent dates, monetary
values, numbers, etc. Unix has &amp;quot;locales&amp;quot; to configure applications for a
specific language and a specific country. For example, there are &lt;tt class="docutils literal"&gt;fr_BE&lt;/tt&gt; for
Belgium (french) and &lt;tt class="docutils literal"&gt;fr_FR&lt;/tt&gt; for France (french).&lt;/p&gt;
&lt;p&gt;In practice, each locale uses its own encoding and problems arise when an
application uses a different encoding than the locale. There are LC_NUMERIC
locale for numbers, LC_MONETARY locale for monetary and LC_CTYPE for the
encoding. Not only it's possible to configure an application to use LC_NUMERIC
with a different encoding than LC_CTYPE, but some users use such configuration!&lt;/p&gt;
&lt;p&gt;In an application which only uses bytes for text, as Python 2 does mostly, it's
mostly fine: in the worst case, users see &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Mojibake"&gt;mojibake&lt;/a&gt;, but the application doesn't
&amp;quot;crash&amp;quot; (exit and/or data loss). On the other side, &lt;strong&gt;Python 3 is designed to
use Unicode for text and fail with hard Unicode errors if it fails to decode
bytes and fails to encode text&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="support-non-ascii-decimal-point-and-thousands-separator"&gt;
&lt;h2&gt;Support non-ASCII decimal point and thousands separator&lt;/h2&gt;
&lt;p&gt;The Unicode type has been reimplemented in Python 3.3 to use &amp;quot;compact string&amp;quot;:
&lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0393/"&gt;PEP 393 &amp;quot;Flexible String Representation&amp;quot;&lt;/a&gt;. The new implementation is more
complex and the format() function has been limited to ASCII for the decimal
point and thousands separator (format a number using the &amp;quot;n&amp;quot; type).&lt;/p&gt;
&lt;p&gt;In January 2012, Stefan Krah noticed the regression (compared to Python 3.2)
and reported &lt;a class="reference external" href="https://bugs.python.org/issue13706"&gt;bpo-13706&lt;/a&gt;. I fixed the
code to support non-ASCII in format (&lt;a class="reference external" href="https://github.com/python/cpython/commit/a4ac600d6f9c5b74b97b99888b7cf3a7973cadc8"&gt;commit a4ac600d&lt;/a&gt;).
But when I did more tests, I noticed that the &amp;quot;n&amp;quot; type doesn't decode properly
the decimal point and thousands seprator which come from the &lt;tt class="docutils literal"&gt;localeconv()&lt;/tt&gt;
function which uses byte strings.&lt;/p&gt;
&lt;p&gt;I fixed &lt;tt class="docutils literal"&gt;format(int, &amp;quot;n&amp;quot;)&lt;/tt&gt; with &lt;a class="reference external" href="https://github.com/python/cpython/commit/41a863cb81608c779d60b49e7be8a115816734fc"&gt;commit 41a863cb&lt;/a&gt;,
decode decimal point and the thousands separator (&lt;tt class="docutils literal"&gt;localeconv()&lt;/tt&gt; fields) from
the locale encoding, rather than latin1, using &lt;tt class="docutils literal"&gt;PyUnicode_DecodeLocale()&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 41a863cb81608c779d60b49e7be8a115816734fc
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;haypocalc.com&amp;gt;
Date:   Fri Feb 24 00:37:51 2012 +0100

    Issue #13706: Fix format(int, &amp;quot;n&amp;quot;) for locale with non-ASCII thousands separator

     * Decode thousands separator and decimal point using PyUnicode_DecodeLocale()
       (from the locale encoding), instead of decoding them implicitly from latin1
     * Remove _PyUnicode_InsertThousandsGroupingLocale(), it was not used
     * Change _PyUnicode_InsertThousandsGrouping() API to return the maximum
       character if unicode is NULL
     * (...)
&lt;/pre&gt;
&lt;p&gt;Note: I decided to not fix Python 3.2:&lt;/p&gt;
&lt;blockquote&gt;
Hum, &lt;strong&gt;it is not trivial to redo the work on Python 3.2&lt;/strong&gt;. I prefer to leave
the code unchanged to not introduce a regression, and I wait until a Python
3.2 user complains (the bug exists since Python 3.0 and nobody complained).&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="crash-with-non-ascii-decimal-point"&gt;
&lt;h2&gt;Crash with non-ASCII decimal point&lt;/h2&gt;
&lt;p&gt;Six years later, in June 2018, I noticed that Python does crash when running
tests on locales:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ./python
Python 3.8.0a0 (heads/master-dirty:bcd3a1a18d, Jun 23 2018, 10:31:03)
[GCC 8.1.1 20180502 (Red Hat 8.1.1-1)] on linux
&amp;gt;&amp;gt;&amp;gt; import locale
&amp;gt;&amp;gt;&amp;gt; locale.str(2.5)
'2.5'
&amp;gt;&amp;gt;&amp;gt; '{:n}'.format(2.5)
'2.5'

&amp;gt;&amp;gt;&amp;gt; locale.setlocale(locale.LC_ALL, '')
'fr_FR.UTF-8'
&amp;gt;&amp;gt;&amp;gt; locale.str(2.5)
'2,5'
&amp;gt;&amp;gt;&amp;gt; '{:n}'.format(2.5)
python: Objects/unicodeobject.c:474: _PyUnicode_CheckConsistency: Assertion `maxchar &amp;lt; 128' failed.
Aborted (core dumped)
&lt;/pre&gt;
&lt;p&gt;I reported the issue as &lt;a class="reference external" href="https://bugs.python.org/issue33954"&gt;bpo-33954&lt;/a&gt;. The
bug only occurrs for decimal point larger than U+00FF (code point greater than
255). It was a bug in my &lt;a class="reference external" href="https://bugs.python.org/issue13706"&gt;bpo-13706&lt;/a&gt;
fix: &lt;a class="reference external" href="https://github.com/python/cpython/commit/a4ac600d6f9c5b74b97b99888b7cf3a7973cadc8"&gt;commit a4ac600d&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I pushed a second fix to properly support all cases, &lt;a class="reference external" href="https://github.com/python/cpython/commit/59423e3ddd736387cef8f7632c71954c1859bed0"&gt;commit 59423e3d&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 59423e3ddd736387cef8f7632c71954c1859bed0
Author: Victor Stinner &amp;lt;vstinner&amp;#64;redhat.com&amp;gt;
Date:   Mon Nov 26 13:40:01 2018 +0100

    bpo-33954: Fix _PyUnicode_InsertThousandsGrouping() (GH-10623)

    Fix str.format(), float.__format__() and complex.__format__() methods
    for non-ASCII decimal point when using the &amp;quot;n&amp;quot; formatter.

    Changes:

    * Rewrite _PyUnicode_InsertThousandsGrouping(): it now requires
      a _PyUnicodeWriter object for the buffer and a Python str object
      for digits.
    * Rename FILL() macro to unicode_fill(), convert it to static inline function,
      add &amp;quot;assert(0 &amp;lt;= start);&amp;quot; and rework its code.
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="lc-numeric-encoding-different-than-lc-ctype-encoding"&gt;
&lt;h2&gt;LC_NUMERIC encoding different than LC_CTYPE encoding&lt;/h2&gt;
&lt;p&gt;In August 2017, Petr Viktorin identified a bug in Koji (server building Fedora
packages): &lt;a class="reference external" href="https://bugzilla.redhat.com/show_bug.cgi?id=1484497"&gt;UnicodeDecodeError in localeconv() makes test_float fail in Koji&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&amp;quot;This is tripped by Python's test suite, namely
test_float.GeneralFloatCases.test_float_with_comma&amp;quot;&lt;/blockquote&gt;
&lt;p&gt;He wrote a short reproducer script:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
import locale
locale.setlocale(locale.LC_ALL, 'C.UTF-8')
locale.setlocale(locale.LC_NUMERIC, 'fr_FR.ISO8859-1')
print(locale.localeconv())
&lt;/pre&gt;
&lt;p&gt;Two months later, Charalampos Stratakis reported the bug upstream: &lt;a class="reference external" href="https://bugs.python.org/issue31900"&gt;bpo-31900&lt;/a&gt;.  The problem arises when &lt;strong&gt;the
LC_NUMERIC locale uses a different encoding than the LC_CTYPE encoding&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The bug was already known:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;2015-12-05: Serhiy Storchaka reported &lt;a class="reference external" href="https://bugs.python.org/issue25812"&gt;bpo-25812&lt;/a&gt; with uk_UA locale&lt;/li&gt;
&lt;li&gt;2016-11-03: Guillaume Pasquet reported &lt;a class="reference external" href="https://bugs.python.org/issue28604"&gt;bpo-28604&lt;/a&gt; with en_GB locale&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Moreover, &lt;strong&gt;the bug was known since 2009&lt;/strong&gt;, Stefan Krah reported a very similar
bug: &lt;a class="reference external" href="https://bugs.python.org/issue7442"&gt;bpo-7442&lt;/a&gt;. I was even involved in
this issue in 2013, but then I forgot about it (as usual, I am working on too
many issues in parallel :-)).&lt;/p&gt;
&lt;p&gt;In 2010, PostgreSQL &lt;a class="reference external" href="https://www.postgresql.org/message-id/20100422015552.4B7E07541D0&amp;#64;cvs.postgresql.org"&gt;had the same issue&lt;/a&gt;
and &lt;a class="reference external" href="https://anoncvs.postgresql.org/cvsweb.cgi/pgsql/src/backend/utils/adt/pg_locale.c?r1=1.53&amp;amp;r2=1.54"&gt;fixed the bug by changing temporarily the LC_CTYPE locale to the
LC_NUMERIC locale&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In January 2018, I came back to this 9 years old bug. I was fixing bugs in the
implementation of my &lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0540/"&gt;PEP 540 &amp;quot;Add a new UTF-8 Mode&amp;quot;&lt;/a&gt;. I pushed a large change to fix
locale encodings in &lt;a class="reference external" href="https://bugs.python.org/issue29240"&gt;bpo-29240&lt;/a&gt;, &lt;a class="reference external" href="https://github.com/python/cpython/commit/7ed7aead9503102d2ed316175f198104e0cd674c"&gt;commit
7ed7aead&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 7ed7aead9503102d2ed316175f198104e0cd674c
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Mon Jan 15 10:45:49 2018 +0100

    bpo-29240: Fix locale encodings in UTF-8 Mode (#5170)

    Modify locale.localeconv(), time.tzname, os.strerror() and other
    functions to ignore the UTF-8 Mode: always use the current locale
    encoding.

    Changes: (...)
&lt;/pre&gt;
&lt;p&gt;Stefan Krah asked:&lt;/p&gt;
&lt;blockquote&gt;
I have the exact same questions as Marc-Andre.  This is one of the reasons
why I blocked the _decimal change.  I don't fully understand the role of the
new glibc, since #7442 has existed for ages -- and &lt;strong&gt;it is a open question
whether it is a bug or not&lt;/strong&gt;.&lt;/blockquote&gt;
&lt;p&gt;I replied:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Past 10 years, I repeated to every single user I met that &amp;quot;Python 3 is
right, your system setup is wrong&amp;quot;. But that's a waste of time. People
continue to associate Python3 and Unicode to annoying bugs, because they
don't understand how locales work.&lt;/p&gt;
&lt;p&gt;Instead of having to repeat to each user that &amp;quot;hum, maybe your config is
wrong&amp;quot;, &lt;strong&gt;I prefer to support this non convential setup and work as expected
(&amp;quot;it just works&amp;quot;)&lt;/strong&gt;. With my latest implementation, setlocale() is only done
when LC_CTYPE and LC_NUMERIC are different, which is the corner case which
&amp;quot;shouldn't occur in practice&amp;quot;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Marc-Andre Lemburg added:&lt;/p&gt;
&lt;blockquote&gt;
Sounds like a good compromise :-)&lt;/blockquote&gt;
&lt;p&gt;After doing more tests on FreeBSD, Linux and macOS, I pushed &lt;a class="reference external" href="https://github.com/python/cpython/commit/cb064fc2321ce8673fe365e9ef60445a27657f54"&gt;commit cb064fc2&lt;/a&gt;
to fix &lt;a class="reference external" href="https://bugs.python.org/issue31900"&gt;bpo-31900&lt;/a&gt; by changing
temporarily the LC_CTYPE locale to the LC_NUMERIC locale:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit cb064fc2321ce8673fe365e9ef60445a27657f54
Author: Victor Stinner &amp;lt;victor.stinner&amp;#64;gmail.com&amp;gt;
Date:   Mon Jan 15 15:58:02 2018 +0100

    bpo-31900: Fix localeconv() encoding for LC_NUMERIC (#4174)

    * Add _Py_GetLocaleconvNumeric() function: decode decimal_point and
      thousands_sep fields of localeconv() from the LC_NUMERIC encoding,
      rather than decoding from the LC_CTYPE encoding.
    * Modify locale.localeconv() and &amp;quot;n&amp;quot; formatter of str.format() (for
      int, float and complex to use _Py_GetLocaleconvNumeric()
      internally.
&lt;/pre&gt;
&lt;p&gt;I dislike my own fix because changing temporarily the LC_CTYPE locale impacts
all threads, not only the current thread. But we failed to find another
solution. &lt;strong&gt;The LC_CTYPE locale is only changed if the LC_NUMERIC locale is
different than the LC_CTYPE locale and if the decimal point or the thousands
separator is non-ASCII.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Note: I proposed a change to fix the same bug in the &lt;tt class="docutils literal"&gt;decimal&lt;/tt&gt; module: &lt;a class="reference external" href="https://github.com/python/cpython/pull/5191"&gt;PR
#5191&lt;/a&gt;, but I abandonned my
patch.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="lc-monetary-encoding-different-than-lc-ctype-encoding"&gt;
&lt;h2&gt;LC_MONETARY encoding different than LC_CTYPE encoding&lt;/h2&gt;
&lt;p&gt;Fixing &lt;a class="reference external" href="https://bugs.python.org/issue31900"&gt;bpo-31900&lt;/a&gt; drained all my
energy, but sadly... there was a similar bug with LC_MONETARY!&lt;/p&gt;
&lt;p&gt;At 2016-11-03, Guillaume Pasquet reported &lt;a class="reference external" href="https://bugs.python.org/issue28604"&gt;bpo-28604: Exception raised by
python3.5 when using en_GB locale&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The fix is similar to the LC_NUMERIC fix: change temporarily the LC_CTYPE
locale to the LC_MONETARY locale, &lt;a class="reference external" href="https://github.com/python/cpython/commit/02e6bf7f2025cddcbde6432f6b6396198ab313f4"&gt;commit 02e6bf7f&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
commit 02e6bf7f2025cddcbde6432f6b6396198ab313f4
Author: Victor Stinner &amp;lt;vstinner&amp;#64;redhat.com&amp;gt;
Date:   Tue Nov 20 16:20:16 2018 +0100

    bpo-28604: Fix localeconv() for different LC_MONETARY (GH-10606)

    locale.localeconv() now sets temporarily the LC_CTYPE locale to the
    LC_MONETARY locale if the two locales are different and monetary
    strings are non-ASCII. This temporary change affects other threads.

    Changes:

    * locale.localeconv() can now set LC_CTYPE to LC_MONETARY to decode
      monetary fields.
    * (...)
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="tests-non-ascii-locales"&gt;
&lt;h2&gt;Tests non-ASCII locales&lt;/h2&gt;
&lt;p&gt;To test my bugfixes, I used manual tests. The first issue was to identify
locales with problematic characters: non-ASCII decimal point or thousands
separator for example. I wrote my own &amp;quot;test suite&amp;quot; for Windows, Linux, macOS
and FreeBSD on my website: &lt;a class="reference external" href="https://vstinner.readthedocs.io/unicode.html#test-non-ascii-characters-with-locales"&gt;Test non-ASCII characters with locales&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Example with localeconv() on Fedora 27:&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="15%" /&gt;
&lt;col width="8%" /&gt;
&lt;col width="16%" /&gt;
&lt;col width="25%" /&gt;
&lt;col width="36%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;LC_ALL locale&lt;/th&gt;
&lt;th class="head"&gt;Encoding&lt;/th&gt;
&lt;th class="head"&gt;Field&lt;/th&gt;
&lt;th class="head"&gt;Bytes&lt;/th&gt;
&lt;th class="head"&gt;Text&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;es_MX.utf8&lt;/td&gt;
&lt;td&gt;UTF-8&lt;/td&gt;
&lt;td&gt;thousands_sep&lt;/td&gt;
&lt;td&gt;&lt;tt class="docutils literal"&gt;0xE2 0x80 0x89&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;U+2009&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;fr_FR.UTF-8&lt;/td&gt;
&lt;td&gt;UTF-8&lt;/td&gt;
&lt;td&gt;currency_symbol&lt;/td&gt;
&lt;td&gt;&lt;tt class="docutils literal"&gt;0xE2 0x82 0xAC&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;U+20AC (€)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ps_AF.utf8&lt;/td&gt;
&lt;td&gt;UTF-8&lt;/td&gt;
&lt;td&gt;thousands_sep&lt;/td&gt;
&lt;td&gt;&lt;tt class="docutils literal"&gt;0xD9 0xAC&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;U+066C (٬)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;uk_UA.koi8u&lt;/td&gt;
&lt;td&gt;KOI8-U&lt;/td&gt;
&lt;td&gt;currency_symbol&lt;/td&gt;
&lt;td&gt;&lt;tt class="docutils literal"&gt;0xC7 0xD2 0xCE 0x2E&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;U+0433 U+0440 U+043d U+002E (грн.)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;uk_UA.koi8u&lt;/td&gt;
&lt;td&gt;KOI8-U&lt;/td&gt;
&lt;td&gt;thousands_sep&lt;/td&gt;
&lt;td&gt;&lt;tt class="docutils literal"&gt;0x9A&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;U+00A0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Manual tests became more and more complex, since there are so many cases: each
operating system use different locale names and the result depends on the libc
version. After months of manual tests, I wrote my small personal &lt;strong&gt;portable&lt;/strong&gt;
locale test suite: &lt;a class="reference external" href="https://github.com/vstinner/misc/blob/master/python/test_all_locales.py"&gt;test_all_locales.py&lt;/a&gt;.
It supports:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;FreeBSD 11&lt;/li&gt;
&lt;li&gt;macOS&lt;/li&gt;
&lt;li&gt;Fedora (Linux)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
def test_zh_TW_Big5(self):
    loc = &amp;quot;zh_TW.Big5&amp;quot; if BSD else &amp;quot;zh_TW.big5&amp;quot;
    if FREEBSD:
        currency_symbol = u'\uff2e\uff34\uff04'
        decimal_point = u'\uff0e'
        thousands_sep = u'\uff0c'
        date_str = u'\u661f\u671f\u56db 2\u6708'
    else:
        currency_symbol = u'NT$'
        decimal_point = u'.'
        thousands_sep = u','
        if MACOS:
            date_str =  u'\u9031\u56db 2\u6708'
        else:
            date_str = u'\u9031\u56db \u4e8c\u6708'

    self.set_locale(loc, &amp;quot;Big5&amp;quot;)

    lc = locale.localeconv()
    self.assertLocaleEqual(lc['currency_symbol'], currency_symbol)
    self.assertLocaleEqual(lc['decimal_point'], decimal_point)
    self.assertLocaleEqual(lc['thousands_sep'], thousands_sep)

    self.assertLocaleEqual(time.strftime('%A %B', FEBRUARY), date_str)
&lt;/pre&gt;
&lt;p&gt;The best would be to integrate directly these tests into the Python test suite,
but it's not portable nor future-proof, since most constants are hardcoded and
depends on the operating sytem and the libc version.&lt;/p&gt;
&lt;/div&gt;
</content><category term="cpython"></category><category term="unicode"></category><category term="locales"></category></entry><entry><title>Python 3, locales and encodings</title><link href="https://vstinner.github.io/python3-locales-encodings.html" rel="alternate"></link><published>2018-09-06T16:00:00+02:00</published><updated>2018-09-06T16:00:00+02:00</updated><author><name>Victor Stinner</name></author><id>tag:vstinner.github.io,2018-09-06:/python3-locales-encodings.html</id><summary type="html">&lt;p&gt;Recently, I worked on a change which looked simple: move the code to initialize
the &lt;tt class="docutils literal"&gt;sys.stdout&lt;/tt&gt; encoding before &lt;tt class="docutils literal"&gt;Py_Initialize()&lt;/tt&gt;. While I was on it,
I also decided to move the code which selects the Python &amp;quot;filesystem encoding&amp;quot;.
I didn't expect that I would spend 2 weeks on these issues …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Recently, I worked on a change which looked simple: move the code to initialize
the &lt;tt class="docutils literal"&gt;sys.stdout&lt;/tt&gt; encoding before &lt;tt class="docutils literal"&gt;Py_Initialize()&lt;/tt&gt;. While I was on it,
I also decided to move the code which selects the Python &amp;quot;filesystem encoding&amp;quot;.
I didn't expect that I would spend 2 weeks on these issues... This article
tells me about my recent journey in locales and encodings on AIX, HP-UX,
Windows, Linux, macOS, Solaris and FreeBSD.&lt;/p&gt;
&lt;img alt="I □ Unicode" src="https://vstinner.github.io/images/i-square-unicode.jpg" /&gt;
&lt;p&gt;Table of Contents:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Lying HP-UX&lt;/li&gt;
&lt;li&gt;Standard streams and filesystem encodings&lt;/li&gt;
&lt;li&gt;POSIX locale on FreeBSD&lt;/li&gt;
&lt;li&gt;C locale on Windows&lt;/li&gt;
&lt;li&gt;Back to stdio encoding&lt;/li&gt;
&lt;li&gt;Back to filesystem encoding&lt;/li&gt;
&lt;li&gt;Use surrogatepass on Windows&lt;/li&gt;
&lt;li&gt;Filesystem encoding documentation&lt;/li&gt;
&lt;li&gt;Final FreeBSD 10 issue&lt;/li&gt;
&lt;li&gt;Configuration of locales and encodings&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="lying-hp-ux"&gt;
&lt;h2&gt;Lying HP-UX&lt;/h2&gt;
&lt;p&gt;At 2018-08-14, Michael Osipov reported &lt;a class="reference external" href="https://bugs.python.org/issue34403"&gt;bpo-34403&lt;/a&gt;:
&amp;quot;test_utf8_mode.test_cmd_line() fails on HP-UX due to false assumptions&amp;quot;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
======================================================================
FAIL: test_cmd_line (test.test_utf8_mode.UTF8ModeTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  (...)
AssertionError: &amp;quot;['h\\xc3\\xa9\\xe2\\x82\\xac']&amp;quot; != &amp;quot;['h\\udcc3\\udca9\\udce2\\udc82\\udcac']&amp;quot;
- ['h\xc3\xa9\xe2\x82\xac']
+ ['h\udcc3\udca9\udce2\udc82\udcac']
 : roman8:['h\xc3\xa9\xe2\x82\xac']
&lt;/pre&gt;
&lt;p&gt;Interesting, HP-UX uses &amp;quot;roman8&amp;quot; as its locale encoding. What is this &amp;quot;new&amp;quot;
encoding? Wikipedia: &lt;a class="reference external" href="https://en.wikipedia.org/wiki/HP_Roman#Roman-8"&gt;HP Roman-8&lt;/a&gt;. Oh, that's even older than
the common ISO 8859 encodings like Latin1!&lt;/p&gt;
&lt;p&gt;Michael Felt was working on a similar test_utf8_mode failure on AIX, so they
tried to debug the issue together, but failed to understand the issue. Osipov
proposed to give up and just skip the test on HP-UX...&lt;/p&gt;
&lt;p&gt;I showed up and proposed a fix for the unit test: &lt;a class="reference external" href="https://github.com/python/cpython/pull/8967/files"&gt;PR 8967&lt;/a&gt;. The test was hardcoding
the expected locale encoding. I modified the test to query the locale encoding
at runtime instead.&lt;/p&gt;
&lt;p&gt;Bad surprise, the test still fails, oh. &lt;a class="reference external" href="https://bugs.python.org/issue34403#msg324219"&gt;I commented&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
Hum, it looks like a bug in the C library of HP-UX.&lt;/blockquote&gt;
&lt;p&gt;I wrote a C program calling mbstowcs() to check what is the actual encoding
used by the C library: &lt;a class="reference external" href="https://bugs.python.org/file47767/c_locale.c"&gt;c_locale.c&lt;/a&gt;. &lt;a class="reference external" href="https://bugs.python.org/issue34403#msg324225"&gt;Result&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
Well, it confirms what I expected: &lt;tt class="docutils literal"&gt;nl_langinfo(CODESET)&lt;/tt&gt; announces
&lt;tt class="docutils literal"&gt;&amp;quot;roman8&amp;quot;&lt;/tt&gt;, but &lt;tt class="docutils literal"&gt;mbstowcs()&lt;/tt&gt; uses Latin1 encoding in practice.&lt;/blockquote&gt;
&lt;p&gt;So I wrote a workaround similar to the one used on FreeBSD and Solaris: check
if the libc is announcing an encoding different than the real encoding, and if
it's the case: force the usage of the ASCII encoding in Python. See
my &lt;a class="reference external" href="https://github.com/python/cpython/commit/d500e5307aec9c5d535f66d567fadb9c587a9a36"&gt;commit d500e530&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Author: Victor Stinner &amp;lt;vstinner&amp;#64;redhat.com&amp;gt;
Date:   Tue Aug 28 17:27:36 2018 +0200

    bpo-34403: On HP-UX, force ASCII for C locale (GH-8969)

    On HP-UX with C or POSIX locale, sys.getfilesystemencoding() now returns
    &amp;quot;ascii&amp;quot; instead of &amp;quot;roman8&amp;quot; (when the UTF-8 Mode is disabled and the C locale
    is not coerced).

    nl_langinfo(CODESET) announces &amp;quot;roman8&amp;quot; whereas it uses the Latin1
    encoding in practice.
&lt;/pre&gt;
&lt;p&gt;Extract of the heuristic code:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
if (strcmp(encoding, &amp;quot;roman8&amp;quot;) == 0) {
    unsigned char ch = (unsigned char)0xA7;
    wchar_t wch;
    size_t res = mbstowcs(&amp;amp;wch, (char*)&amp;amp;ch, 1);
    if (res != (size_t)-1 &amp;amp;&amp;amp; wch == L'\xA7') {
        /* On HP-UX withe C locale or the POSIX locale,
           nl_langinfo(CODESET) announces &amp;quot;roman8&amp;quot;,
           whereas mbstowcs() uses Latin1 encoding in practice.
           Force ASCII in this case.  Roman8 decodes 0xA7
           to U+00CF. Latin1 decodes 0xA7 to U+00A7. */
        return 1;
    }
}
&lt;/pre&gt;
&lt;p&gt;Python 3.8 will handle better Unicode support on HP-UX. The test_utf8_mode
failure was just a hint for a real underlying bug!&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="standard-streams-and-filesystem-encodings"&gt;
&lt;h2&gt;Standard streams and filesystem encodings&lt;/h2&gt;
&lt;p&gt;While reworking the Python initialization, I tried to move &lt;strong&gt;all&lt;/strong&gt;
configuration parameters to a new &lt;tt class="docutils literal"&gt;_PyCoreConfig&lt;/tt&gt; structure. But I know that
I missed at least the standard streams encoding (ex: &lt;tt class="docutils literal"&gt;sys.stdout.encoding&lt;/tt&gt;).
My first attempt failed to move the code, it broke many tests. I created
&lt;a class="reference external" href="https://bugs.python.org/issue34485"&gt;bpo-34485&lt;/a&gt;: &amp;quot;_PyCoreConfig: add
stdio_encoding and stdio_errors&amp;quot;.&lt;/p&gt;
&lt;p&gt;While I was working on stdio encoding, I also recalled that the Python
filesystem encoding is also initialized &amp;quot;late&amp;quot;. I also created &lt;a class="reference external" href="https://bugs.python.org/issue34523"&gt;bpo-34523&lt;/a&gt;: &amp;quot;Choose the filesystem encoding before
Python initialization (add _PyCoreConfig.filesystem_encoding)&amp;quot; to move this
code as well.&lt;/p&gt;
&lt;p&gt;I quickly had an implementation, but it didn't go as well as expected...&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="posix-locale-on-freebsd"&gt;
&lt;h2&gt;POSIX locale on FreeBSD&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="https://bugs.python.org/issue34485"&gt;bpo-34485&lt;/a&gt;: For me, the &amp;quot;C&amp;quot; and &amp;quot;POSIX&amp;quot;
locales were the same locale: C is an alias to POSIX, or the opposite, it
didn't really matter for me. But Python handles them differently in some corner
cases. For example, Nick Coghlan's PEP 538 (C locale coercion) is only enabled
if the LC_CTYPE locale is equal to &amp;quot;C&amp;quot;, not if it's equal to &amp;quot;POSIX&amp;quot;.&lt;/p&gt;
&lt;p&gt;In Python 3.5, I changed stdin and stdout error handlers from strict to
surrogateescape if the LC_CTYPE locale is &amp;quot;C&amp;quot;: &lt;a class="reference external" href="https://bugs.python.org/issue19977"&gt;bpo-19977&lt;/a&gt;. But when I tested my
stdio and filesystem changes on Linux, FreeBSD and Windows, I noticed that
I forgot to handle the &amp;quot;POSIX&amp;quot; locale. On FreeBSD, &lt;tt class="docutils literal"&gt;LC_ALL=POSIX&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;LC_ALL=C&lt;/tt&gt;
behave differently:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;With &lt;tt class="docutils literal"&gt;LC_ALL=POSIX&lt;/tt&gt; environment, &lt;tt class="docutils literal"&gt;setlocale(LC_CTYPE, &amp;quot;&amp;quot;)&lt;/tt&gt; returns &lt;tt class="docutils literal"&gt;&amp;quot;POSIX&amp;quot;&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;With &lt;tt class="docutils literal"&gt;LC_ALL=C&lt;/tt&gt; environment, &lt;tt class="docutils literal"&gt;setlocale(LC_CTYPE, &amp;quot;&amp;quot;)&lt;/tt&gt; returns &lt;tt class="docutils literal"&gt;&amp;quot;C&amp;quot;&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I fixed that to also use the &amp;quot;surrogateescape&amp;quot; error handler for the POSIX
locale on FreeBSD. &lt;a class="reference external" href="https://github.com/python/cpython/commit/315877dc361d554bec34b4b62c270479ad36a1be"&gt;Commit 315877dc&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Author: Victor Stinner &amp;lt;vstinner&amp;#64;redhat.com&amp;gt;
Date:   Wed Aug 29 09:58:12 2018 +0200

    bpo-34485: stdout uses surrogateescape on POSIX locale (GH-8986)

    Standard streams like sys.stdout now use the &amp;quot;surrogateescape&amp;quot; error
    handler, instead of &amp;quot;strict&amp;quot;, on the POSIX locale (when the C locale is not
    coerced and the UTF-8 Mode is disabled).

    Add tests on sys.stdout.errors with LC_ALL=POSIX.
&lt;/pre&gt;
&lt;p&gt;The most important change is just one line:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
-        if (strcmp(ctype_loc, &amp;quot;C&amp;quot;) == 0) {
+        if (strcmp(ctype_loc, &amp;quot;C&amp;quot;) == 0 || strcmp(ctype_loc, &amp;quot;POSIX&amp;quot;) == 0) {
             return &amp;quot;surrogateescape&amp;quot;;
         }
&lt;/pre&gt;
&lt;p&gt;&lt;a class="reference external" href="https://bugs.python.org/issue34527"&gt;bpo-34527&lt;/a&gt;: Since I was testing
various configurations, I also noticed that my UTF-8 Mode (PEP 540) had the
same bug. Python 3.7 enables it if the LC_CTYPE locale is equal to &amp;quot;C&amp;quot;,
but not if it's equal to &amp;quot;POSIX&amp;quot;. I also changed that (&lt;a class="reference external" href="https://github.com/python/cpython/commit/5cb258950ce9b69b1f65646431c464c0c17b1510"&gt;commit 5cb25895&lt;/a&gt;).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="c-locale-on-windows"&gt;
&lt;h2&gt;C locale on Windows&lt;/h2&gt;
&lt;p&gt;While testing my changes on Windows, I noticed that Python starts with the
LC_CTYPE locale equal to &amp;quot;C&amp;quot;, whereas &lt;tt class="docutils literal"&gt;locale.setlocale(locale.LC_CTYPE, &amp;quot;&amp;quot;)&lt;/tt&gt;
changes the LC_CTYPE locale to something like &lt;tt class="docutils literal"&gt;English_United States.1252&lt;/tt&gt;
(English with the code page 1252). Example with Python 3.6:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
C:\&amp;gt; python
Python 3.6.4 (v3.6.4:d48eceb, Dec 19 2017, 06:54:40) [MSC v.1900 64 bit (AMD64)] on win32
&amp;gt;&amp;gt;&amp;gt; import locale
&amp;gt;&amp;gt;&amp;gt; locale.setlocale(locale.LC_CTYPE, None)
'C'
&amp;gt;&amp;gt;&amp;gt; locale.setlocale(locale.LC_CTYPE, &amp;quot;&amp;quot;)
'English_United States.1252'
&amp;gt;&amp;gt;&amp;gt; locale.setlocale(locale.LC_CTYPE, None)
'English_United States.1252'
&lt;/pre&gt;
&lt;p&gt;On UNIX, Python 2 starts with the default C locale, whereas Python 3 always
sets the LC_CTYPE locale to my preference. Example on Fedora 28 with
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;LANG=fr_FR.UTF-8&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ python2 -c 'import locale; print(locale.setlocale(locale.LC_CTYPE, None))'
C
$ python3 -c 'import locale; print(locale.setlocale(locale.LC_CTYPE, None))'
fr_FR.UTF-8
&lt;/pre&gt;
&lt;p&gt;I modified Windows to behave as UNIX, &lt;a class="reference external" href="https://github.com/python/cpython/commit/177d921c8c03d30daa32994362023f777624b10d"&gt;commit 177d921c&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Author: Victor Stinner &amp;lt;vstinner&amp;#64;redhat.com&amp;gt;
Date:   Wed Aug 29 11:25:15 2018 +0200

    bpo-34485, Windows: LC_CTYPE set to user preference (GH-8988)

    On Windows, the LC_CTYPE is now set to the user preferred locale at
    startup: _Py_SetLocaleFromEnv(LC_CTYPE) is now called during the
    Python initialization. Previously, the LC_CTYPE locale was &amp;quot;C&amp;quot; at
    startup, but changed when calling setlocale(LC_CTYPE, &amp;quot;&amp;quot;) or
    setlocale(LC_ALL, &amp;quot;&amp;quot;).

    pymain_read_conf() now also calls _Py_SetLocaleFromEnv(LC_CTYPE) to
    behave as _Py_InitializeCore(). Moreover, it doesn't save/restore the
    LC_ALL anymore.

    On Windows, standard streams like sys.stdout now always use
    surrogateescape error handler by default (ignore the locale).
&lt;/pre&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
C:\&amp;gt; python3.6 -c &amp;quot;import locale; print(locale.setlocale(locale.LC_CTYPE, None))&amp;quot;
C
C:\&amp;gt; python3.8 -c &amp;quot;import locale; print(locale.setlocale(locale.LC_CTYPE, None))&amp;quot;
English_United States.1252
&lt;/pre&gt;
&lt;p&gt;On Windows, Python 3.8 now starts with the LC_CTYPE locale set to my
preference, as it was already previously done on UNIX.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="back-to-stdio-encoding"&gt;
&lt;h2&gt;Back to stdio encoding&lt;/h2&gt;
&lt;p&gt;After all previous changes and fixes, I was able to push my &lt;a class="reference external" href="https://github.com/python/cpython/commit/dfe0dc74536dfb6f331131d9b2b49557675bb6b7"&gt;commit dfe0dc74&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Author: Victor Stinner &amp;lt;vstinner&amp;#64;redhat.com&amp;gt;
Date:   Wed Aug 29 11:47:29 2018 +0200

    bpo-34485: Add _PyCoreConfig.stdio_encoding (GH-8881)

    * Add stdio_encoding and stdio_errors fields to _PyCoreConfig.
    * Add unit tests on stdio_encoding and stdio_errors.
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="back-to-filesystem-encoding"&gt;
&lt;h2&gt;Back to filesystem encoding&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/python/cpython/commit/b2457efc78b74a1d6d1b77d11a939e886b8a4e2c"&gt;Commit b2457efc&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Author: Victor Stinner &amp;lt;vstinner&amp;#64;redhat.com&amp;gt;
Date:   Wed Aug 29 13:25:36 2018 +0200

    bpo-34523: Add _PyCoreConfig.filesystem_encoding (GH-8963)

    _PyCoreConfig_Read() is now responsible to choose the filesystem
    encoding and error handler. Using Py_Main(), the encoding is now
    chosen even before calling Py_Initialize().

    _PyCoreConfig.filesystem_encoding is now the reference, instead of
    Py_FileSystemDefaultEncoding, for the Python filesystem encoding.

    Changes:

    * Add filesystem_encoding and filesystem_errors to _PyCoreConfig
    * _PyCoreConfig_Read() now reads the locale encoding for the file
      system encoding.
    * PyUnicode_EncodeFSDefault() and PyUnicode_DecodeFSDefaultAndSize()
      now use the interpreter configuration rather than
      Py_FileSystemDefaultEncoding and Py_FileSystemDefaultEncodeErrors
      global configuration variables.
    * Add _Py_SetFileSystemEncoding() and _Py_ClearFileSystemEncoding()
      private functions to only modify Py_FileSystemDefaultEncoding and
      Py_FileSystemDefaultEncodeErrors in coreconfig.c.
    * _Py_CoerceLegacyLocale() now takes an int rather than
      _PyCoreConfig for the warning.
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="use-surrogatepass-on-windows"&gt;
&lt;h2&gt;Use surrogatepass on Windows&lt;/h2&gt;
&lt;p&gt;While working on the filesystem encoding change, I had a bug in
_freeze_importlib.exe which failed at startup:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ValueError: only 'strict' and 'surrogateescape' error handlers are supported, not 'surrogatepass'
&lt;/pre&gt;
&lt;p&gt;I used the following workaround in &lt;tt class="docutils literal"&gt;_freeze_importlib.c&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#ifdef MS_WINDOWS
    /* bpo-34523: initfsencoding() is not called if _install_importlib=0,
       so interp-&amp;gt;fscodec_initialized value remains 0.
       PyUnicode_EncodeFSDefault() doesn't support the &amp;quot;surrogatepass&amp;quot; error
       handler in such case, whereas it's the default error handler on Windows.
       Force the &amp;quot;strict&amp;quot; error handler to work around this bootstrap issue. */
    config.filesystem_errors = &amp;quot;strict&amp;quot;;
#endif
&lt;/pre&gt;
&lt;p&gt;But I wasn't fully happy with the workaround. When running more manual tests, I
found that the &lt;tt class="docutils literal"&gt;PYTHONLEGACYWINDOWSFSENCODING&lt;/tt&gt; environment variable wasn't
handled properly. I pushed a first fix,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/c5989cd87659acbfd4d19dc00dbe99c3a0fc9bd2"&gt;commit c5989cd8&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Author: Victor Stinner &amp;lt;vstinner&amp;#64;redhat.com&amp;gt;
Date:   Wed Aug 29 19:32:47 2018 +0200

    bpo-34523: Py_DecodeLocale() use UTF-8 on Windows (GH-8998)

    Py_DecodeLocale() and Py_EncodeLocale() now use the UTF-8 encoding on
    Windows if Py_LegacyWindowsFSEncodingFlag is zero.

    pymain_read_conf() now sets Py_LegacyWindowsFSEncodingFlag in its
    loop, but restore its value at exit.
&lt;/pre&gt;
&lt;p&gt;My intent was to be able to use the &lt;tt class="docutils literal"&gt;surrogatepass&lt;/tt&gt; error handler. If
&lt;tt class="docutils literal"&gt;Py_DecodeLocale()&lt;/tt&gt; is hardcoded to use UTF-8 on Windows, we should get
access to the &lt;tt class="docutils literal"&gt;surrogatepass&lt;/tt&gt; error handler. Previously, &lt;tt class="docutils literal"&gt;mbstowcs()&lt;/tt&gt;
function was used and this function only support &lt;tt class="docutils literal"&gt;strict&lt;/tt&gt; or
&lt;tt class="docutils literal"&gt;surrogateescape&lt;/tt&gt; error handlers.&lt;/p&gt;
&lt;p&gt;I pushed a second big change to add support for the &lt;tt class="docutils literal"&gt;surrogatepass&lt;/tt&gt; error
handler in locale codecs, &lt;a class="reference external" href="https://github.com/python/cpython/commit/3d4226a832cabc630402589cc671cc4035d504e5"&gt;commit 3d4226a8&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Author: Victor Stinner &amp;lt;vstinner&amp;#64;redhat.com&amp;gt;
Date:   Wed Aug 29 22:21:32 2018 +0200

    bpo-34523: Support surrogatepass in locale codecs (GH-8995)

    Add support for the &amp;quot;surrogatepass&amp;quot; error handler in
    PyUnicode_DecodeFSDefault() and PyUnicode_EncodeFSDefault()
    for the UTF-8 encoding.

    Changes:

    * _Py_DecodeUTF8Ex() and _Py_EncodeUTF8Ex() now support the
      surrogatepass error handler (_Py_ERROR_SURROGATEPASS).
    * _Py_DecodeLocaleEx() and _Py_EncodeLocaleEx() now use
      the _Py_error_handler enum instead of &amp;quot;int surrogateescape&amp;quot; to pass
      the error handler. These functions now return -3 if the error
      handler is unknown.
    * Add unit tests on _Py_DecodeLocaleEx() and _Py_EncodeLocaleEx()
      in test_codecs.
    * Rename get_error_handler() to _Py_GetErrorHandler() and expose it
      as a private function.
    * _freeze_importlib doesn't need config.filesystem_errors=&amp;quot;strict&amp;quot;
      workaround anymore.
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;PyUnicode_DecodeFSDefault()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;PyUnicode_EncodeFSDefault()&lt;/tt&gt; functions
use &lt;tt class="docutils literal"&gt;Py_DecodeLocale()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;Py_EncodeLocale()&lt;/tt&gt; before the Python codec of
the filesystem encoding is loaded. With this big change, &lt;tt class="docutils literal"&gt;Py_DecodeLocale()&lt;/tt&gt;
and &lt;tt class="docutils literal"&gt;Py_EncodeLocale()&lt;/tt&gt; now really behave as the Python codec.&lt;/p&gt;
&lt;p&gt;Previously, Python started with the &lt;tt class="docutils literal"&gt;surrogateescape&lt;/tt&gt; error handler, and
switched to the &lt;tt class="docutils literal"&gt;surrogatepass&lt;/tt&gt; error handler once the Python codec was
loaded.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="filesystem-encoding-documentation"&gt;
&lt;h2&gt;Filesystem encoding documentation&lt;/h2&gt;
&lt;p&gt;One &amp;quot;last&amp;quot; change, I documented how Python selects the filesystem encoding,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/de427556746aa41a8b5198924ce423021bc0c718"&gt;commit de427556&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Author: Victor Stinner &amp;lt;vstinner&amp;#64;redhat.com&amp;gt;
Date:   Wed Aug 29 23:26:55 2018 +0200

    bpo-34523: Py_FileSystemDefaultEncoding NULL by default (GH-9003)

    * Py_FileSystemDefaultEncoding and Py_FileSystemDefaultEncodeErrors
      default value is now NULL: initfsencoding() set them
      during Python initialization.
    * Document how Python chooses the filesystem encoding and error
      handler.
    * Add an assertion to _PyCoreConfig_Read().
&lt;/pre&gt;
&lt;p&gt;Documentation:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
/* Python filesystem encoding and error handler:
   sys.getfilesystemencoding() and sys.getfilesystemencodeerrors().

   Default encoding and error handler:

   * if Py_SetStandardStreamEncoding() has been called: they have the
     highest priority;
   * PYTHONIOENCODING environment variable;
   * The UTF-8 Mode uses UTF-8/surrogateescape;
   * locale encoding: ANSI code page on Windows, UTF-8 on Android,
     LC_CTYPE locale encoding on other platforms;
   * On Windows, &amp;quot;surrogateescape&amp;quot; error handler;
   * &amp;quot;surrogateescape&amp;quot; error handler if the LC_CTYPE locale is &amp;quot;C&amp;quot; or &amp;quot;POSIX&amp;quot;;
   * &amp;quot;surrogateescape&amp;quot; error handler if the LC_CTYPE locale has been coerced
     (PEP 538);
   * &amp;quot;strict&amp;quot; error handler.

   Supported error handlers: &amp;quot;strict&amp;quot;, &amp;quot;surrogateescape&amp;quot; and
   &amp;quot;surrogatepass&amp;quot;. The surrogatepass error handler is only supported
   if Py_DecodeLocale() and Py_EncodeLocale() use directly the UTF-8 codec;
   it's only used on Windows.

   initfsencoding() updates the encoding to the Python codec name.
   For example, &amp;quot;ANSI_X3.4-1968&amp;quot; is replaced with &amp;quot;ascii&amp;quot;.

   On Windows, sys._enablelegacywindowsfsencoding() sets the
   encoding/errors to mbcs/replace at runtime.


   See Py_FileSystemDefaultEncoding and Py_FileSystemDefaultEncodeErrors.
   */
char *filesystem_encoding;
char *filesystem_errors;
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="final-freebsd-10-issue"&gt;
&lt;h2&gt;Final FreeBSD 10 issue&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="https://bugs.python.org/issue34544"&gt;bpo-34544&lt;/a&gt;: The stdio and filesystem
encodings are now properly selected before Py_Initialize(), the LC_CTYPE locale
should be properly initialized, the &amp;quot;POSIX&amp;quot; locale is now properly handled, but
the FreeBSD 10 buildbot still complained about my recent changes... Many
&lt;tt class="docutils literal"&gt;test_c_locale_coerce&lt;/tt&gt; tests started to fail with:&lt;/p&gt;
&lt;blockquote&gt;
Fatal Python error: get_locale_encoding: failed to get the locale encoding: nl_langinfo(CODESET) failed&lt;/blockquote&gt;
&lt;p&gt;Sadly, I wasn't able to reproduce the issue on my FreeBSD 11 VM. I also got
access to the FreeBSD CURRENT buildbot, but I also failed to reproduce the bug
there. I was supposed to get access to the FreeBSD 10 buildbot, but there was a
DNS issue.&lt;/p&gt;
&lt;p&gt;I had to &lt;em&gt;guess&lt;/em&gt; the origin of the bug and I attempted a fix, &lt;a class="reference external" href="https://github.com/python/cpython/commit/f01b2a1b84ee08df73a78cf1017eecf15e3cb995"&gt;commit f01b2a1b&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Author: Victor Stinner &amp;lt;vstinner&amp;#64;redhat.com&amp;gt;
Date:   Mon Sep 3 14:38:21 2018 +0200

    bpo-34544: Fix setlocale() in pymain_read_conf() (GH-9041)

    bpo-34485, bpo-34544: On some FreeBSD, nl_langinfo(CODESET) fails if
    LC_ALL or LC_CTYPE is set to an invalid locale name. Replace
    _Py_SetLocaleFromEnv(LC_CTYPE) with _Py_SetLocaleFromEnv(LC_ALL) to
    initialize properly locales.

    Partially revert commit 177d921c8c03d30daa32994362023f777624b10d.
&lt;/pre&gt;
&lt;p&gt;... but it didn't work.&lt;/p&gt;
&lt;p&gt;I decided to install a FreeBSD 10 VM and one week later... I finally succeded
to reproduce the issue!&lt;/p&gt;
&lt;p&gt;The bug was that the &lt;tt class="docutils literal"&gt;_Py_CoerceLegacyLocale()&lt;/tt&gt; function doesn't restore the
LC_CTYPE to its previous value if it attempted to coerce the LC_CTYPE locale
but no locale worked.&lt;/p&gt;
&lt;p&gt;Previously, it didn't matter, since the LC_CTYPE locale was initialized again
later, or it was saved/restored indirectly. But with my latest changes, the
LC_CTYPE was left unchanged.&lt;/p&gt;
&lt;p&gt;The fix is just to restore LC_CTYPE if &lt;tt class="docutils literal"&gt;_Py_CoerceLegacyLocale()&lt;/tt&gt; fails,
&lt;a class="reference external" href="https://github.com/python/cpython/commit/8ea09110d413829f71d979d8c7073008cb87fb03"&gt;commit 8ea09110&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Author: Victor Stinner &amp;lt;vstinner&amp;#64;redhat.com&amp;gt;
Date:   Mon Sep 3 17:05:18 2018 +0200

    _Py_CoerceLegacyLocale() restores LC_CTYPE on fail (GH-9044)

    bpo-34544: If _Py_CoerceLegacyLocale() fails to coerce the C locale,
    restore the LC_CTYPE locale to the its previous value.
&lt;/pre&gt;
&lt;p&gt;Finally, I succeded to do what I wanted to do initially, remove the code which
saved/restored the LC_ALL locale: &lt;tt class="docutils literal"&gt;pymain_read_conf()&lt;/tt&gt; is now really
responsible to set the LC_CTYPE locale, and it doesn't modify the LC_ALL locale
anymore.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="configuration-of-locales-and-encodings"&gt;
&lt;h2&gt;Configuration of locales and encodings&lt;/h2&gt;
&lt;p&gt;Python has &lt;strong&gt;many&lt;/strong&gt; options to configure the locales and encodings.&lt;/p&gt;
&lt;p&gt;Main options of Python 3.7:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Legacy Windows stdio (PEP 528)&lt;/li&gt;
&lt;li&gt;Legacy Windows filesystem encoding (PEP 529)&lt;/li&gt;
&lt;li&gt;C locale coercion (PEP 538)&lt;/li&gt;
&lt;li&gt;UTF-8 mode (PEP 540)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The combination of C locale coercion and UTF-8 mode is non-obvious and should
be carefully tested!&lt;/p&gt;
&lt;p&gt;Environment variables:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PYTHONCOERCECLOCALE=0&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PYTHONCOERCECLOCALE=1&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PYTHONCOERCECLOCALE=warn&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;PYTHONIOENCODING=:&amp;lt;errors&amp;gt;&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;PYTHONIOENCODING=&amp;lt;encoding&amp;gt;:&amp;lt;errors&amp;gt;&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;PYTHONIOENCODING=&amp;lt;encoding&amp;gt;&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PYTHONLEGACYWINDOWSFSENCODING=1&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PYTHONLEGACYWINDOWSSTDIO=1&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PYTHONUTF8=0&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;PYTHONUTF8=1&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Command line options:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-X&lt;/span&gt; utf8=0&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-X&lt;/span&gt; utf8&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-X&lt;/span&gt; utf8=1&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-E&lt;/span&gt;&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-I&lt;/span&gt;&lt;/tt&gt; (ignore &lt;tt class="docutils literal"&gt;PYTHON*&lt;/tt&gt; environment variables)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Global configuration variables:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_FileSystemDefaultEncodeErrors&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_FileSystemDefaultEncoding&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_LegacyWindowsFSEncodingFlag&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_LegacyWindowsStdioFlag&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Py_UTF8Mode&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;_PyCoreConfig:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;coerce_c_locale&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;coerce_c_locale_warn&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;filesystem_encoding&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;filesystem_errors&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;stdio_encoding&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;stdio_errors&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The LC_CTYPE locale depends on 3 environment variables:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;LC_ALL&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;LC_CTYPE&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;LANG&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Depending on the platform, the following configuration gives a different
LC_CTYPE locale:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;LC_ALL= LC_CTYPE= LANG=&lt;/tt&gt; (no variable set)&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;LC_ALL= LC_CTYPE=C LANG=&lt;/tt&gt; (C locale)&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;LC_ALL= LC_CTYPE=POSIX LANG=&lt;/tt&gt; (POSIX locale)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In case of doubt, I also tested:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;LC_ALL=C LC_CTYPE= LANG=&lt;/tt&gt; (C locale)&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;LC_ALL=POSIX LC_CTYPE= LANG=&lt;/tt&gt; (POSIX locale)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The LC_CTYPE encoding (locale encoding) can be queried using
&lt;tt class="docutils literal"&gt;nl_langinfo(CODESET)&lt;/tt&gt;. On FreeBSD, Solaris, HP-UX and maybe other platforms,
&lt;tt class="docutils literal"&gt;nl_langinfo(CODESET)&lt;/tt&gt; announces an encoding which is different than the
codec used by &lt;tt class="docutils literal"&gt;mbstowcs()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;wcstombs()&lt;/tt&gt; functions, and so Python forces
the usage of the ASCII encoding.&lt;/p&gt;
&lt;p&gt;The test matrix of all these configurations and all platforms is quite big.
Honestly, I would not bet that Python 3.8 will behave properly in all possible
cases. At least, I tried to fix all issues that I spotted! Moreover, I added
many tests which should help to detect bugs and prevent regressions.&lt;/p&gt;
&lt;/div&gt;
</content><category term="cpython"></category><category term="unicode"></category><category term="locales"></category></entry></feed>